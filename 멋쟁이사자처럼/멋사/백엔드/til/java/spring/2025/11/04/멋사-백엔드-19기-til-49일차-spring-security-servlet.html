<!DOCTYPE html>
<html lang="kor">

    <head><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<link href="https://fonts.googleapis.com/css?family=Merriweather:300|Raleway:400,700" rel="stylesheet">
<link rel="icon" href="/seonghun120614/assets/img/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/seonghun120614/assets/css/style.css">
<title>[멋사 백엔드 19기] TIL 49일차 Spring Security Servlet</title>
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>[멋사 백엔드 19기] TIL 49일차 Spring Security Servlet | Seonghun’s Blog</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="[멋사 백엔드 19기] TIL 49일차 Spring Security Servlet" />
<meta name="author" content="Seonghun Park" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description." />
<meta property="og:description" content="Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description." />
<link rel="canonical" href="https://seonghun120614.github.io/seonghun120614/%EB%A9%8B%EC%9F%81%EC%9D%B4%EC%82%AC%EC%9E%90%EC%B2%98%EB%9F%BC/%EB%A9%8B%EC%82%AC/%EB%B0%B1%EC%97%94%EB%93%9C/til/java/spring/2025/11/04/%EB%A9%8B%EC%82%AC-%EB%B0%B1%EC%97%94%EB%93%9C-19%EA%B8%B0-til-49%EC%9D%BC%EC%B0%A8-spring-security-servlet.html" />
<meta property="og:url" content="https://seonghun120614.github.io/seonghun120614/%EB%A9%8B%EC%9F%81%EC%9D%B4%EC%82%AC%EC%9E%90%EC%B2%98%EB%9F%BC/%EB%A9%8B%EC%82%AC/%EB%B0%B1%EC%97%94%EB%93%9C/til/java/spring/2025/11/04/%EB%A9%8B%EC%82%AC-%EB%B0%B1%EC%97%94%EB%93%9C-19%EA%B8%B0-til-49%EC%9D%BC%EC%B0%A8-spring-security-servlet.html" />
<meta property="og:site_name" content="Seonghun’s Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-11-04T00:45:31+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="[멋사 백엔드 19기] TIL 49일차 Spring Security Servlet" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Seonghun Park"},"dateModified":"2025-11-04T00:45:31+00:00","datePublished":"2025-11-04T00:45:31+00:00","description":"Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.","headline":"[멋사 백엔드 19기] TIL 49일차 Spring Security Servlet","mainEntityOfPage":{"@type":"WebPage","@id":"https://seonghun120614.github.io/seonghun120614/%EB%A9%8B%EC%9F%81%EC%9D%B4%EC%82%AC%EC%9E%90%EC%B2%98%EB%9F%BC/%EB%A9%8B%EC%82%AC/%EB%B0%B1%EC%97%94%EB%93%9C/til/java/spring/2025/11/04/%EB%A9%8B%EC%82%AC-%EB%B0%B1%EC%97%94%EB%93%9C-19%EA%B8%B0-til-49%EC%9D%BC%EC%B0%A8-spring-security-servlet.html"},"url":"https://seonghun120614.github.io/seonghun120614/%EB%A9%8B%EC%9F%81%EC%9D%B4%EC%82%AC%EC%9E%90%EC%B2%98%EB%9F%BC/%EB%A9%8B%EC%82%AC/%EB%B0%B1%EC%97%94%EB%93%9C/til/java/spring/2025/11/04/%EB%A9%8B%EC%82%AC-%EB%B0%B1%EC%97%94%EB%93%9C-19%EA%B8%B0-til-49%EC%9D%BC%EC%B0%A8-spring-security-servlet.html"}</script>
<!-- End Jekyll SEO tag -->


<script type="text/javascript" src="/seonghun120614/assets/js/darkmode.js"></script>

<!-- Mermaid -->
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-RQTWJRLWGD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-RQTWJRLWGD');
</script></head><script>
        document.addEventListener("DOMContentLoaded", function () {
            const toggle = document.getElementById("dark-toggle");
        
            // 이미 실행한 적 있는지 확인
            const hasToggled = localStorage.getItem("darkModeInitialized");
        
            if (!hasToggled && toggle && toggle.checked) {
                toggleDarkMode();
                localStorage.setItem("darkModeInitialized", "true"); // 최초 실행 기록
            }
        });
    </script>

    <body>
        <div id="scroll-progress"></div>
        <main class="container">
            <section class="about">
                <div class="about-header condensed">
                    <div class="about-title">
                        <a href="/seonghun120614/">
                            
                            <img class="light"
                                src="/seonghun120614/assets/portfolio.png"
                                alt="Seonghun Park" />
                            <img class="dark"
                                src="/seonghun120614/assets/portfolio.png"
                                alt="Seonghun Park" />
                            
                        </a>
                        <h2 id="title">
                            <a href="/seonghun120614/">Seonghun Park</a>
                        </h2>
                    </div><p class="tagline">Developer.</p></div>
                
                <ul class="social about-footer condensed"><li>
                        <a
                            href="https://github.com/seonghun120614"
                            target="_blank"
                            rel="noopener"
                            aria-label="github">
                            <i class="icon-github-circled"></i>
                        </a>
                    </li><li>
                        <a
                            href="mailto:seonghun120614@gmail.com"
                            target="_blank" rel="noopener" aria-label="email">
                            <i class="icon-mail-alt"></i>
                        </a>
                    </li></ul><nav class="navigation about-footer condensed">
                    <ul>
                        
                        <li>
                            <a href="/seonghun120614/about">About Me</a>
                        </li>
                        
                        <li>
                            <a href="/seonghun120614/categories/computerscience">Computer Science</a>
                        </li>
                        
                        <li>
                            <a href="/seonghun120614/categories/math">Math</a>
                        </li>
                        
                        <li>
                            <a href="/seonghun120614/categories/softwareengineering">Software Engineering</a>
                        </li>
                        
                    </ul>
                </nav><p class="about-footer condensed">&copy;
                    2025</p><div class="about-footer condensed">
                    <p>Dark Mode
                        <i class="icon-moon"></i>
                        <label class="switch" for="dark-toggle">
                            <input id="dark-toggle" type="checkbox"
                                class="dark-mode-toggle"
                                aria-label="Toggle dark mode">
                            <span class="slider round"
                                onclick="toggleDarkMode()"></span>
                        </label>
                    </p>
                </div>
            </section>
            <section class="content">
                <script>
window.MathJax = {
    tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']]
    },
    options: {
    renderActions: {
        addMenu: []
    }
    }
};
</script>

<script type="text/javascript"
    id="MathJax-script"
    async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script><div class="post-container">
    <a class="post-link" href="/seonghun120614/%EB%A9%8B%EC%9F%81%EC%9D%B4%EC%82%AC%EC%9E%90%EC%B2%98%EB%9F%BC/%EB%A9%8B%EC%82%AC/%EB%B0%B1%EC%97%94%EB%93%9C/til/java/spring/2025/11/04/%EB%A9%8B%EC%82%AC-%EB%B0%B1%EC%97%94%EB%93%9C-19%EA%B8%B0-til-49%EC%9D%BC%EC%B0%A8-spring-security-servlet.html">
        <h2 class="post-title">[멋사 백엔드 19기] TIL 49일차 Spring Security Servlet</h2>
    </a>
    
    <div class="post-meta">
        <div class="post-date"><i class="icon-calendar"></i>Nov 4, 2025</div><ul class="post-categories"><li>멋쟁이사자처럼</li><li>멋사</li><li>백엔드</li><li>TIL</li><li>Java</li><li>Spring</li></ul></div>

    <div class="post">
        <!--more-->

<h2 id="-목차">📂 목차</h2>

<ul>
  <li><a href="#spring-security">Spring Security</a>
    <ul>
      <li><a href="#architecture">Architecture</a>
        <ul>
          <li><a href="#filters">Filters</a></li>
          <li><a href="#delegatingfilterproxy">DelegatingFilterProxy</a></li>
          <li><a href="#filterchainproxy">FilterChainProxy</a></li>
          <li><a href="#securityfilterchain">SecurityFilterChain</a></li>
          <li><a href="#securityfilters">SecurityFilters</a></li>
          <li><a href="#체인-디버깅하기">체인 디버깅하기</a></li>
          <li><a href="#spring-filters-출력">Spring Filters 출력</a></li>
          <li><a href="#필터-체인에-필터-추가하기">필터 체인에 필터 추가하기</a></li>
          <li><a href="#adding-custom-filter">Adding Custom Filter</a></li>
          <li><a href="#declaring-custom-filter-as-bean-with-filterregistrationbean">Declaring Custom Filter as Bean with FilterRegistrationBean</a></li>
          <li><a href="#customizing-a-spring-security-filter">Customizing a Spring Security Filter</a></li>
          <li><a href="#exceptiontranslationfilter">ExceptionTranslationFilter</a></li>
          <li><a href="#saving-requests-between-authentication">Saving Requests Between Authentication</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="-본문">📚 본문</h2>

<h3 id="spring-security">Spring Security</h3>

<p>어플리케이션 보안은 서블릿과 리액티브 용으로 나뉘지만 이를 보기 전에 전반적인 아키텍쳐를 바라본다.</p>

<h4 id="architecture">Architecture</h4>

<p><img src="/seonghun120614/assets/img/filter-chain.png" alt="assets/img/filter-chain.png" /></p>

<p>우선 서블릿에서의 security 역할을 먼저 보자. 서블릿에서의 Spring Security 는 가장 중요한 개념인 <strong>Servlet Filters</strong> 를 기반으로 하기 때문에, 먼저 필터의 개념과 역할을 살펴보는게 좋다.</p>

<h5 id="filters">Filters</h5>

<p>클라이언트가 어플리케이션에 요청을 보내면, 컨테이너는 <code class="language-plaintext highlighter-rouge">FilterChain</code> 을 생성하게 된다. <code class="language-plaintext highlighter-rouge">FilterChain</code> 은 요청 <code class="language-plaintext highlighter-rouge">URI</code> 의 경로에 따라 해당 요청을 처리해야 하는 <code class="language-plaintext highlighter-rouge">FilterChain</code> 인스턴스 와 <strong>Servlet</strong> 을 포함한다.</p>

<p>Spring MVC 어플리케이션은 이 Servlet 이 <code class="language-plaintext highlighter-rouge">DispatcherServlet</code> 의 인스턴스이며, 하나의 <code class="language-plaintext highlighter-rouge">HttpServletRequest</code> 와 <code class="language-plaintext highlighter-rouge">HttpServletResponse</code> 는 최대 하나의 <code class="language-plaintext highlighter-rouge">Servlet</code> 만이 처리할 수 있다.</p>

<p>하지만 여러 개의 <code class="language-plaintext highlighter-rouge">Filter</code> 는 서블릿과 다르게 여러 개를 함께 사용할 수 있고, 그 목적은 다음과 같다:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">FilterChain</code> 내 다음 순서의 다른 <code class="language-plaintext highlighter-rouge">Filter</code> 인스턴스나 <code class="language-plaintext highlighter-rouge">Servlet</code> 이 호출되지 않도록 차단함, 이 경우에는 해당 <code class="language-plaintext highlighter-rouge">Filter</code> 가 직접 <code class="language-plaintext highlighter-rouge">HttpServletResponse</code> 를 작성하게 된다.</p>
  </li>
  <li>
    <p>하위 <code class="language-plaintext highlighter-rouge">Filter</code> 인스턴스 혹은 <code class="language-plaintext highlighter-rouge">Servlet</code> 이 사용할 <code class="language-plaintext highlighter-rouge">HttpServletResponse</code> 를 작성한다. 즉, 현재 필터가 요청이나 응답을 가로채서 바꾼뒤 다음 필터나 서블릿에게 전달이 가능하다는 것이다(doFilter 쪽).</p>
  </li>
</ul>

<p>두 번째 경우가 가장 많이 쓰이는데 다음을 보자.</p>

<p><strong>Request 수정</strong></p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">doFilter</span><span class="o">(</span><span class="nc">ServletRequest</span> <span class="n">request</span><span class="o">,</span>
                     <span class="nc">ServletResponse</span> <span class="n">response</span><span class="o">,</span>
                     <span class="nc">FilterChain</span> <span class="n">chain</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span> <span class="nc">ServletException</span> <span class="o">{</span>
    
    <span class="nc">HttpServletRequest</span> <span class="n">httpRequest</span> <span class="o">=</span> <span class="o">(</span><span class="nc">HttpServletRequest</span><span class="o">)</span> <span class="n">request</span><span class="o">;</span>

    <span class="c1">// HttpServletRequest를 감싸서 헤더를 수정할 수 있는 Wrapper를 만듦</span>
    <span class="nc">HttpServletRequestWrapper</span> <span class="n">wrappedRequest</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HttpServletRequestWrapper</span><span class="o">(</span><span class="n">httpRequest</span><span class="o">)</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getHeader</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="s">"Authorization"</span><span class="o">.</span><span class="na">equalsIgnoreCase</span><span class="o">(</span><span class="n">name</span><span class="o">))</span>
                <span class="k">return</span> <span class="s">"Bearer dummy-token"</span><span class="o">;</span> <span class="c1">// 새로운 헤더 값 주입</span>
            <span class="k">return</span> <span class="kd">super</span><span class="o">.</span><span class="na">getHeader</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">};</span>

    <span class="c1">// 수정된 요청 객체를 다음 Filter나 Servlet에게 넘김</span>
    <span class="n">chain</span><span class="o">.</span><span class="na">doFilter</span><span class="o">(</span><span class="n">wrappedRequest</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p>이 경우에 원래 <code class="language-plaintext highlighter-rouge">Authorization</code> 헤더가 없던 요청이, 다음 서블릿으로 넘어갈 때에는 <code class="language-plaintext highlighter-rouge">Authorization: Bearer dummy-token</code> 을 가진 요청으로 바뀐다. 이 역할은 <code class="language-plaintext highlighter-rouge">HttpServletRequestWrapper</code> 로 하게 된다.</p>

<p><strong>Response 수정</strong></p>

<p>응답을 다음처럼 수정하는 경우가 많다. 모든 응답에 공통 보안 헤더를 추가하고 싶을 때:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">doFilter</span><span class="o">(</span><span class="nc">ServletRequest</span> <span class="n">request</span><span class="o">,</span>
                     <span class="nc">ServletResponse</span> <span class="n">response</span><span class="o">,</span>
                     <span class="nc">FilterChain</span> <span class="n">chain</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span> <span class="nc">ServletException</span> <span class="o">{</span>

    <span class="nc">HttpServletResponse</span> <span class="n">httpResponse</span> <span class="o">=</span> <span class="o">(</span><span class="nc">HttpServletResponse</span><span class="o">)</span> <span class="n">response</span><span class="o">;</span>

    <span class="c1">// 체인 내 다음 필터나 서블릿을 먼저 실행</span>
    <span class="n">chain</span><span class="o">.</span><span class="na">doFilter</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>

    <span class="c1">// 응답에 공통 헤더 추가</span>
    <span class="n">httpResponse</span><span class="o">.</span><span class="na">setHeader</span><span class="o">(</span><span class="s">"X-Security-Checked"</span><span class="o">,</span> <span class="s">"true"</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p>이 경우는 서블릿이 응답을 만든 뒤, 필터들을 거치게 되는데 그 응답을 받아서 <strong>헤더를 덧붙이고 최종 클라이언트로 전달</strong>하게 된다.</p>

<p>결국에는 컨트롤러에서는 데이터 바디만 처리하도록 할 수 있고, 책임은 필터쪽으로 넘기게 되는 것이다.</p>

<blockquote>
  <p>필터는 다운스트림 필터 인스턴스와 서블릿에만 영향을 미치므로 각 필터가 호출되는 순서는 매우 중요</p>
</blockquote>

<h5 id="delegatingfilterproxy">DelegatingFilterProxy</h5>

<p>Spring 의 필터에는 가장 중요한 필터 구현체인 <strong>DelegatingFilterProxy</strong> 가 있다. 서블릿 <strong>컨테이너(톰캣 등등)</strong> 와 <code class="language-plaintext highlighter-rouge">SpringApplicationContext</code> 사이를 연결해주는 다리 역할을 한다.</p>

<p>이런게 필요한 이유는 서블릿 컨테이너는 원래 자바 표준인 <code class="language-plaintext highlighter-rouge">javax.servlet.Filter</code> 를 인식한다. 이 말은 즉슨 필터 인스턴스를 등록하면 요청과 응답을 가로채서 처리할 수 있게 된다.</p>

<p>그런데 문제는 <strong>서블릿 컨테이너는 Spring 이 관리하는 Bean 을 모른다는 것이다</strong>(스프링 컨텍스트 IoC 는 완전히 별개의 프로그래밍 언어로 구성되기 때문).</p>

<p>따라서 다음과 같은 상황이 생기게 된다:</p>
<ul>
  <li>톰캣: 필터는 등록했는데 얘는 그냥 자바 객체라 해석할 수 없다</li>
  <li>스프링: 필터는 내가 관리하는 빈으로 등록했는데 톰캣이 그걸 모름</li>
</ul>

<p>그래서 등장한 것이 <code class="language-plaintext highlighter-rouge">DelegatingFilterProxy</code> 로 말 그대로 필터를 위임하는 것이다.</p>

<ol>
  <li>서블릿 컨테이너는 <code class="language-plaintext highlighter-rouge">DelegatingFilterProxy</code> 라는 껍데기 필터를 등록하고</li>
  <li>실제 로직은 Spring 이 관리하는 <code class="language-plaintext highlighter-rouge">Bean</code>(진짜 필터 구현체) 에게 위임하는 방식</li>
</ol>

<figure class="highlight"><pre><code class="language-text" data-lang="text">[Client Request]
      ↓
[Servlet Container]
      ↓
[DelegatingFilterProxy]  ← (등록된 표준 서블릿 필터)
      ↓
[Spring Bean: 실제 Filter 구현체]  ← (Spring이 관리)
      ↓
[DispatcherServlet → Controller ...]</code></pre></figure>

<p>따라서 Spring Security 의 진입점이 바로 이 구조이다. <code class="language-plaintext highlighter-rouge">DelegatingFilterProxy</code> 가 서블릿 컨테이너에 등록되어 있고, 실제 필터 체인은 스프링 컨텍스트 안의 <code class="language-plaintext highlighter-rouge">springSecurityFilterChain</code> 이라는 빈이 담당하게 된다(실제로 <code class="language-plaintext highlighter-rouge">springSecurityFilterChain</code> 이라는 것을 함수 빈으로 등록하려고 하면 실행 시 오류가 뜬다. 동일 빈으로 등록할 수 없기 때문이다).</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Bean</span>
<span class="kd">public</span> <span class="nc">Filter</span> <span class="nf">springSecurityFilterChain</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// 여기에 수많은 SecurityFilter들이 체인 형태로 연결됨</span>
<span class="o">}</span></code></pre></figure>

<p>이제 그러면 톰캣 입장에서는 <code class="language-plaintext highlighter-rouge">DelegatingFilterProxy</code> 만 알면, 실제 필터는 Spring 이 관리하게 되며 Spring 이 이를 연결시키게 되는 것이다.</p>

<p><strong>정리</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Servlet Container</code>: 필터의 생명주기를 관리하지만, 스프링 빈은 모름</li>
  <li><code class="language-plaintext highlighter-rouge">Spring Application</code>: 스프링 빈을 관리하지만, 서블릿 컨테이너는 모름</li>
  <li><code class="language-plaintext highlighter-rouge">DelegatingFilterProxy</code>: 둘 사이를 연결하는 위임 필터이며 프록시 역할을 함</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">DelegatingFilterProxy</code> 는 서블릿 컨테이너와 스프링 컨텍스트의 필터 연결 어댑터이다. <strong>Spring Security</strong>, <strong>Spring Session</strong>, <strong>Spring Web Flow</strong> 등등과 같은 보안/세션 관련 기능들은 전부 이 구조를 기반으로 돌아가게 된다.</p>

<p>아래는 그 예시이다.</p>

<p><img src="/seonghun120614/assets/img/delegating-filter-proxy.png" alt="assets/img/delegating-filter-proxy.png" /></p>

<p><code class="language-plaintext highlighter-rouge">DelegatingFilterProxy</code> 는 <code class="language-plaintext highlighter-rouge">ApplicationContext</code> 에서 <code class="language-plaintext highlighter-rouge">Filter0</code> 라는 <code class="language-plaintext highlighter-rouge">Bean</code> 을 찾아낸 다음 그 <code class="language-plaintext highlighter-rouge">Filter0</code> 를 호출하게 된다. 아래 예시는 DelegatingFilterProxy 의 동작 방식을 보여주는 pseudo code 이다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">doFilter</span><span class="o">(</span><span class="nc">ServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">ServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">FilterChain</span> <span class="n">chain</span><span class="o">)</span> <span class="o">{</span>
	<span class="nc">Filter</span> <span class="n">delegate</span> <span class="o">=</span> <span class="n">getFilterBean</span><span class="o">(</span><span class="n">someBeanName</span><span class="o">);</span>
	<span class="n">delegate</span><span class="o">.</span><span class="na">doFilter</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p>Spring Bean 으로 등록된 <code class="language-plaintext highlighter-rouge">Filter</code> 를 <strong>lazy</strong> 해서 가져오게 되며, <code class="language-plaintext highlighter-rouge">DelegatingFilterProxy</code> 의 예시에서는 delegate 가 Bean Filter0 의 인스턴스이다.</p>

<ul>
  <li>실제 작업 처리는 <code class="language-plaintext highlighter-rouge">Filter</code> 에게 위임</li>
  <li><code class="language-plaintext highlighter-rouge">DelegatingFilterProxy</code> 의 또 다른 장점으로 필터 빈 인스턴스 조회를 늦출 수 있다</li>
</ul>

<p>두 번째 내용은 톰캣과 같은 서블릿 컨테이너는 어플리케이션이 시잘될 때 가장 먼저 Filter들을 등록하게 된다. 필터는 <code class="language-plaintext highlighter-rouge">HTTP</code> 요청이 들어오는 가장 첫 시점에서 실행되기 때문에 가장 먼저 인스턴스가 등록되어야 한다.</p>

<blockquote>
  <p>필터 등록 &gt; 스프링 빈 로딩</p>
</blockquote>

<p>하지만 이때 문제가 생기는데, 예를 들어 우리의 Spring Security 의 필터를 스프링 빈으로 등록했다고 하자.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Bean</span>
<span class="kd">public</span> <span class="nc">Filter</span> <span class="nf">securityFilter</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">MySecurityFilter</span><span class="o">();</span>
<span class="o">}</span></code></pre></figure>

<p>톰캣이 필터를 등록해야 하는 시점에 아직 스프링 컨텍스트가 만들어지지 않았다는 것이다. 즉, <code class="language-plaintext highlighter-rouge">@Bean</code> 들은 아직 생성되지 않은 상태인데, 톰캣이 필터 인스턴스 좀 달라고 요청이 왔을 때, 스프링은 이와 같은 구현체 빈을 아직 가지고 있지 않아서 오류가 발생하게 된다.</p>

<p>이를 방지하는 것이 바로 <code class="language-plaintext highlighter-rouge">DelegatingFilterProxy</code> 이며, 이 일반화 된 필터는 다른 필터를 <code class="language-plaintext highlighter-rouge">Lazy Lookup</code> 기법을 사용하여 스프링 컨텍스트가 나중에 열린 후에 거기 있는 진짜 필터를 찾아와서 연결하는 역할을 하게 된다.</p>

<blockquote>
  <p>DelegatingFilterProxy 와 함께 필터 등록 &gt; 스프링 빈 로딩 &gt; 진짜 필터 찾아서 연결</p>
</blockquote>

<h5 id="filterchainproxy">FilterChainProxy</h5>

<p><img src="/seonghun120614/assets/img/delegating-filter-proxy.png" alt="assets/img/delegating-filter-proxy.png" /></p>

<p>지금처럼 스프링 시큐리티의 구조에서 이제 <code class="language-plaintext highlighter-rouge">DelegatingFilterProxy</code> -&gt; <code class="language-plaintext highlighter-rouge">FilterChainProxy</code> 를 보자.</p>

<p><code class="language-plaintext highlighter-rouge">DelegatingFilterProxy</code> 는 톰캣과 스프링의 컨텍스트의 생명주기 불일치를 해결하기 위한 설계적 해법임을 위에서 보았다. 이때 톰캣은 서블릿 필터를 시작 지점에 등록해야 하지만, 스프링은 컨텍스트 초기화 이후에야 필터 빈을 생성할 수 있다.</p>

<p>즉 필터의 등록시점과 생성시점이 어긋나기 때문에, <code class="language-plaintext highlighter-rouge">DelegatingFilterProxy</code> 로 이 간극을 메워 등록은 톰캣이 먼저, 실행은 스프링이 나중에 실행하는 구조를 가지게 된다.</p>

<p>그리고 이 구조 위에 <code class="language-plaintext highlighter-rouge">FilterChainProxy</code> 가 있는데, <code class="language-plaintext highlighter-rouge">FilterChainProxy</code> 는 여러 <code class="language-plaintext highlighter-rouge">SecurityFilter</code> 를 체인 형태로 묶어 보안로직의 조립식 파이프라인을 구성하게 된다. Spring Security 의 실질적 동작은 전부 이 <code class="language-plaintext highlighter-rouge">FilterChainProxy</code> 내부에서 일어나게 된다.</p>

<h5 id="securityfilterchain">SecurityFilterChain</h5>

<p><img src="/seonghun120614/assets/img/security-filter-chain.png" alt="assets/img/security-filter-chain.png" /></p>

<p>이제 스프링 시큐리티의 핵심인 <code class="language-plaintext highlighter-rouge">SecurityFilterChain</code> 을 보자. <code class="language-plaintext highlighter-rouge">SecurityFilterChain</code> 안에 들어있는 <code class="language-plaintext highlighter-rouge">Security Filter</code> 들은 대부분 Spring Bean 이지만, 이 필터들은 <code class="language-plaintext highlighter-rouge">DelegatingFilterProxy</code> 에 직접 등록되지 않고 대신 <code class="language-plaintext highlighter-rouge">FilterChainProxy</code> 에 등록되게 된다.</p>

<p>이렇게 하는 이유는 다음과 같은 이점을 지니기 때문이다:</p>

<ol>
  <li>Spring Security 서블릿 지원의 시작점 (Entry Point)
    <ul>
      <li>서블릿 기반 보안 로직의 출발점이기 때문</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">FilterChainProxy</code> 는 공통적이고 필수적인 작업을 수행 하는 책임
    <ul>
      <li>따라서 중심부에 있기에, 모든 요청에 대해 반드시 수행해야 하는 작업들을 담당하도록 할 수 있음(<code class="language-plaintext highlighter-rouge">SecurityContext</code> 초기화 및 정리, <code class="language-plaintext highlighter-rouge">HttpFirewall</code> 적용)</li>
    </ul>
  </li>
  <li>요청 매칭의 유연성
    <ul>
      <li>서블릿 컨테이너의 기본 필터 구조는 URL 패턴만을 기준으로 필터를 호출하지만</li>
      <li><code class="language-plaintext highlighter-rouge">FilterChainProxy</code> 는 <code class="language-plaintext highlighter-rouge">RequestMatcher</code> 인터페이스 등을 사용하여 요청의 어떤 속성이든 매칭 조건으로 활용할 수 있게 된다.</li>
    </ul>
  </li>
  <li>여러 개의 <code class="language-plaintext highlighter-rouge">SecurityFilterChain</code>
    <ul>
      <li>하나의 어플리케이션에 여러 개의 <code class="language-plaintext highlighter-rouge">SecurityFilterChain</code> 이 존재할 수 있음</li>
    </ul>
  </li>
</ol>

<p>즉, <code class="language-plaintext highlighter-rouge">FilterChainProxy</code> 는 들어오는 요청을 보고 어떤 <code class="language-plaintext highlighter-rouge">SecurityFilterChain</code> 이 이 요청을 처리할지를 결정하고 그 체인 안의 필터들을 순서대로 실행하게 된다.</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">DelegatingFilterProxy</code> 는 <strong>스프링과 서블릿 세계를 연결</strong>하고,<br />
<code class="language-plaintext highlighter-rouge">FilterChainProxy</code> 는 <strong>요청 흐름을 보안 체인 단위로 관리</strong>하며,<br />
<code class="language-plaintext highlighter-rouge">SecurityFilterChain</code> 은 <strong>각 요청에 맞는 보안 규칙 세트를 정의</strong></p>
</blockquote>

<p>다음과 같은 여러 개의 보안 필터 체인을 가질 때 <code class="language-plaintext highlighter-rouge">Spring Security</code> 가 어떤 체인을 선택해서 실행하는지 보자.</p>

<p><img src="/seonghun120614/assets/img/multi-security-filter-chain.png" alt="assets/img/multi-security-filter-chain.png" /></p>

<p><code class="language-plaintext highlighter-rouge">FilterChainProxy</code> 는 들어오는 요청에 대해 어떤 <code class="language-plaintext highlighter-rouge">SecurityFilterChain</code> 을 사용할지 결정한다. 여러 체인 중 가장 먼저 매칭되는(<code class="language-plaintext highlighter-rouge">SecurityFilterChain</code>) “하나만” 실행된다.</p>

<p><strong>예시</strong></p>

<p>요청 URL 이 <code class="language-plaintext highlighter-rouge">/api/messages</code> 인 경우</p>

<ol>
  <li>첫번째 체인인 <code class="language-plaintext highlighter-rouge">SecurityFilterChain0</code> 의 패턴 <code class="language-plaintext highlighter-rouge">/api/**</code> 에 매칭</li>
  <li>따라서 <code class="language-plaintext highlighter-rouge">SecurityFilterChain0</code> 만 실행된다</li>
  <li>비록 <code class="language-plaintext highlighter-rouge">/api/messages/</code> 가 <code class="language-plaintext highlighter-rouge">SecurityFilterChainN</code> 의 패턴과 맞을 수도 있지만, 가장 먼저 일치한 체인만을 사용하는 것을 원칙으로 한다.</li>
</ol>

<blockquote>
  <p>심지어 필터가 0개 일 수도 있다.</p>
</blockquote>

<h5 id="securityfilters">SecurityFilters</h5>

<p><code class="language-plaintext highlighter-rouge">SecurityFilterChain</code> 은 내부적으로 여러 보안 필터(<code class="language-plaintext highlighter-rouge">Security Filter</code>) 들을 포하마고 있으며, 이 필터들은 <code class="language-plaintext highlighter-rouge">SecurityFilterChain API</code> 를 통해 <code class="language-plaintext highlighter-rouge">FilterChainProxy</code> 안에 삽입되게 된다.</p>

<p>즉, <code class="language-plaintext highlighter-rouge">FilterChainProxy</code> 가 전체 보안 파이프라인의 컨테이너라면, 그 안에 들어있는 개별 보안 모듈들이 바로 Security Filter 들이다.</p>

<p>필터들은 다양한 역할을 가질 수 있다.</p>

<p><strong>역할</strong></p>
<ul>
  <li>익스플로잇(취약점) 방어 - CSRF, 세션 고정, XSS 등 공격 차단</li>
  <li>인증(Authentication) - 사용자의 신원 확인</li>
  <li>인가(Authorization) - 해당 사용자가 특정 리소스에 접근 가능한지 확인</li>
</ul>

<p>이 모든 과정이 필터 체인 내부에서 순차적으로 일어나게 된다.</p>

<p>위에서 말했지만, 실행 순서는 중요하다. 보안 필터들은 정해진 순서로 실행되며, 인증이 끝나야 인가를 할 수 있고, 세션 검증이 끝나야 인증 절차를 시작할 수 있기 때문이다.</p>

<p>하지만 대부분의 경우는 순서를 직접 알 필요는 없으며, 일반적으로 Spring Security 가 내부적으로 필터들을 올바른 순서로 등록해주기 때문이다.</p>

<p>순서를 알아야할 경우는 다음 때가 있다:</p>
<ul>
  <li>커스텀 필터를 특정 필터 앞이나 뒤에 추가하고 싶을때</li>
  <li>디버깅 중 어떤 필터가 먼저 실행되는지 알고 싶을때</li>
</ul>

<p>이럴 땐 <code class="language-plaintext highlighter-rouge">FilterOrderRegistration</code> 코드를 참고하면, 각 필터가 어떤 순서로 실행되는지 확인할 수 있다.</p>

<p><strong>필터 등록 방법 - HttpSecurity</strong></p>

<p>이 보안 필터들을 대부분 HttpSecurity 를 통해 선언된다. 즉 우리가 흔히 작성하는 다음과 같은 설정 코드가 결국은 SecurityFilterChain 안의 필터들을 구성하는 명령이 된다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Override</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">configure</span><span class="o">(</span><span class="nc">HttpSecurity</span> <span class="n">http</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="n">http</span>
        <span class="o">.</span><span class="na">csrf</span><span class="o">().</span><span class="na">and</span><span class="o">()</span>
        <span class="o">.</span><span class="na">authorizeRequests</span><span class="o">()</span>
            <span class="o">.</span><span class="na">antMatchers</span><span class="o">(</span><span class="s">"/admin/**"</span><span class="o">).</span><span class="na">hasRole</span><span class="o">(</span><span class="s">"ADMIN"</span><span class="o">)</span>
            <span class="o">.</span><span class="na">anyRequest</span><span class="o">().</span><span class="na">authenticated</span><span class="o">()</span>
        <span class="o">.</span><span class="na">and</span><span class="o">()</span>
        <span class="o">.</span><span class="na">formLogin</span><span class="o">();</span>
<span class="o">}</span></code></pre></figure>

<ul>
  <li><code class="language-plaintext highlighter-rouge">.csrf()</code> - <code class="language-plaintext highlighter-rouge">CsrfFilter</code> 추가</li>
  <li><code class="language-plaintext highlighter-rouge">.authorizeRequests()</code> - <code class="language-plaintext highlighter-rouge">AuthorizationFilter</code> 추가</li>
  <li><code class="language-plaintext highlighter-rouge">.formLogin()</code> - <code class="language-plaintext highlighter-rouge">UserPasswordAuthenticationFilter</code> 추가</li>
</ul>

<p>즉, <code class="language-plaintext highlighter-rouge">HttpSecurity</code> 는 필터 체인을 선언적으로 조립하는 DSL 이라고 이해할 수 있다.</p>

<p>위 설정은 다음 실행 순서를 가진다</p>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">CsrfFilter</code>: <code class="language-plaintext highlighter-rouge">HttpSecurity#csrf</code>, CSRF 공격 차단을 위한 유효한 토큰을 포함하고 있는가?</p>
  </li>
  <li>Authentication 관련 필터
    <ul>
      <li><code class="language-plaintext highlighter-rouge">BasicAuthenticationFilter</code>: <code class="language-plaintext highlighter-rouge">HttpSecurity#httpBasic</code>, Http Basic 인증</li>
      <li><code class="language-plaintext highlighter-rouge">UsernamePasswordAuthenticationFilter</code>: <code class="language-plaintext highlighter-rouge">HttpSecurity#formLogin</code>, 폼 로그인 기반 인증</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">AuthorizationFilter</code>: <code class="language-plaintext highlighter-rouge">HttpSecurity#authorizeHttpRequests</code>
    <ul>
      <li>승인된 사용자(role 또는 권한을 가진 사용자) 인지 확인</li>
    </ul>
  </li>
</ol>

<blockquote>
  <p>이 외에도 다양한 필터들이 존재한다.<br />
SecurityContextPersistenceFilter<br />
LogoutFilter<br />
ExceptionTranslationFilter<br />
RequestCacheAwareFilter<br />
…</p>
</blockquote>

<p><strong>이들은 HttpSecurity 설정의 세부 옵션에 따라 추가되기도 하고 생략되기도 한다.</strong></p>

<h5 id="체인-디버깅하기">체인 디버깅하기</h5>

<p>Spring Security 는 내부적으로 요청마다 어떤 필터 체인이 구성되어 있는지 로깅할 수 있다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">import</span> <span class="nn">org.springframework.security.web.FilterChainProxy</span><span class="o">;</span>

<span class="nd">@Autowired</span>
<span class="kd">private</span> <span class="nc">FilterChainProxy</span> <span class="n">filterChainProxy</span><span class="o">;</span>

<span class="nd">@PostConstruct</span> <span class="c1">// 자바 표준(JSR-250) 에 정의된 애너테이션이며, 이 객체가 완전히 준비된 다음에 딱 한 번 실행해줘 라는 의미이다.</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">printFilters</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">filterChainProxy</span><span class="o">.</span><span class="na">getFilterChains</span><span class="o">().</span><span class="na">forEach</span><span class="o">(</span><span class="n">chain</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"=== Security FilterChain for pattern: "</span> <span class="o">+</span> <span class="n">chain</span><span class="o">.</span><span class="na">getRequestMatcher</span><span class="o">());</span>
        <span class="n">chain</span><span class="o">.</span><span class="na">getFilters</span><span class="o">().</span><span class="na">forEach</span><span class="o">(</span><span class="n">f</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">" - "</span> <span class="o">+</span> <span class="n">f</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getSimpleName</span><span class="o">()));</span>
    <span class="o">});</span>
<span class="o">}</span></code></pre></figure>

<blockquote>
  <p>보통 스프링 시큐리티의 <code class="language-plaintext highlighter-rouge">Configuration</code> 이나 <code class="language-plaintext highlighter-rouge">Component</code> 로 등록된 하나에만 작성하면 된다.<br />
다만 <code class="language-plaintext highlighter-rouge">FilterChainProxy</code> 빈은 Spring Security 가 내부적으로 등록하기 때문에<br />
<code class="language-plaintext highlighter-rouge">SpringAutoConfiguration</code> 이 완료된 이후에만 접근할 수 있다.</p>
</blockquote>

<h5 id="spring-filters-출력">Spring Filters 출력</h5>

<p>보통 특정 요청에 대해 어떤 보안 필터들이 실제로 호출되는지 확인하고 싶을 때가 있을 것이다.</p>

<p><strong>어플리케이션 시작 시 필터 목록 보기</strong></p>

<p>어플리케이션 시작 시점에 각 보안 필터 체인(<code class="language-plaintext highlighter-rouge">SecurityFilterChain</code>) 에 어떤 필터들이 등록되어 있는지를 <code class="language-plaintext highlighter-rouge">DEBUG</code> 레벨 로그로 출력하기 때문에 다음과 같이 설정해준다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">logging</span><span class="o">.</span><span class="na">level</span><span class="o">.</span><span class="na">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">security</span><span class="o">=</span><span class="no">DEBUG</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">2023-06-14T08:55:22.321-03:00  DEBUG 76975 --- [main]
o.s.s.web.DefaultSecurityFilterChain : Will secure any request with [
    DisableEncodeUrlFilter,
    WebAsyncManagerIntegrationFilter,
    SecurityContextHolderFilter,
    HeaderWriterFilter,
    CsrfFilter,
    LogoutFilter,
    UsernamePasswordAuthenticationFilter,
    DefaultLoginPageGeneratingFilter,
    DefaultLogoutPageGeneratingFilter,
    BasicAuthenticationFilter,
    RequestCacheAwareFilter,
    SecurityContextHolderAwareRequestFilter,
    AnonymousAuthenticationFilter,
    ExceptionTranslationFilter,
    AuthorizationFilter
]</code></pre></figure>

<p>필터들이 순차적으로 어떻게 실행됐는지 볼 수 있다.</p>

<p><strong>요청마다 필터 호출 과정을 로그로 확인</strong></p>

<p>이게 가장 유용하며, 단순히 필터가 등록되었는가 뿐 아니라 특정 요청에서 실제로 어떤 필터들이 실행되었는지를 알 수 있다. <code class="language-plaintext highlighter-rouge">Security Events</code> 를 켜면 각 필터의 실행 시점, 예외 발생 위치, 인증/인가 처리 흐름이 전부 로그로 찍히게 설정할 수 있다.</p>

<p>이건 나중에 본다.</p>

<h5 id="필터-체인에-필터-추가하기">필터 체인에 필터 추가하기</h5>

<p>보통은 Spring Security 가 기본적으로 제공하는 보안 필터들만으로도 어플리케이션 보안을 충분히 구성할 수 있다.</p>

<p>하지만 때로는 기본 필터 외에 내가 직접 만든 커스텀 필터를 SecurityFilterChain 안에 추가해야 할 때가 있다.</p>

<ul>
  <li>요청 로깅이나 트래킹 하고 싶을 때</li>
  <li>커스텀 JWT 토큰 검증을 하고 싶을 때</li>
  <li>특정 요청 헤더를 가로채서 변환하고 싶을 때</li>
</ul>

<p><strong>addFilterBefore(Filter, Class&lt;?&gt;)</strong></p>

<p>특정 필터 앞(before) 에 새 필터를 추가한다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">http</span><span class="o">.</span><span class="na">addFilterBefore</span><span class="o">(</span><span class="k">new</span> <span class="nc">JwtAuthenticationFilter</span><span class="o">(),</span> <span class="nc">UsernamePasswordAuthenticationFilter</span><span class="o">.</span><span class="na">class</span><span class="o">);</span></code></pre></figure>

<p>즉 이 UsernamePasswordAuthenticationFilter 보다 먼저 실행되게 할 수 있다.</p>

<p><strong>addFilterAfter(Filter, Class&lt;?&gt;)</strong></p>

<p>특정 필터 뒤(after) 에 커스텀 필터를 추가한다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">http</span><span class="o">.</span><span class="na">addFilterAfter</span><span class="o">(</span><span class="k">new</span> <span class="nc">LoggingFilter</span><span class="o">(),</span> <span class="nc">BasicAuthenticationFilter</span><span class="o">.</span><span class="na">class</span><span class="o">);</span></code></pre></figure>

<p>보통 어떤 필터가 끝난 뒤 처리 결과를 가공하거나 후처리, 로깅할 때 쓰인다.</p>

<p><strong>addFilterAt(Filter, Class&lt;?&gt;)</strong></p>

<p>특정 필터를 대체하게 된다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">http</span><span class="o">.</span><span class="na">addFilterAt</span><span class="o">(</span><span class="k">new</span> <span class="nc">CustomLoginFilter</span><span class="o">(),</span> <span class="nc">UsernamePasswordAuthenticationFilter</span><span class="o">.</span><span class="na">class</span><span class="o">);</span></code></pre></figure>

<p>주로 기본 폼 로그인 방식 대신 커스텀 로그인 처리를 하고 싶을 때 사용하며, OAuth2 나 외부 인증 서버와 연동하여 로그인 로직을 직접 구성할 때 사용한다.</p>

<h5 id="adding-custom-filter">Adding Custom Filter</h5>

<p>직접 만든 커스텀 필터를 필터 체인에서 어디에 배치해야 하는지 모를 수 있다.</p>

<p>자신만의 커스텀 필터를 만든다면, 그 필터를 필터 체인 안의 어느 위치에 넣을지 결정해야 한다. 필터의 실행 위치는 보안 이벤트의 순서에 따라 달라진다.</p>

<p>즉, 이 필터가 실행되기 전에 어던 일이 이미 끝나 있어야 하는가? 를 먼저 생각해야 한다.</p>

<p>보통 Spring Security 필터 체인 내의 주요 이벤트 순서는 다음과 같다.</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">SecurityContext</code> 로드
    <ul>
      <li>세션에서 <code class="language-plaintext highlighter-rouge">SecurityContext</code> 를 불러와 인증 정보(Authentication) 를 복원</li>
      <li>이 작업은 <code class="language-plaintext highlighter-rouge">SecurityContextHolderFilter</code> 가 담당</li>
    </ul>
  </li>
  <li>익스플로잇 방어: CSRF, CORS, 보안 헤더(<code class="language-plaintext highlighter-rouge">X-Frame-Options</code>, <code class="language-plaintext highlighter-rouge">X-Content-Type-Options</code> 등) 으로 요청을 보호한다.
    <ul>
      <li>사용자의 신원을 검증하는 단계</li>
      <li>로그인 폼, 토큰(<code class="language-plaintext highlighter-rouge">JWT</code>, <code class="language-plaintext highlighter-rouge">OAuth2</code>), 세션 등 다양한 방식이 여기에 해당한다.</li>
    </ul>
  </li>
  <li>요청 인증(<code class="language-plaintext highlighter-rouge">Authentication</code>)
    <ul>
      <li>사용자 신원을 검증</li>
      <li>로그인 폼, 토큰(JWT, OAuth2), 세션 등 다양한 인증 방식이 사용</li>
    </ul>
  </li>
  <li>요청 인가(<code class="language-plaintext highlighter-rouge">Authorization</code>)
    <ul>
      <li>인증된 사용자가 요청한 리소스에 접근할 권한이 있는지 검사</li>
    </ul>
  </li>
</ol>

<blockquote>
  <p>가장 흔한 커스텀 필터는 커스텀 인증 필터이다, 이는 보통 <code class="language-plaintext highlighter-rouge">LogoutFilter</code> 뒤에 위치시킨다.</p>
</blockquote>

<p>실습으로 테넌트 커스텀 필터를 추가해보자.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TenantFilter</span> <span class="kd">implements</span> <span class="nc">Filter</span> <span class="o">{</span>
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">doFilter</span><span class="o">(</span><span class="nc">ServletRequest</span> <span class="n">request</span><span class="o">,</span>
	                     <span class="nc">ServletResponse</span> <span class="n">response</span><span class="o">,</span>
	                     <span class="nc">FilterChain</span> <span class="n">chain</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span> <span class="nc">ServletException</span> <span class="o">{</span>
		<span class="nc">HttpServletRequest</span> <span class="n">httpRequest</span> <span class="o">=</span> <span class="o">(</span><span class="nc">HttpServletRequest</span><span class="o">)</span> <span class="n">request</span><span class="o">;</span>
		<span class="nc">HttpServletResponse</span> <span class="n">httpResponse</span> <span class="o">=</span> <span class="o">(</span><span class="nc">HttpServletResponse</span><span class="o">)</span> <span class="n">response</span><span class="o">;</span>

		<span class="nc">String</span> <span class="n">tenantId</span> <span class="o">=</span> <span class="n">httpRequest</span><span class="o">.</span><span class="na">getHeader</span><span class="o">(</span><span class="s">"X-Tenant-Id"</span><span class="o">);</span>
		<span class="kt">boolean</span> <span class="n">hasAccess</span> <span class="o">=</span> <span class="n">isUserAllowed</span><span class="o">(</span><span class="n">tenantId</span><span class="o">);</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">hasAccess</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">chain</span><span class="o">.</span><span class="na">doFilter</span><span class="o">(</span><span class="n">httpRequest</span><span class="o">,</span> <span class="n">httpResponse</span><span class="o">);</span>
			<span class="k">return</span><span class="o">;</span>
		<span class="o">}</span>
		<span class="k">throw</span> <span class="k">new</span> <span class="nf">AccessDeniedException</span><span class="o">(</span><span class="s">"Access Denied"</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isUserAllowed</span><span class="o">(</span><span class="nc">String</span> <span class="n">tenantId</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>위와 같이 설정할 수 있다. 이제 이 필터를 적용만 하면 되는데 그 적용하는 것은 <code class="language-plaintext highlighter-rouge">SecurityFilterChain</code> 에 끼워넣어야 하므로 <code class="language-plaintext highlighter-rouge">HttpSecurity</code> 를 토대로 넣어주면 된다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Configuration</span>
<span class="nd">@EnableWebSecurity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SecurityConfig</span> <span class="o">{</span>
	<span class="nd">@Bean</span>
	<span class="kd">public</span> <span class="nc">SecurityFilterChain</span> <span class="nf">securityFilterChain</span><span class="o">(</span><span class="nc">HttpSecurity</span> <span class="n">http</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
		<span class="n">http</span>
				<span class="o">.</span><span class="na">addFilterAfter</span><span class="o">(</span><span class="k">new</span> <span class="nc">TenantFilter</span><span class="o">(),</span> <span class="nc">AnonymousAuthenticationFilter</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
		<span class="k">return</span> <span class="n">http</span><span class="o">.</span><span class="na">build</span><span class="o">();</span>
	<span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<h5 id="declaring-custom-filter-as-bean-with-filterregistrationbean">Declaring Custom Filter as Bean with FilterRegistrationBean</h5>

<p>위에서는 Configuration 으로 등록했다면 이번에는 Bean 을 통해 등록하는 경우를 보자</p>

<p>Filter 는 요청이 Controller 로 가기 전에 또는 응답이 나가기 전에 특정 로직을 수행하는 객체이다. 이때 로그인 정보 확인, 로그 기록, <strong><a href="#tenant">테넌트</a></strong> ID 확인 등을 할 수가 있을 것이다.</p>

<p>이때 필터를 다음과 같이 등록할 수 있다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TenantFilter</span> <span class="kd">implements</span> <span class="nc">Filter</span> <span class="o">{</span>
    <span class="o">...</span>
<span class="o">}</span>

<span class="nd">@Bean</span>
<span class="kd">public</span> <span class="nc">TenantFilter</span> <span class="nf">tenantFilter</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">TenantFilter</span><span class="o">();</span>
<span class="o">}</span></code></pre></figure>

<p>이렇게 하면 Spring Boot가 자동으로 <code class="language-plaintext highlighter-rouge">Filter</code> 를 <strong>서블릿 컨테이너(내장 Tomcat 등)에 등록하</strong>긴 하지만, Spring Security 도 자체적으로 <code class="language-plaintext highlighter-rouge">Filter</code> 체인을 관리하기 때문에 이 <code class="language-plaintext highlighter-rouge">Filter</code> 가 한 번은 Tomcat 쪽에서 실행되고 또 한 번은 Spring Security <code class="language-plaintext highlighter-rouge">FilterChain</code> 에서 실행되게 된다. 즉 두 번 호출되며, 호출 순서도 달라질 수 있어서 의도치 않은 보안 순서 문제가 생기게 된다.</p>

<p>그래서 Bean 은 만들되 자동 등록은 막는 방법으로 다음이 있다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Bean</span>
<span class="kd">public</span> <span class="nc">FilterRegistrationBean</span><span class="o">&lt;</span><span class="nc">TenantFilter</span><span class="o">&gt;</span> <span class="nf">tenantFilterRegistration</span><span class="o">(</span><span class="nc">TenantFilter</span> <span class="n">filter</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">FilterRegistrationBean</span><span class="o">&lt;</span><span class="nc">TenantFilter</span><span class="o">&gt;</span> <span class="n">registration</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FilterRegistrationBean</span><span class="o">&lt;&gt;(</span><span class="n">filter</span><span class="o">);</span>
    <span class="n">registration</span><span class="o">.</span><span class="na">setEnabled</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span> <span class="c1">// 자동 등록 비활성화!</span>
    <span class="k">return</span> <span class="n">registration</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<p>필터 안에서 DI 를 써야 해서 Bean 으로 만들어야 한다면 자동 등록만 위처럼 꺼버리면 된다.</p>

<h5 id="customizing-a-spring-security-filter">Customizing a Spring Security Filter</h5>

<p>보통 Security 는 자동으로 HttpSecurity DSL 로 설정만 해도 필요한 필터들을 추가해준다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">http</span><span class="o">.</span><span class="na">httpBasic</span><span class="o">(</span><span class="nc">Customizer</span><span class="o">.</span><span class="na">withDefaults</span><span class="o">());</span></code></pre></figure>

<p>이 한 줄이면 내부적으로 BasicAuthenticationFilter 가 자동 추가되게 된다. 하지만 여기서 직접 만든 버전의 필터를 쓰고 싶을때 다음을 등록할 수 있다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Bean</span>
<span class="nc">SecurityFilterChain</span> <span class="nf">filterChain</span><span class="o">(</span><span class="nc">HttpSecurity</span> <span class="n">http</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="nc">BasicAuthenticationFilter</span> <span class="n">basic</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BasicAuthenticationFilter</span><span class="o">(...);</span>
    <span class="c1">// 커스텀 설정 추가</span>

    <span class="n">http</span>
        <span class="c1">// ...</span>
        <span class="o">.</span><span class="na">addFilterAt</span><span class="o">(</span><span class="n">basic</span><span class="o">,</span> <span class="nc">BasicAuthenticationFilter</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

    <span class="k">return</span> <span class="n">http</span><span class="o">.</span><span class="na">build</span><span class="o">();</span>
<span class="o">}</span></code></pre></figure>

<blockquote>
  <p>여기서 주의할 점은 같은 필터를 두 번 추가하면 안된다는 것이다.</p>
</blockquote>

<h5 id="exceptiontranslationfilter">ExceptionTranslationFilter</h5>

<p><img src="/seonghun120614/assets/img/exception-translation-filter.png" alt="assets/img/exception-translation-filter.png" /></p>

<p>보안 로직 중에서도 인증/인가에 실패를 하였을 때 HTTP 응답으로 바꿔주는 역할을 하는 필터이다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">AuthenticationException</code> 인증 실패</li>
  <li><code class="language-plaintext highlighter-rouge">AccessDeniedException</code> 인가 실패</li>
</ul>

<p>이 두 가지를 HTTP 응답으로 변환하는 게 주 역할이다. 이 필터의 위치는 다음에 위치된다</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">[인증 관련 필터들]
     ↓
[AuthorizationFilter]
     ↓
[ExceptionTranslationFilter] ← 여기서 예외 처리 담당
     ↓
[나머지 필터 / 애플리케이션 로직]</code></pre></figure>

<p>즉, 아래쪽 필터들이 던진 예외(<code class="language-plaintext highlighter-rouge">AuthenticationException</code>, <code class="language-plaintext highlighter-rouge">AccessDeniedException</code>)를 맨 위에서 받아서 처리하는 “보안 예외의 수문장” 역할을 한다.</p>

<p><strong>실제 동작 순서</strong></p>

<ol>
  <li>요청 실행 시도
    <ul>
      <li>먼저 <code class="language-plaintext highlighter-rouge">ExceptionTranslationFilter</code> 는 단순히 필터 체인만 실행</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">AuthenticationException</code> 발생
    <ul>
      <li>하위 필터에서 위 예외 발생</li>
      <li><code class="language-plaintext highlighter-rouge">SecurityContextHolder</code> 안의 인증 정보(<code class="language-plaintext highlighter-rouge">Authentication</code>) 를 비움</li>
      <li>현재 요청을 저장해둠 (로그인 성공 후 다시 원래 요청을 리플레이 하기 위함)</li>
      <li><code class="language-plaintext highlighter-rouge">AuthenticationEntryPoint</code> 호출
        <ul>
          <li>로그인 페이지로 리다이렉팅</li>
          <li><code class="language-plaintext highlighter-rouge">WWW-Authenticate</code> 헤더를 응답에 추가</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">AccessDeniedException</code> 발생
    <ul>
      <li>하위 필터에서 위 예외 발생 시</li>
      <li>인증은 되었지만 권한이 없는 경우이며,</li>
      <li><code class="language-plaintext highlighter-rouge">AccessDeniedHandler</code> 가 호출되고</li>
      <li>이 핸들러가 <code class="language-plaintext highlighter-rouge">403 Forbidden</code> 응답을 보낸다.</li>
      <li>즉, 로그인을 했음에도 불구하고 이 리소스에 접근할 권한이 없다고 내뱉는 것이다.</li>
    </ul>
  </li>
</ol>

<h5 id="saving-requests-between-authentication">Saving Requests Between Authentication</h5>

<p>Spring Securty 에서 인증 전 요청을 저장하고 복원하는 메커니즘 즉, <code class="language-plaintext highlighter-rouge">RequestCache</code> 에 대해 이제 보자.</p>

<p>실제 로그인 처리에 대해 굉장히 중요한 부분이다.</p>

<p><strong>로그인 전 요청 복원</strong></p>

<p>요청을 저장하는 이유는 사용자가 로그인 하지 않는 상태에서 <code class="language-plaintext highlighter-rouge">/mypage</code> 같은 보호된 리소스를 요청해야 한다고 가정하자. 이때</p>

<ol>
  <li>Spring Security 는 “이 URL 은 인증이 필요함” 을 감지하게 되고</li>
  <li><code class="language-plaintext highlighter-rouge">ExceptionTranslationFilter</code> 가 <code class="language-plaintext highlighter-rouge">AuthenticationException</code> 을 받아, <code class="language-plaintext highlighter-rouge">RequestCache</code> 에 현재 요청을 저장해둔다.</li>
  <li>그리고 로그인 페이지로 리다이렉팅 시키며,</li>
  <li>로그인 성공 시에 원래 가려던 <code class="language-plaintext highlighter-rouge">/mypage</code> 를 <code class="language-plaintext highlighter-rouge">RequestCacheAwareFilter</code> 에서 <code class="language-plaintext highlighter-rouge">RequestCache</code> 의 저장된 요청을 다시 복원시키게 된다. 이로써 <strong>로그인 전 요청 복원</strong> 기능이 완성되게 된다.</li>
</ol>

<p><strong>전체 흐름</strong></p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="o">[</span><span class="nl">사용자:</span> <span class="o">/</span><span class="n">mypage</span> <span class="n">요청</span><span class="o">]</span> <span class="err">→</span> <span class="o">[</span><span class="n">인증</span> <span class="n">안</span> <span class="n">됨</span><span class="o">]</span>
     <span class="err">↓</span>
<span class="o">[</span><span class="nc">ExceptionTranslationFilter</span><span class="o">]</span>
  <span class="err">└─</span><span class="o">&gt;</span> <span class="nc">RequestCache</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">request</span><span class="o">)</span>
  <span class="err">└─</span><span class="o">&gt;</span> <span class="n">로그인</span> <span class="n">페이지로</span> <span class="n">redirect</span>
     <span class="err">↓</span>
<span class="o">[</span><span class="n">사용자</span> <span class="n">로그인</span> <span class="n">성공</span><span class="o">]</span>
     <span class="err">↓</span>
<span class="o">[</span><span class="nc">RequestCacheAwareFilter</span><span class="o">]</span>
  <span class="err">└─</span><span class="o">&gt;</span> <span class="nc">RequestCache</span><span class="o">.</span><span class="na">getSavedRequest</span><span class="o">()</span>
  <span class="err">└─</span><span class="o">&gt;</span> <span class="n">원래</span> <span class="o">/</span><span class="n">mypage로</span> <span class="n">redirect</span></code></pre></figure>

<p><strong>기본 구현체 - HttpSessionRequestCache</strong></p>

<p>기본적으로 Spring Security 는 <code class="language-plaintext highlighter-rouge">HttpSessionRequestCache</code> 를 사용하며 <code class="language-plaintext highlighter-rouge">HttpSession</code> 에 요청 정보를 저장한다.</p>

<ul>
  <li>원래 URL</li>
  <li>HTTP 메서드</li>
  <li>쿼리 파라미터</li>
  <li>헤더 정보</li>
</ul>

<p><strong>커스터마이징 - 저장 조건 변경</strong></p>

<p>예를들어 <code class="language-plaintext highlighter-rouge">continue</code> 라는 파라미터가 있을 때만, 요청을 저장하도록 설정할 수 있다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Bean</span>
<span class="nc">SecurityFilterChain</span> <span class="nf">springSecurity</span><span class="o">(</span><span class="nc">HttpSecurity</span> <span class="n">http</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="nc">HttpSessionRequestCache</span> <span class="n">requestCache</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HttpSessionRequestCache</span><span class="o">();</span>
    <span class="n">requestCache</span><span class="o">.</span><span class="na">setMatchingRequestParameterName</span><span class="o">(</span><span class="s">"continue"</span><span class="o">);</span>

    <span class="n">http</span>
        <span class="o">.</span><span class="na">requestCache</span><span class="o">(</span><span class="n">cache</span> <span class="o">-&gt;</span> <span class="n">cache</span>
            <span class="o">.</span><span class="na">requestCache</span><span class="o">(</span><span class="n">requestCache</span><span class="o">)</span>
        <span class="o">);</span>

    <span class="k">return</span> <span class="n">http</span><span class="o">.</span><span class="na">build</span><span class="o">();</span>
<span class="o">}</span></code></pre></figure>

<p>이렇게 하면 요청 URL 이 <code class="language-plaintext highlighter-rouge">/mypage?continue=true</code> 일때만 요청을 저장하게 된다.</p>

<p><strong>요청 저장 기능 끄기 - NullRequestCache</strong></p>

<p>어떤 앱은 로그인 성공 후 무조건 홈으로 가게 하고 싶을 수 있을 것이다. 이때는 아예 요청을 처리하지 않도록 설정하면 된다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Bean</span>
<span class="nc">SecurityFilterChain</span> <span class="nf">springSecurity</span><span class="o">(</span><span class="nc">HttpSecurity</span> <span class="n">http</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="nc">RequestCache</span> <span class="n">nullRequestCache</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">NullRequestCache</span><span class="o">();</span>
    <span class="n">http</span>
        <span class="o">.</span><span class="na">requestCache</span><span class="o">(</span><span class="n">cache</span> <span class="o">-&gt;</span> <span class="n">cache</span>
            <span class="o">.</span><span class="na">requestCache</span><span class="o">(</span><span class="n">nullRequestCache</span><span class="o">)</span>
        <span class="o">);</span>
    <span class="k">return</span> <span class="n">http</span><span class="o">.</span><span class="na">build</span><span class="o">();</span>
<span class="o">}</span></code></pre></figure>

<blockquote>
  <p>Spring Security 는 이전 요청을 절대 저장하지 않음 =&gt; 로그인 후 항상 <code class="language-plaintext highlighter-rouge">/home</code> 같은 기본 페이지로 이동함</p>
</blockquote>

<p><strong>RequestCacheAwareFilter</strong></p>

<ul>
  <li>로그인 성공 시점에 RequestCache 에서 저장된 요청을 찾아내고</li>
  <li>원래 요청이 있었다면 해당 URL 로 리다이렉트하는 기능을 가진다</li>
  <li>없으면 기본 페이지로 이동한다</li>
</ul>

<blockquote>
  <p>저장된 요청을 복원하는 담당자</p>
</blockquote>

<hr />

<h3 id="용어">용어</h3>

<h6 id="tenant">Tenant</h6>

<p>임차인이라는 의미이며, 소프트웨어에서는 하나의 시스템을 여러 조직이나 사용자가 공유할 때, 각 사용자를 구분하는 단위를 의미한다. 이 개념은 멀티테넌시(Multi-Tenancy) 구조에서 중요하다.</p>

<p>예를 들어 어떤 회사가 exam.com 이라는 SaaS 를 운영하고 있다고 하자. 그러면 이 서비스를 여러 A 회사, B 회사가 함께 사용한다고 친다면, A 회사 직원은 tenantId = A, B 회사의 직원은 tenantId = B 를 가질 수 있다.</p>

<p>이때 A 회사와 B 회사는 같은 어플리케이션 서버와 DB를 사용하지만, 서로의 데이터에는 접근할 수 없어야 한다.</p>

<p>여기서 <code class="language-plaintext highlighter-rouge">Tenant</code> 는 다음 역할을 하게 된다.</p>
<ul>
  <li><strong>데이터 분리</strong>: 각 테넌트마다 별도의 데이터베이스나 스키마를 사용하거나 테이블 내에서 <code class="language-plaintext highlighter-rouge">tenant_id</code> 컬럼으로 데이터 구분</li>
  <li><strong>인증 및 인가 구분</strong>: 로그인 한 사용자가 속한 tenant 에 따라 접근 가능한 리소스 제한</li>
  <li><strong>설정 및 커스터마이징 분리</strong>: 각 테넌트마다 설정, 로고, 테마, 정책 등을 다르게 유지</li>
</ul>

<p><strong>TenanFilter</strong></p>

<p>테넌트 피터는 요청에 포함된 헤더나 토큰에서 <code class="language-plaintext highlighter-rouge">X-Tenant-Id</code> 를 읽어서 현재 요청이 어느 테넌트 소속인지 판별하고, 현재 로그인한 사용자가 그 테넌트에 접근할 권한이 있는지 없는지를 검사하게 된다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="no">GET</span> <span class="o">/</span><span class="n">api</span><span class="o">/</span><span class="n">data</span>
<span class="no">X</span><span class="o">-</span><span class="nc">Tenant</span><span class="o">-</span><span class="nl">Id:</span> <span class="n">companyA</span>
<span class="nl">Authorization:</span> <span class="nc">Bearer</span> <span class="o">&lt;</span><span class="n">token</span><span class="o">&gt;</span></code></pre></figure>

    </div><div id="disqus_thread" style="margin-top:25px"></div>
    <script>
    var disqus_config = function () {
        this.page.url = 'https://seonghun120614.github.io/seonghun120614/%EB%A9%8B%EC%9F%81%EC%9D%B4%EC%82%AC%EC%9E%90%EC%B2%98%EB%9F%BC/%EB%A9%8B%EC%82%AC/%EB%B0%B1%EC%97%94%EB%93%9C/til/java/spring/2025/11/04/%EB%A9%8B%EC%82%AC-%EB%B0%B1%EC%97%94%EB%93%9C-19%EA%B8%B0-til-49%EC%9D%BC%EC%B0%A8-spring-security-servlet.html';
        this.page.identifier = 'https://seonghun120614.github.io/seonghun120614/%EB%A9%8B%EC%9F%81%EC%9D%B4%EC%82%AC%EC%9E%90%EC%B2%98%EB%9F%BC/%EB%A9%8B%EC%82%AC/%EB%B0%B1%EC%97%94%EB%93%9C/til/java/spring/2025/11/04/%EB%A9%8B%EC%82%AC-%EB%B0%B1%EC%97%94%EB%93%9C-19%EA%B8%B0-til-49%EC%9D%BC%EC%B0%A8-spring-security-servlet.html';
    };
    (function () {
        var d = document, s = d.createElement('script');
        s.src = 'https://seonghun.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
  </script>
    <noscript>Please enable JavaScript to view the <a
            href="https://disqus.com/?ref_noscript" rel="nofollow">comments
            powered by Disqus.</a></noscript></div>
<script>
    mermaid.initialize({startOnLoad:true});
    window.mermaid.init(undefined, document.querySelectorAll('.language-mermaid'));
</script>
            </section>
            <footer class="condensed">
                <ul class="social about-footer condensed"><li>
                        <a
                            href="https://github.com/seonghun120614"
                            target="_blank"
                            rel="noopener"
                            aria-label="github">
                            <i class="icon-github-circled"></i>
                        </a>
                    </li><li>
                        <a
                            href="mailto:seonghun120614@gmail.com"
                            target="_blank" rel="noopener" aria-label="email">
                            <i class="icon-mail-alt"></i>
                        </a>
                    </li></ul><nav class="navigation about-footer condensed">
                    <ul>
                        
                        <li>
                            <a href="/seonghun120614/about">About Me</a>
                        </li>
                        
                        <li>
                            <a href="/seonghun120614/categories/computerscience">Computer Science</a>
                        </li>
                        
                        <li>
                            <a href="/seonghun120614/categories/math">Math</a>
                        </li>
                        
                        <li>
                            <a href="/seonghun120614/categories/softwareengineering">Software Engineering</a>
                        </li>
                        
                    </ul>
                </nav><p class="about-footer condensed">&copy;
                    2025</p><div class="about-footer condensed">
                    <p>Dark Mode
                        <i class="icon-moon"></i>
                        <label class="switch" for="dark-toggle">
                            <input id="dark-toggle" type="checkbox"
                                class="dark-mode-toggle"
                                aria-label="Toggle dark mode">
                            <span class="slider round"
                                onclick="toggleDarkMode()"></span>
                        </label>
                    </p>
                </div>
            </footer>
        </main>
        
        <script type="text/javascript" src="/seonghun120614/assets/js/darkmode.js"></script>
        
        <script src="/seonghun120614/assets/js/simple-jekyll-search.min.js"></script>
        <script src="/seonghun120614/assets/js/search.js"></script>
        
        <script>
            window.addEventListener('scroll', () => {
                const scrollTop = window.scrollY;
                const docHeight = document.documentElement.scrollHeight - window.innerHeight;
                const scrollPercent = (scrollTop / docHeight) * 100;
                document.getElementById('scroll-progress').style.width = scrollPercent + '%';
            });
        </script>
    </body>
</html>