<!DOCTYPE html>
<html lang="kor">

    <head><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<link href="https://fonts.googleapis.com/css?family=Merriweather:300|Raleway:400,700" rel="stylesheet">
<link rel="icon" href="/seonghun120614/assets/img/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/seonghun120614/assets/css/style.css">
<title>[멋사 백엔드 19기] TIL 22일차 Hikari Connection Pool</title>
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>[멋사 백엔드 19기] TIL 22일차 Hikari Connection Pool | Seonghun’s Blog</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="[멋사 백엔드 19기] TIL 22일차 Hikari Connection Pool" />
<meta name="author" content="Seonghun Park" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description." />
<meta property="og:description" content="Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description." />
<link rel="canonical" href="https://seonghun120614.github.io/seonghun120614/%EB%A9%8B%EC%9F%81%EC%9D%B4%EC%82%AC%EC%9E%90%EC%B2%98%EB%9F%BC/%EB%A9%8B%EC%82%AC/%EB%B0%B1%EC%97%94%EB%93%9C/til/database/2025/09/16/%EB%A9%8B%EC%82%AC-%EB%B0%B1%EC%97%94%EB%93%9C-19%EA%B8%B0-til-22%EC%9D%BC%EC%B0%A8.html" />
<meta property="og:url" content="https://seonghun120614.github.io/seonghun120614/%EB%A9%8B%EC%9F%81%EC%9D%B4%EC%82%AC%EC%9E%90%EC%B2%98%EB%9F%BC/%EB%A9%8B%EC%82%AC/%EB%B0%B1%EC%97%94%EB%93%9C/til/database/2025/09/16/%EB%A9%8B%EC%82%AC-%EB%B0%B1%EC%97%94%EB%93%9C-19%EA%B8%B0-til-22%EC%9D%BC%EC%B0%A8.html" />
<meta property="og:site_name" content="Seonghun’s Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-09-16T04:42:53+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="[멋사 백엔드 19기] TIL 22일차 Hikari Connection Pool" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Seonghun Park"},"dateModified":"2025-09-16T04:42:53+00:00","datePublished":"2025-09-16T04:42:53+00:00","description":"Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.","headline":"[멋사 백엔드 19기] TIL 22일차 Hikari Connection Pool","mainEntityOfPage":{"@type":"WebPage","@id":"https://seonghun120614.github.io/seonghun120614/%EB%A9%8B%EC%9F%81%EC%9D%B4%EC%82%AC%EC%9E%90%EC%B2%98%EB%9F%BC/%EB%A9%8B%EC%82%AC/%EB%B0%B1%EC%97%94%EB%93%9C/til/database/2025/09/16/%EB%A9%8B%EC%82%AC-%EB%B0%B1%EC%97%94%EB%93%9C-19%EA%B8%B0-til-22%EC%9D%BC%EC%B0%A8.html"},"url":"https://seonghun120614.github.io/seonghun120614/%EB%A9%8B%EC%9F%81%EC%9D%B4%EC%82%AC%EC%9E%90%EC%B2%98%EB%9F%BC/%EB%A9%8B%EC%82%AC/%EB%B0%B1%EC%97%94%EB%93%9C/til/database/2025/09/16/%EB%A9%8B%EC%82%AC-%EB%B0%B1%EC%97%94%EB%93%9C-19%EA%B8%B0-til-22%EC%9D%BC%EC%B0%A8.html"}</script>
<!-- End Jekyll SEO tag -->


<script type="text/javascript" src="/seonghun120614/assets/js/darkmode.js"></script>

<!-- Mermaid -->
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-RQTWJRLWGD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-RQTWJRLWGD');
</script></head><script>
        document.addEventListener("DOMContentLoaded", function () {
            const toggle = document.getElementById("dark-toggle");
        
            // 이미 실행한 적 있는지 확인
            const hasToggled = localStorage.getItem("darkModeInitialized");
        
            if (!hasToggled && toggle && toggle.checked) {
                toggleDarkMode();
                localStorage.setItem("darkModeInitialized", "true"); // 최초 실행 기록
            }
        });
    </script>

    <body>
        <div id="scroll-progress"></div>
        <main class="container">
            <section class="about">
                <div class="about-header condensed">
                    <div class="about-title">
                        <a href="/seonghun120614/">
                            
                            <img class="light"
                                src="/seonghun120614/assets/portfolio.png"
                                alt="Seonghun Park" />
                            <img class="dark"
                                src="/seonghun120614/assets/portfolio.png"
                                alt="Seonghun Park" />
                            
                        </a>
                        <h2 id="title">
                            <a href="/seonghun120614/">Seonghun Park</a>
                        </h2>
                    </div><p class="tagline">Developer.</p></div>
                
                <ul class="social about-footer condensed"><li>
                        <a
                            href="https://github.com/seonghun120614"
                            target="_blank"
                            rel="noopener"
                            aria-label="github">
                            <i class="icon-github-circled"></i>
                        </a>
                    </li><li>
                        <a
                            href="mailto:seonghun120614@gmail.com"
                            target="_blank" rel="noopener" aria-label="email">
                            <i class="icon-mail-alt"></i>
                        </a>
                    </li></ul><nav class="navigation about-footer condensed">
                    <ul>
                        
                        <li>
                            <a href="/seonghun120614/about">About Me</a>
                        </li>
                        
                        <li>
                            <a href="/seonghun120614/categories/computerscience">Computer Science</a>
                        </li>
                        
                        <li>
                            <a href="/seonghun120614/categories/math">Math</a>
                        </li>
                        
                        <li>
                            <a href="/seonghun120614/categories/softwareengineering">Software Engineering</a>
                        </li>
                        
                    </ul>
                </nav><p class="about-footer condensed">&copy;
                    2025</p><div class="about-footer condensed">
                    <p>Dark Mode
                        <i class="icon-moon"></i>
                        <label class="switch" for="dark-toggle">
                            <input id="dark-toggle" type="checkbox"
                                class="dark-mode-toggle"
                                aria-label="Toggle dark mode">
                            <span class="slider round"
                                onclick="toggleDarkMode()"></span>
                        </label>
                    </p>
                </div>
            </section>
            <section class="content">
                <script>
window.MathJax = {
    tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']]
    },
    options: {
    renderActions: {
        addMenu: []
    }
    }
};
</script>

<script type="text/javascript"
    id="MathJax-script"
    async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script><div class="post-container">
    <a class="post-link" href="/seonghun120614/%EB%A9%8B%EC%9F%81%EC%9D%B4%EC%82%AC%EC%9E%90%EC%B2%98%EB%9F%BC/%EB%A9%8B%EC%82%AC/%EB%B0%B1%EC%97%94%EB%93%9C/til/database/2025/09/16/%EB%A9%8B%EC%82%AC-%EB%B0%B1%EC%97%94%EB%93%9C-19%EA%B8%B0-til-22%EC%9D%BC%EC%B0%A8.html">
        <h2 class="post-title">[멋사 백엔드 19기] TIL 22일차 Hikari Connection Pool</h2>
    </a>
    
    <div class="post-meta">
        <div class="post-date"><i class="icon-calendar"></i>Sep 16, 2025</div><ul class="post-categories"><li>멋쟁이사자처럼</li><li>멋사</li><li>백엔드</li><li>TIL</li><li>Database</li></ul></div>

    <div class="post">
        <!--more-->

<h2 id="-목차">📂 목차</h2>
<ul>
  <li><a href="#hikaricp">HikariCP</a>
    <ul>
      <li><a href="#hikaricp-의존성-추가">HikariCP 의존성 추가</a></li>
      <li><a href="#hikari-configuration">Hikari Configuration</a>
        <ul>
          <li><a href="#hikariconfig">HikariConfig</a></li>
          <li><a href="#hikaridatasource">HikariDataSource</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="-본문">📚 본문</h2>

<h3 id="hikaricp">HikariCP</h3>

<p>데이터베이스와 어플리케이션을 통신할 때, Connection 이라는 추상화 된 연결시켜주는 인터페이스를 통해 통신을 할 수 있음을 볼 수 있었다. 내부적인 구현은 DriverManager 을 통해서 외부의 인스턴스를 들고와서 구현하였음을 알 수 있다.</p>

<blockquote>
  <p>외부의 인스턴스를 들고오기 위해 mysql-connector 라는 것을 사용했다.</p>
</blockquote>

<p>여기서 Connection 이라는 하나의 객체를 생성하면 해당 클래스로만 요청을 할 수 있는데, 이는 요청할 수 있는 입구가 하나뿐임을 뜻한다. 그러면 요청이 더 많이 들어올 때마다 Connection 을 생성시켜서 요청을 받을 수 있게 하면 되지만, Connection 을 새로 생성하는 비용이 매우 커서, 이를 서버 실행 이전에 미리 다 만들어두고 사용하는 방식을 채택하게 된다.</p>

<p>이것이 바로 <strong>Connection Pool</strong> 이며, 자바 진영에서는 이 이론을 토대로 가장 빠르고 가벼운 커넥션 풀 구현체 중에 <strong>Hikari Connection Pool</strong> 을 사용하게 된다.</p>

<h4 id="hikaricp-의존성-추가">HikariCP 의존성 추가</h4>

<figure class="highlight"><pre><code class="language-gradle" data-lang="gradle"><span class="c1">// https://mvnrepository.com/artifact/com.zaxxer/HikariCP</span>
<span class="n">implementation</span> <span class="s1">'com.zaxxer:HikariCP:7.0.2'</span></code></pre></figure>

<p>이는 보통 Spring Boot 2.0 이후에 전부 내장되어 있기 때문에 따로 추가해주지 않아도 기본값이 hikari cp 를 사용하도록 되어 있다.</p>

<h4 id="hikari-configuration">Hikari Configuration</h4>

<p>커넥션 풀은 여러 개의 스레드를 통해 커넥션의 수를 정할 수 있다.</p>

<p>이런 커넥션 수는 <code class="language-plaintext highlighter-rouge">properties</code> 파일로 환경 변수처럼 미리 설정하여 <code class="language-plaintext highlighter-rouge">HikariCP</code> 모듈에게 전달할 수 있다.</p>

<figure class="highlight"><pre><code class="language-properties" data-lang="properties"><span class="c"># resources/hikari.properties
</span><span class="py">dataSourceClassName</span><span class="p">=</span><span class="s">com.mysql.cj.jdbc.MysqlDataSource</span>
<span class="py">dataSource.url</span><span class="p">=</span><span class="s">jdbc:mysql://localhost:3306/library?serverTimezone=Asia/Seoul&amp;useSSL=false&amp;allowPublicKeyRetrieval=true</span>
<span class="py">dataSource.user</span><span class="p">=</span><span class="s">lion</span>
<span class="py">dataSource.password</span><span class="p">=</span><span class="s">1234</span>

<span class="c"># Statement 캐시 관련 설정
</span><span class="py">dataSource.cachePrepStmts</span><span class="p">=</span><span class="s">true</span>
<span class="py">dataSource.prepStmtCacheSize</span><span class="p">=</span><span class="s">250</span>
<span class="py">dataSource.prepStmtCacheSqlLimit</span><span class="p">=</span><span class="s">2048</span>

<span class="c"># 풀 사이즈 &amp; 타임아웃
</span><span class="py">maximumPoolSize</span><span class="p">=</span><span class="s">4</span>
<span class="py">minimumIdle</span><span class="p">=</span><span class="s">4</span>
<span class="py">connectionTimeout</span><span class="p">=</span><span class="s">30000</span>
<span class="py">idleTimeout</span><span class="p">=</span><span class="s">600000</span>
<span class="py">maxLifetime</span><span class="p">=</span><span class="s">1800000</span>
<span class="py">poolName</span><span class="p">=</span><span class="s">MyHikariPool</span></code></pre></figure>

<p>이는 HikariCP 만의 독립적인 설정 방식이고, Spring 에서는 위 설정과는 또 다르게 입력해줘야 한다.</p>

<p><strong>Spring 에서의 HikariCP 설정</strong></p>

<figure class="highlight"><pre><code class="language-properties" data-lang="properties"><span class="py">spring.datasource.url</span><span class="p">=</span><span class="s">jdbc:mysql://localhost:3306/testdb</span>
<span class="py">spring.datasource.username</span><span class="p">=</span><span class="s">testuser</span>
<span class="py">spring.datasource.password</span><span class="p">=</span><span class="s">testpass</span>
<span class="py">spring.datasource.driver-class-name</span><span class="p">=</span><span class="s">com.mysql.cj.jdbc.Driver</span>

<span class="py">spring.datasource.hikari.maximum-pool-size</span><span class="p">=</span><span class="s">10</span>
<span class="py">spring.datasource.hikari.minimum-idle</span><span class="p">=</span><span class="s">5</span>
<span class="py">spring.datasource.hikari.idle-timeout</span><span class="p">=</span><span class="s">600000</span>
<span class="py">spring.datasource.hikari.max-lifetime</span><span class="p">=</span><span class="s">1800000</span>
<span class="py">spring.datasource.hikari.connection-timeout</span><span class="p">=</span><span class="s">30000</span></code></pre></figure>

<ul>
  <li>maximum-pool-size:
    <ul>
      <li>DB 서버가 가용하는 코어 수 * 스레드로 경험적으로 정함</li>
      <li>쿼드 코어 &amp; 멀티 스레드 = 4 * 2 = 8</li>
    </ul>
  </li>
  <li>minimum-idle: 최소 유지 커넥션 수(같게 두면 모든 커넥션이 돌아감)</li>
  <li>idle-timeout: 유휴 커넥션 제거 밀리 초
    <ul>
      <li>보통 10분으로 둠(600000 으로 설정 = 10 분)</li>
    </ul>
  </li>
  <li>max-lifetime: 커넥션 최대 생존 밀리 초
    <ul>
      <li>1800000 = 30 분</li>
    </ul>
  </li>
  <li>connection-timeout: 커넥션 최대 대기 밀리초
    <ul>
      <li>30000: 30 초</li>
    </ul>
  </li>
</ul>

<h5 id="hikariconfig">HikariConfig</h5>

<p>HikariConfig class 를 뜯어보자.</p>

<p><strong>HikariConfig Member Var.</strong></p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@SuppressWarnings</span><span class="o">({</span><span class="s">"SameParameterValue"</span><span class="o">,</span> <span class="s">"unused"</span><span class="o">})</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">HikariConfig</span> <span class="kd">implements</span> <span class="nc">HikariConfigMXBean</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span></code></pre></figure>

<p>Hikari 를 뜯어보면 최상위에 <code class="language-plaintext highlighter-rouge">HikariConfig</code> 가 있음을 볼 수 있다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java">   <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">char</span><span class="o">[]</span> <span class="no">ID_CHARACTERS</span> <span class="o">=</span> <span class="s">"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
   <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="no">CONNECTION_TIMEOUT</span> <span class="o">=</span> <span class="no">SECONDS</span><span class="o">.</span><span class="na">toMillis</span><span class="o">(</span><span class="mi">30</span><span class="o">);</span>
   <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="no">VALIDATION_TIMEOUT</span> <span class="o">=</span> <span class="no">SECONDS</span><span class="o">.</span><span class="na">toMillis</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
   <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="no">SOFT_TIMEOUT_FLOOR</span> <span class="o">=</span> <span class="nc">Long</span><span class="o">.</span><span class="na">getLong</span><span class="o">(</span><span class="s">"com.zaxxer.hikari.timeoutMs.floor"</span><span class="o">,</span> <span class="mi">250L</span><span class="o">);</span>
   <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="no">IDLE_TIMEOUT</span> <span class="o">=</span> <span class="no">MINUTES</span><span class="o">.</span><span class="na">toMillis</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
   <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="no">MAX_LIFETIME</span> <span class="o">=</span> <span class="no">MINUTES</span><span class="o">.</span><span class="na">toMillis</span><span class="o">(</span><span class="mi">30</span><span class="o">);</span>
   <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="no">DEFAULT_KEEPALIVE_TIME</span> <span class="o">=</span> <span class="no">MINUTES</span><span class="o">.</span><span class="na">toMillis</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
   <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">DEFAULT_POOL_SIZE</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span></code></pre></figure>

<p>멤버 변수로는 기본값들이 들어 있음을 볼 수 있다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java">   <span class="c1">// Properties changeable at runtime through the HikariConfigMXBean</span>
   <span class="c1">//</span>
   <span class="kd">private</span> <span class="kd">volatile</span> <span class="nc">String</span> <span class="n">catalog</span><span class="o">;</span>
   <span class="kd">private</span> <span class="kd">volatile</span> <span class="kt">long</span> <span class="n">connectionTimeout</span><span class="o">;</span>
   <span class="kd">private</span> <span class="kd">volatile</span> <span class="kt">long</span> <span class="n">validationTimeout</span><span class="o">;</span>
   <span class="kd">private</span> <span class="kd">volatile</span> <span class="kt">long</span> <span class="n">idleTimeout</span><span class="o">;</span>
   <span class="kd">private</span> <span class="kd">volatile</span> <span class="kt">long</span> <span class="n">leakDetectionThreshold</span><span class="o">;</span>
   <span class="kd">private</span> <span class="kd">volatile</span> <span class="kt">long</span> <span class="n">maxLifetime</span><span class="o">;</span>
   <span class="kd">private</span> <span class="kd">volatile</span> <span class="kt">int</span> <span class="n">maxPoolSize</span><span class="o">;</span>
   <span class="kd">private</span> <span class="kd">volatile</span> <span class="kt">int</span> <span class="n">minIdle</span><span class="o">;</span>
   <span class="kd">private</span> <span class="kd">final</span> <span class="nc">AtomicReference</span><span class="o">&lt;</span><span class="nc">Credentials</span><span class="o">&gt;</span> <span class="n">credentials</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AtomicReference</span><span class="o">&lt;&gt;(</span><span class="nc">Credentials</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">));</span></code></pre></figure>

<p>그 밑은 우리가 <code class="language-plaintext highlighter-rouge">properties</code> 에 입력했던 값들이 들어가는 변수들을 선언했다. <code class="language-plaintext highlighter-rouge">volatile</code> 이어서 변수 수준에서 원자적인 연산을 수행함도 알 수 있다(수정과 삭제에 있어 data concurrent 하다).</p>

<p><strong>생성자 부분</strong></p>

<figure class="highlight"><pre><code class="language-java" data-lang="java">      <span class="kt">var</span> <span class="n">systemProp</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="s">"hikaricp.configurationFile"</span><span class="o">);</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">systemProp</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
         <span class="n">loadProperties</span><span class="o">(</span><span class="n">systemProp</span><span class="o">);</span>
      <span class="o">}</span></code></pre></figure>

<p>생성자 에는 기본적으로 <code class="language-plaintext highlighter-rouge">Hikari</code> 에서 제공하는 상수들을 기본 값으로 초기화하는 것을 볼 수 있고, 그 이후에 위의 코드를 볼 수 있다.</p>

<p>해당 부분은 <code class="language-plaintext highlighter-rouge">System.getProperty</code> 라는 것을 통해 <code class="language-plaintext highlighter-rouge">property</code>라는 설정 사항을 추상화 해놓은 <code class="language-plaintext highlighter-rouge">Property</code> 인스턴스를 얻어옴을 볼 수 있다. 만약 null 이라면 그냥 지나치며, 아니라면 <code class="language-plaintext highlighter-rouge">loadProperties</code> 로 넘어가게 된다.</p>

<h5 id="hikaridatasource">HikariDataSource</h5>

<p><code class="language-plaintext highlighter-rouge">HikariDataSource</code> 를 보기 전에 구현하고 있는 인터페이스인 <code class="language-plaintext highlighter-rouge">DataSource</code> 를 보자.</p>

<p>원래 <code class="language-plaintext highlighter-rouge">DataSource</code> 는 DB 를 연결하여 객체를 얻는 방법을 추상화한 인터페이스인데, 자바에서는 <code class="language-plaintext highlighter-rouge">DriverManager.getConnection</code> 으로 매번 직접 커넥션을 작성해야 했다. 하지만 이거는 다음과 같은 단점이 있다:</p>

<ul>
  <li>매번 새로운 커넥션을 만들 때 비용이 큼</li>
  <li>커넥션 풀링(pooling) 이나 트랜잭션 관리 같은 고급 기능을 붙이기 어려움</li>
  <li>설정 정보(URL, 사용자, 비밀번호) 가 코드에 박혀서 재사용성이 떨어지며, 보안적으로도 문제가 있음</li>
</ul>

<p>이런 문제를 해결하기 위해 <code class="language-plaintext highlighter-rouge">JDBC 2.0</code> 에서 <code class="language-plaintext highlighter-rouge">javax.sql.DataSource</code> 가 도입된다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nc">Connection</span> <span class="nf">getConnection</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">SQLException</span></code></pre></figure>

<p>위와 같은 인터페이스가 있으며 우리는 설정 정보만 다른 파일에 입력해주고, <code class="language-plaintext highlighter-rouge">dataSource.getConnection()</code> 만 호출한다면 실제 구현체에 따라 적절한 커넥션을 반환받게 된다.</p>

<p><code class="language-plaintext highlighter-rouge">HikariDataSource</code> 는 <code class="language-plaintext highlighter-rouge">DataSource</code> 를 구현하는 구현체이다. 뜯어보면, <code class="language-plaintext highlighter-rouge">HikariConfig</code> 를 확장하고 있고, 이 말은 <code class="language-plaintext highlighter-rouge">HikariConfig</code> 가 가지고 있는 모든 설정 정보들을 가져올 수 있다는 의미이다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HikariDataSource</span> <span class="kd">extends</span> <span class="nc">HikariConfig</span> <span class="kd">implements</span> <span class="nc">DataSource</span><span class="o">,</span> <span class="nc">Closeable</span>
<span class="o">{</span>
   <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Logger</span> <span class="no">LOGGER</span> <span class="o">=</span> <span class="nc">LoggerFactory</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="nc">HikariDataSource</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

   <span class="kd">private</span> <span class="kd">final</span> <span class="nc">AtomicBoolean</span> <span class="n">isShutdown</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AtomicBoolean</span><span class="o">();</span>

   <span class="kd">private</span> <span class="kd">final</span> <span class="nc">HikariPool</span> <span class="n">fastPathPool</span><span class="o">;</span>
   <span class="kd">private</span> <span class="kd">volatile</span> <span class="nc">HikariPool</span> <span class="n">pool</span><span class="o">;</span></code></pre></figure>

<p>여기서 얻어갈 것들은 자바 프로그래밍에서의 다양한 기법들을 얻을 수 있다. 나머지는 그냥 제공해주는 것을 이용하면 되는 부분이며, 그 안에 코드를 어떻게 짜서 넣었는지를 보자.</p>

<p><strong>Initialization-on-demand Holder Idiom</strong></p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Foo</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Holder</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Foo</span> <span class="no">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Foo</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Foo</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">Holder</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>싱글턴을 가져가는 코드 방식 중 하나이다. 여기서는 <code class="language-plaintext highlighter-rouge">nested class</code> 를 썼는데, 이때 객체가 클래스 로더 단위로 하나만 생성되게 된다.</p>

<p>또한 Holder 내부에서 초기화를 딱 한 번만 하게 되며, <code class="language-plaintext highlighter-rouge">new Foo()</code> 방식으로 초기화하기 때문에 <strong>지연 초기화</strong> 기능도 가져가게 된다. 당연하게도 <code class="language-plaintext highlighter-rouge">static final</code> 하기에 스레드 안전이 자동으로 보장되게 된다.</p>

<ul>
  <li>코드가 깔끔</li>
  <li>스레드 안전 + 지연 초기화 자동 보장</li>
  <li>synchronized 사용이 없어 성능이 최적화 됨</li>
</ul>

<p><strong>Double-Checked Locking</strong>
<img src="/seonghun120614/assets/img/singleton-volatile.png" alt="singleton-volatile.png" /></p>

<p>위 글을 보면 J2SE 5.0 부터 <code class="language-plaintext highlighter-rouge">volatile</code> 키워드는 메모리 배리어(<code class="language-plaintext highlighter-rouge">memory barrier</code>)를 만들도록 정의되었는데, 이를 통해 여러 스레드가 싱글턴 인스턴스를 올바르게 다루도록 보장하는 코딩을 칠 수 있게 되었다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// Works with acquire/release semantics for volatile in Java 1.5 and later</span>
<span class="c1">// Broken under Java 1.4 and earlier semantics for volatile</span>
<span class="kd">class</span> <span class="nc">Foo</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">volatile</span> <span class="nc">Helper</span> <span class="n">helper</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">Helper</span> <span class="nf">getHelper</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Helper</span> <span class="n">localRef</span> <span class="o">=</span> <span class="n">helper</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">localRef</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">localRef</span> <span class="o">=</span> <span class="n">helper</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">localRef</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">helper</span> <span class="o">=</span> <span class="n">localRef</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Helper</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">localRef</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// other functions and members...</span>
<span class="o">}</span></code></pre></figure>

<p>Java 1.5 이상에서의 코드에서 안전하게 동작하는 코드이며, <code class="language-plaintext highlighter-rouge">Helper</code> 라는 <code class="language-plaintext highlighter-rouge">volatile</code>(최신 값을 읽을 수 있는, 가시성을 보장하는) 로 선언되었고, 초기화 과정에서 reordering 을 방지하기 때문에 수정할 때 다른 스레드가 접근하지 못하게 한다.</p>

<p>이때 <code class="language-plaintext highlighter-rouge">Helper</code> 를 반환하고 싶은 메서드가 있을 때(지연 초기화를 하고 싶을때), <code class="language-plaintext highlighter-rouge">localRef</code> 로 <code class="language-plaintext highlighter-rouge">helper</code> 의 주소값을 참조해온다. 이는 멀티 스레드 환경에서 성능을 최적화하기 위해서 임시로 가져오는 것이다(<code class="language-plaintext highlighter-rouge">volatile</code> 필드를 여러 번 읽는 것보다 로컬 변수에 복사 후 사용하는게 효율이 좋음).</p>

<p>그 후 <code class="language-plaintext highlighter-rouge">helper</code> 가 초기화되지 않았다면, 해당 객체를 기준으로 동기화 블록을 시작한다. 즉, 여러 스레드가 동시에 들어왔을 때, 한 번만 객체를 생성하도록 보장한다. 이때 <code class="language-plaintext highlighter-rouge">localRef</code> 를 통해 <code class="language-plaintext highlighter-rouge">helper</code> 값을 다시 한 번 확인하는데, 이유는 <strong>critical criteria</strong> 안에 들어오기 전에 다른 스레드가 이미 helper 를 초기화 했을 수도 있기 때문에 두 번 체크하게 되는 것이다.</p>

<p>따라서 첫 번째는 전역 스레드에서 값을 체크, 두 번째는 동기화 블럭 안에서 오로지 체크가 되게 된다. 이렇게 되면 <code class="language-plaintext highlighter-rouge">synchronized</code> 에 들어오기 전에 첫번째 <code class="language-plaintext highlighter-rouge">localRef == null</code> 검사 때 통과를 하였더라도 <code class="language-plaintext highlighter-rouge">synchronized</code> 에서 두 번째 초기화가 안되게 걸러지게 된다.</p>

<p>그 이후 <code class="language-plaintext highlighter-rouge">helper = localRef = new Helper();</code> 를 통해 값을 동시에 할당시키면 된다.</p>

<blockquote>
  <p>이를 통해 성능이 최대 40% 까지 오른다고 한다.</p>
</blockquote>

<p>위 두가지 방식은 둘 다 괜찮은 방법이지만, 유지보수성이나 코드 가독성 측면에서는 nested class 를 사용하는 <strong>Initialization-on-demand Holder Idiom</strong> 이 훨씬 좋아보인다.</p>

<p><strong>FastList</strong></p>

<p>그 다음으로 모듈 내에서 가져갈 수 있는 최적화 방식은 <code class="language-plaintext highlighter-rouge">FastList</code> 가 있었다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">add</span><span class="o">(</span><span class="no">T</span> <span class="n">element</span><span class="o">)</span>
<span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">elementData</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">elementData</span><span class="o">[</span><span class="n">size</span><span class="o">++]</span> <span class="o">=</span> <span class="n">element</span><span class="o">;</span>   <span class="c1">// 범위 체크 없이 바로 추가</span>
    <span class="o">}</span>
    <span class="k">else</span> <span class="o">{</span>
        <span class="c1">// 배열 크기 확장</span>
        <span class="kd">final</span> <span class="kt">var</span> <span class="n">oldCapacity</span> <span class="o">=</span> <span class="n">elementData</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kd">final</span> <span class="kt">var</span> <span class="n">newCapacity</span> <span class="o">=</span> <span class="n">oldCapacity</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
        <span class="kd">final</span> <span class="kt">var</span> <span class="n">newElementData</span> <span class="o">=</span> <span class="o">(</span><span class="no">T</span><span class="o">[])</span> <span class="nc">Array</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="n">clazz</span><span class="o">,</span> <span class="n">newCapacity</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">elementData</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">newElementData</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">oldCapacity</span><span class="o">);</span>
        <span class="n">newElementData</span><span class="o">[</span><span class="n">size</span><span class="o">++]</span> <span class="o">=</span> <span class="n">element</span><span class="o">;</span>
        <span class="n">elementData</span> <span class="o">=</span> <span class="n">newElementData</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<ul>
  <li>System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length): 복사할 원본 배열 src 에, 원본 배열에서 복사 시작 위치 srcPos 부터 복사할 대상 배열 dest 을 복사해서 넣고, 대상 배열에서 붙여넣기 시작 위치 destPos 에서 부터 복사할 요소 수 length 만큼 복사하게 된다.
    <ul>
      <li>결국엔 둘은 같게 된다. 하지만 dest 가 현재 더 많은 메모리를 할당받을 수 있게 했기 때문에 메모리 용량만 다르다.</li>
    </ul>
  </li>
</ul>

<p>요소를 제거할 때도 해당 리스트는 굉장히 빠른데, 다음과 같다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Override</span>
<span class="kd">public</span> <span class="no">T</span> <span class="nf">remove</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="no">T</span> <span class="n">old</span> <span class="o">=</span> <span class="n">elementData</span><span class="o">[</span><span class="n">index</span><span class="o">];</span>
    <span class="kd">final</span> <span class="kt">var</span> <span class="n">numMoved</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">numMoved</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">elementData</span><span class="o">,</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">elementData</span><span class="o">,</span> <span class="n">index</span><span class="o">,</span> <span class="n">numMoved</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="n">elementData</span><span class="o">[--</span><span class="n">size</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">old</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<p>중간 요소 제거 시에 실제 제거를 하지 않고 <strong>System.arraycopy</strong> 를 통해 덮어쓰는 연산을 수행하고, 해당 함수는 JVM 내부에서 최적화된 네이티브 코드(C/C++) 로 구현되어 있어 빠를 수 있는 것이다.</p>

<p><strong>Effectively Final</strong></p>

<p>자바 8 이후에 도입된 개념으로, 명시적으로 final 을 붙이지 않아도 사실상 final 처럼 동작하는 변수를 <code class="language-plaintext highlighter-rouge">effectively final</code> 이라고 한다.</p>

<p>즉, 한 번 초기화 된 이후 값이 바뀌지 않으면 <code class="language-plaintext highlighter-rouge">effectively final</code> 이며, 이는 람다 또는 익명 클래스에서 사용할 수 있는 값이 되게 된다.</p>

<hr />

<h2 id="️-용어">✒️ 용어</h2>

<h6 id="var">var</h6>

<p>var 예약어는 <strong>Java 10</strong> 에서 처음 도입되었고, 지역 변수를 선언할 때 컴파일러가 타입을 추론하게 해주는 키워드인데, 개발자가 명시적으로 타입을 적지 않아도 컴파일러가 초기값을 보고 타입을 결정하게 된다.</p>

<p><strong>잘못된 예</strong></p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kt">var</span> <span class="n">x</span><span class="o">;</span> <span class="c1">// ❌ 컴파일 에러, 초기값이 필요함</span>
<span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="kt">var</span> <span class="n">field</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span> <span class="c1">// ❌ 컴파일 에러, 지역 변수가 아님</span>
<span class="o">}</span></code></pre></figure>

<p><strong>잘된 예</strong></p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kt">var</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;();</span> 
<span class="c1">// 대신에 HashMap&lt;String, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); 라고 써야 함</span></code></pre></figure>

<ul>
  <li>코드 간결성 증가</li>
  <li>타입 길거나 복잡할 때 코드 가독성 개선</li>
</ul>

<p><strong>주의 사항</strong></p>
<ul>
  <li>타입 추론은 컴파일 타임에 결정되기 때문에 런타임에는 타입이 바뀌지 않음</li>
  <li>null 로 초기화하면 타입을 추론할 수 없어 사용할 수 없음.</li>
</ul>


    </div><div id="disqus_thread" style="margin-top:25px"></div>
    <script>
    var disqus_config = function () {
        this.page.url = 'https://seonghun120614.github.io/seonghun120614/%EB%A9%8B%EC%9F%81%EC%9D%B4%EC%82%AC%EC%9E%90%EC%B2%98%EB%9F%BC/%EB%A9%8B%EC%82%AC/%EB%B0%B1%EC%97%94%EB%93%9C/til/database/2025/09/16/%EB%A9%8B%EC%82%AC-%EB%B0%B1%EC%97%94%EB%93%9C-19%EA%B8%B0-til-22%EC%9D%BC%EC%B0%A8.html';
        this.page.identifier = 'https://seonghun120614.github.io/seonghun120614/%EB%A9%8B%EC%9F%81%EC%9D%B4%EC%82%AC%EC%9E%90%EC%B2%98%EB%9F%BC/%EB%A9%8B%EC%82%AC/%EB%B0%B1%EC%97%94%EB%93%9C/til/database/2025/09/16/%EB%A9%8B%EC%82%AC-%EB%B0%B1%EC%97%94%EB%93%9C-19%EA%B8%B0-til-22%EC%9D%BC%EC%B0%A8.html';
    };
    (function () {
        var d = document, s = d.createElement('script');
        s.src = 'https://seonghun.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
  </script>
    <noscript>Please enable JavaScript to view the <a
            href="https://disqus.com/?ref_noscript" rel="nofollow">comments
            powered by Disqus.</a></noscript></div>
<script>
    mermaid.initialize({startOnLoad:true});
    window.mermaid.init(undefined, document.querySelectorAll('.language-mermaid'));
</script>
            </section>
            <footer class="condensed">
                <ul class="social about-footer condensed"><li>
                        <a
                            href="https://github.com/seonghun120614"
                            target="_blank"
                            rel="noopener"
                            aria-label="github">
                            <i class="icon-github-circled"></i>
                        </a>
                    </li><li>
                        <a
                            href="mailto:seonghun120614@gmail.com"
                            target="_blank" rel="noopener" aria-label="email">
                            <i class="icon-mail-alt"></i>
                        </a>
                    </li></ul><nav class="navigation about-footer condensed">
                    <ul>
                        
                        <li>
                            <a href="/seonghun120614/about">About Me</a>
                        </li>
                        
                        <li>
                            <a href="/seonghun120614/categories/computerscience">Computer Science</a>
                        </li>
                        
                        <li>
                            <a href="/seonghun120614/categories/math">Math</a>
                        </li>
                        
                        <li>
                            <a href="/seonghun120614/categories/softwareengineering">Software Engineering</a>
                        </li>
                        
                    </ul>
                </nav><p class="about-footer condensed">&copy;
                    2025</p><div class="about-footer condensed">
                    <p>Dark Mode
                        <i class="icon-moon"></i>
                        <label class="switch" for="dark-toggle">
                            <input id="dark-toggle" type="checkbox"
                                class="dark-mode-toggle"
                                aria-label="Toggle dark mode">
                            <span class="slider round"
                                onclick="toggleDarkMode()"></span>
                        </label>
                    </p>
                </div>
            </footer>
        </main>
        
        <script type="text/javascript" src="/seonghun120614/assets/js/darkmode.js"></script>
        
        <script src="/seonghun120614/assets/js/simple-jekyll-search.min.js"></script>
        <script src="/seonghun120614/assets/js/search.js"></script>
        
        <script>
            window.addEventListener('scroll', () => {
                const scrollTop = window.scrollY;
                const docHeight = document.documentElement.scrollHeight - window.innerHeight;
                const scrollPercent = (scrollTop / docHeight) * 100;
                document.getElementById('scroll-progress').style.width = scrollPercent + '%';
            });
        </script>
    </body>
</html>