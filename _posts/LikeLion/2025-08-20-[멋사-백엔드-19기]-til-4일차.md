---
layout: post
title:  [멋사 백엔드 19기] TIL 4일차
date:   2025-08-20 10:29:34 +0900
categories: 멋쟁이사자처럼 멋사 백엔드 TIL Java
---

<!--more-->

모든 함수는 IDE 에서 `Ctrl + 클릭` 이나 `CMD + 좌클릭` 으로 소스코드를 직접 볼 수 있기에 모든 함수의 동작 세부 사항은 생략하고 어떨때, 언제, 왜, 어디서 중요하고 쓰이는지를 설명하고 이론적인 내용을 본다.

## 📚 본문

배울 수 있는 내용만 적는 것이 도움이 될거 같아서 얻어갈 수 있는 것들을 요약 정리한다.  
나머지의 내용들은 타 블로그나 타 수강생들이 매우 많이 적기에 굳이 따로 적지 않고  
제공해준 책이나 영상으로도 충분히 독학이 가능하다.

### For 문 label

for 문 안에는 `continue` 예약어를 써넣을 수 있다.  
중첩 for 문에 대해 `continue` 를 하게 되면 해당 scope 내에서만  
그 다음 iteration 으로 진행하게 된다.

하지만 그 밖의 for 문에게로 가고 싶을때 해당 `label` 을 쓰게 된다.

label 은 `break` 나 `continue` 와 함께 쓸 수 있고,  
반복문 바로 위에 label 을 붙여 해당 반복문으로 이동할 것이다 라는  
의미를 가지게 된다.

**continue 예시**
```java
outer:
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        if (j == 1) {
            continue outer; // outer 반복문의 다음 iteration으로 이동
        }
        System.out.println(i + ", " + j);
    }
}
```

**break 예시**
```java
outer: // 라벨 이름
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        if (i + j == 3) {
            break outer; // outer 라벨이 붙은 반복문을 종료
        }
        System.out.println(i + ", " + j);
    }
}
```

### Collection

여러 객체(element)를 그룹화한 인터페이스 형태의 자료구조이다.  
가지는 element 의 규칙에는 두 특징을 가진다:

- 중복 요소를 허용하거나 안허용하거나
- 순서가 정의되거나 안되거나

> 정의된 컬렉션은 `SequencedCollection` 인터페이스의 하위 타입

JDK는 이런 `Collection` 인터페이스를 직접 구현한 객체는 제공하지 않고,  
대신 `Set`, `List` 같은 구체적인 하위 인터페이스를 구현한 클래스를 제공한다.

> Bag 이나 Multiset 은 이 인터페이스를 직접 구현하는 것이 좋다.

#### Collection 구현체 생성자 규칙

우선 표준 생성자 규칙을 먼저 보자.

**표준 생성자 규칙**
1. 인수가 없는 생성자(`void constructor`)
    - 빈 컬렉션을 생성  
    ex) ArrayList<String> list = new ArrayList<>();
2. 단일 컬렉션 인자를 받는 생성자
    - 인자로 전달된 컬렉션과 동일한 요소를 가진 새 컬렉션 생성  
    ex) ArrayList<String> list2 = new ArrayList<>(list1);

어떤 컬렉션이든 복사를 하여 원하는 구현 타입으로 새 컬렉션을 만들 수 있다.

> 인터페이스 자체는 생성자를 가질 수 없기 때문에 이는 구현체에서 해주어야 한다.

**Optional Method**

컬렉션이 반드시 구현해야 하는 메서드는 아니고,  
필요에 따라 구현할 수 있는 메서드의 의미이다.

만약, 특정 method 를 지원하지 않는 경우에는 해당 메서드를  
`UnsupportedOperationException` 가 발생시키도록 정의해야 하며,  
컬렉션 인터페이스의 메서드 명세에서 “optional operation”으로 표시된다.

**Element Constraints**

일부 구현체는 컬렉션에 들어갈 요소를 제한할 수 있다.

- `null` 금지
- 특정 타입만 허용

제약 위반 시에는 `NullPointerException` 혹은 `ClassCastException`  
과 같은 `unchecked` 예외가 발생한다.

또한 제한 위반을 해도 조회 시에 단순히 `false` 를 반환하는 것도 가능하다.

**Synchronization**

컬렉션 자체 동기화 여부는 **구현체가 결정**한다.

멀티 스레드 환경에서 **다른 스레드가 컬렉션을 수정 중**일 때,  
안전하지 않으면 정의되지 않은 동작이라는 예외(`ConcurrentModificationException`)  
발생이 된다.

이런 제약의 적용 범위는 다음과 같다:
- 직접 메서드 호출:  
ex) 한 스레드가 list.add(x) 를 하는 중에 다른 스레드가 동시에 list.get(0) 을 실행
- `Collection`을 다른 메서드에 전달:  
전달받은 메서드 안에서 또 다른 스레드가 수정하면 위험함
- 기존 `Iterator` 로 탐색:  
```java
for (Objevt o : list) { // 탐색
    list.remove(0);    // 탐색 동시에 수정 -> ConcurrentModificationException
}
```

대부분의 컬렉션 반복자(iterator)는 `fail-fast` 특성을 가지고 있어,  
컬렉션이 구조적으로 수정되면 즉시 `ConcurrentModificationException`을 발생시킨다.  
이는 컬렉션이 예상치 못한 상태에서 변경되는 것을 방지하기 위한 메커니즘이다.

> `fail-fast`는 컬렉션을 반복(iterate)하는 도중,  
컬렉션이 구조적으로 수정(add, remove 등 요소 개수가 변하는 변경)되면,  
즉시 예외(**ConcurrentModificationException**)를 던져서  
잘못된 상태에서 계속 실행되는 걸 막는 메커니즘

따라서 이런 `Thread-safety` 가 필요할 때,  
`Collections.synchronizedList()` 등의 명시적 동기화가 필요하다.

**해결 방법**
- **Collections.synchronizedXXXXXX()**:  
`Collections.synchronizedList(new ArrayList<>())` <- 내부적으로 모든 메서드에  
`synchronized` 블록 을 씌움, 단 반복문, 반복자 사용 시 외부에서 `explicitly` 하게 동기화 필요  
```java
List<String> list = Collections.synchronizedList(new ArrayList<>());
synchronized (list) {
    for (String s : list) {
        // Thread-safety
    }
}
```

- `java.util.concurrent` 사용 
    - `ConcurrentHashMap` - 동시 접근 안전
    - `CopyOnWriteArrayList`
    - ...

### Stream API

`Stream`은 데이터 흐름을 다루기 위한 API 이며, `Collection`, `Array`, `I/O 자원` 등 다양한 데이터 소스로부터 시퀀스 데이터를 처리하게된다.

- `SQL` 의 선언형 처리 방식 처럼, 데이터에 무엇을 할지 집중 가능
- 반복문을 직접 돌리는 대신 `filter`, `map`, `reduce` 등을 활용

`파이프-필터 패턴`과 비슷하다고 보면 된다. 다음 특징을 가진다:

- 데이터 불변성: 원본 데이터는 변경 안됨
- 일회성: 한 번 소비하면 재서용이 불가하다 즉, 스트림 재생성 필요
- 내부 반복: 개발자가 아닌 `Stream` 이 내부에서 처리
- `lazy evaluation`: **중간 연산(map, filter 등등)**은 즉시 실행되지 않으며, **최종 연산(sum, collect, 집계 연산)**등이 호출될 때 실행된다.
- 병렬 지원: `.parallelStream()` 으로 멀티코어 활용 가능

#### Intermediate Operation

결과가 또 다른 `Stream` 을 반환하는  
즉, **Chain 형태로** 이어질 수 있는 연산

- `filter()`
- `map()`: 변환
- `sorted()`
- `distinct()`: 중복 제거

#### Terminal Operation

결과를 **값이나 컬렉션으로 반환**하여,  
`Stream` 을 소비해 종료하는 연산

- `forEach()`
- `sum()`, `max()`, `count()`, `min()`, `average()`
- `collect()`: 리스트/맵 등으로 변환
- `reduce()`: 누적 연산

#### Java Stream 종류

1. Object Stream

타입: `Stream<T>`, `Object` 타입을 다룸

예시로 `Stream<String>`, `Stream<Person>` 등이 있음

2. Primitive Stream

기본형에 대한 `Stream` 이다.

- `IntStream`
- `LongStream`
- `DoubleStream`

특히 각 기본형 스트림은 `summaryStatistics()` 를 제공하여  
합계, 평균, 최댓값, 최솟값, 개수를 한 번에 구할 수 있다.

```java
int[] arr = {95, 87, 66, 73, 82};
IntSummaryStatistics stats = Arrays.stream(arr).summaryStatistics();

System.out.println(stats.getSum());   // 합계
System.out.println(stats.getAverage()); // 평균
System.out.println(stats.getMax());   // 최댓값
System.out.println(stats.getMin());   // 최솟값
System.out.println(stats.getCount()); // 개수
```

### 기타 얻어갈 것들

#### Deep Copy & Shallow Copy

얕은 복사는 객체 복사에서 객체 자체를 새로 만들긴 하지만 안의 참조 타입 필드들은 원본 객체와 동일한 참조를 공유하게 된다.

즉, 객체 구조는 새로 만들어내도, 내부의 다른 객체들은 공유가 된다. 완벽하게 copy는 되지 않고 일차원적으로 복사가 된 것이다.

깊은 복사는 객체를 복사할 때 객체 뿐 아니라 객체 내부의 참조 객체들 까지도 전부 새로 생성하여 복사가 된다.

즉, 원본과 복사본이 완전히 독립적이게 된다.

#### 다른 복사 유틸리티 함수

```java
private static void copy_() {
    int[] arr = {1, 2, 3, 4, 5};
    int[] arr1 = new int[10];

    System.arraycopy(arr, 0,arr1, 2, 3);
    System.out.println(Arrays.toString(arr1));

    arr1 = Arrays.copyOf(arr, 3);
    System.out.println(Arrays.toString(arr1));

    // 4 전까지 copy
    arr1 = Arrays.copyOfRange(arr, 2, 4);
    System.out.println(Arrays.toString(arr1));
}
```
