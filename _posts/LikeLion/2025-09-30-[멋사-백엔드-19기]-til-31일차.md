---
layout: post
title:  "[ë©‹ì‚¬ ë°±ì—”ë“œ 19ê¸°] TIL 31ì¼ì°¨"
date:   2025-09-30 09:32:38 +0900
categories: ë©‹ìŸì´ì‚¬ìì²˜ëŸ¼ ë©‹ì‚¬ ë°±ì—”ë“œ TIL Java
---

<!--more-->

## ğŸ“‚ ëª©ì°¨

- [Stream ì‹¬í™”](#stream-ì‹¬í™”)
    - [ì¤‘ê°„ ì—°ì‚°](#ì¤‘ê°„-ì—°ì‚°)
        - [distinct()](#distinct)
        - [flatMap()](#flatmap)
        - [sorted()](#sorted)
        - [peek()](#peek)
        - [reduce()](#reduce)
        - [collect()](#collect)
    - [ìµœì¢… ì—°ì‚°](#ìµœì¢…-ì—°ì‚°)
        - [allMatch, anyMatch, noneMatch](#allmatch-anymatch-nonematch)
        - [findFirst, findAny](#findfirst-findany)
        - [ì§‘ê³„ ì—°ì‚°](#ì§‘ê³„-ì—°ì‚°)
        - [groupingBy](#groupingby)
        - [partitioningBy](#partitioningby)
    - [Parallel Stream](#parallel-stream)
        - [ì–¸ì œ ì‚¬ìš©í•˜ë©´ ì¢‹ì„ê¹Œ?](#ì–¸ì œ-ì‚¬ìš©í•˜ë©´-ì¢‹ì„ê¹Œ)

---

## ğŸ“š ë³¸ë¬¸

### Stream ì‹¬í™”

ë°ì´í„°ë¥¼ ì €ì¥í•˜ì§€ ì•Šê³  íë¥´ë“¯ì´ ì²˜ë¦¬í•˜ëŠ” ë‚´ì¥ API ì´ë‹¤.

- `List`->`Stream`: `stream()` ë©”ì„œë“œë¡œ ìƒì„±ê°€ëŠ¥í•˜ë‹¤.
- `Array`->`Stream`: `Arrays.stream()` ì •ì  ë©”ì„œë“œë¡œ ìƒì„± ê°€ëŠ¥í•˜ë‹¤.
    - `Arrays.stream(, from, to)` ë¶€ë¶„ stream ìƒì„±ë„ ê°€ëŠ¥í•˜ë‹¤.
- `Stream` ì •ì  ë©”ì„œë“œ
    - `<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f)` ë¥¼ í™œìš©í•´ ë¬´í•œ ì§‘í•©ì— ê°€ê¹Œìš´ ì²˜ë¦¬ë„ ê°€ëŠ¥í•˜ë‹¤
    - `<T> Stream<T> generate(Supplier<? extends T> s)` ë™ì¼í•œ ë¬´í•œ ìŠ¤íŠ¸ë¦¼ì„ ìƒì„±í•˜ì§€ë§Œ, ì´ˆê¸° ê°’ì´ ì—†ë‹¤ëŠ” ê²ƒì´ ì°¨ì´ë‹¤.

> ëª¨ë“  ìƒì„±ëœ `Stream` ì€ ë‚´ë¶€ì ìœ¼ë¡œ `Generic` íƒ€ì…ì— ì•Œë§ì€ ì¸ìê°€ ë“¤ì–´ê°€ê²Œ ëœë‹¤.

#### ì¤‘ê°„ ì—°ì‚°

ì¤‘ê°„ ì—°ì‚°ì„ í†µí•´ ì ì ˆí•œ ë°ì´í„°ë¡œ í˜•ë³€í™˜, í•„í„°ë§ ë“±ë“±ì„ ìˆ˜í–‰í•œë‹¤. ì¤‘ê°„ ì—°ì‚°ì€ í˜¸ì¶œí•´ë„ ì¦‰ì‹œ ì‹¤í–‰ë˜ì§€ ì•Šê³ , ìµœì¢… ì—°ì‚°ì´ ìˆ˜í–‰ë  ë•Œ ì ìš©ëœë‹¤.

> Lazy Evaluation ì´ë‹¤

##### distinct()

ì¤‘ë³µê°’ì„ ì œê±°í•œë‹¤.

{% highlight java %}
class Person {
    String name;
    int age;

    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Person)) return false;
        Person p = (Person) o;
        return age == p.age && name.equals(p.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }

    @Override
    public String toString() {
        return name + "-" + age;
    }
}

public class DistinctObjectExample {
    public static void main(String[] args) {
        List<Person> people = Arrays.asList(
            new Person("Alice", 20),
            new Person("Bob", 25),
            new Person("Alice", 20)
        );

        List<Person> distinctPeople = people.stream()
                                            .distinct()
                                            .collect(Collectors.toList());

        System.out.println(distinctPeople); // [Alice-20, Bob-25]
    }
}
{% endhighlight %}

ì—¬ê¸°ì„œ ì£¼ì˜í•  ì ì€ ë‚´ë¶€ ë¹„êµëŠ” `equals()` + `hashCode()` ë¥¼ êµ¬í˜„í•œ í´ë˜ìŠ¤ì— ëŒ€í•´ì„œ ì¤‘ë³µ ì œê±°ë¥¼ í•˜ê²Œ ëœë‹¤.

> java 16 ë¶€í„°ëŠ” `collect(Collectors.toList())` ë³´ë‹¤ëŠ” `toList()` ë¥¼ í†µí•´ ë” ê°„í¸í•˜ê²Œ ë°”ê¿€ ìˆ˜ ìˆë‹¤.

##### flatMap()

stream ë‚´ë¶€ì—ì„œ collection ì´ ë‚˜ì˜¬ ë•Œ ì´ë¥¼ êµ¬ì¡° ë¶„í•´í•˜ê³  ì‹¶ì„ ìˆ˜ë„ ìˆë‹¤. `Collection` ì—ì„œëŠ” `stream()` ë©”ì„œë“œë¥¼ í™œìš©í•˜ì—¬ ì´ë¥¼ í‰íƒ„í™” ê°€ëŠ¥í•˜ë‹¤.

{% highlight java %}
import java.util.*;
import java.util.stream.*;

public class FlatMapExample {
    public static void main(String[] args) {
        List<List<String>> listOfLists = Arrays.asList(
            Arrays.asList("A", "B"),
            Arrays.asList("C", "D", "E"),
            Arrays.asList("F")
        );

        // flatMap ì‚¬ìš©
        List<String> flatList = listOfLists.stream()
            .flatMap(List::stream)  // ê° ë¦¬ìŠ¤íŠ¸ë¥¼ ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ë³€í™˜í•˜ê³  í‰íƒ„í™”
            .collect(Collectors.toList());

        System.out.println(flatList); // [A, B, C, D, E, F]
    }
}
{% endhighlight %}

ë˜í•œ ë‚´ë¶€ì ìœ¼ë¡œ `Collection` ì´ ì•„ë‹ˆë”ë¼ë„ í•´ë‹¹ í´ë˜ìŠ¤ì— ëŒ€í•œ stream ìœ¼ë¡œ ë³€í™˜í•´ì£¼ëŠ” API ê°€ ìˆë‹¤ë©´ stream ë‚´ì—ì„œ êµ¬ì¡° ë¶„í•´ê°€ ê°€ëŠ¥í•˜ë‹¤.

{% highlight java %}
class Student {
    String name;
    List<String> courses;

    Student(String name, List<String> courses) {
        this.name = name;
        this.courses = courses;
    }
}

public class FlatMapStudentExample {
    public static void main(String[] args) {
        List<Student> students = Arrays.asList(
            new Student("Alice", Arrays.asList("Math", "Physics")),
            new Student("Bob", Arrays.asList("English", "History")),
            new Student("Charlie", Arrays.asList("Math", "History"))
        );

        // ëª¨ë“  í•™ìƒì´ ìˆ˜ê°•í•˜ëŠ” ê³¼ëª©ì„ í•˜ë‚˜ì˜ ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ
        List<String> allCourses = students.stream()
            .flatMap(student -> student.courses.stream())
            .distinct()  // ì¤‘ë³µ ì œê±°
            .collect(Collectors.toList());

        System.out.println(allCourses); // [Math, Physics, English, History]
    }
}
{% endhighlight %}

##### sorted()

ì¤‘ê°„ ì—°ì‚°ìì¸ ì •ë ¬ì€ ì¸ìê°€ ì—†ëŠ” ê²ƒì„ ì“°ë ¤ë©´ í•´ë‹¹ stream ë‚´ë¶€ì˜ ë°ì´í„°ì— ëŒ€í•œ `Comparable` ì´ ì •ì˜ë˜ì–´ ìˆì–´ì•¼ í•˜ë©°, ì¸ìê°€ ìˆì„ ë•ŒëŠ” `sorted(Comparator c)` ì˜ Comparator ê°€ ë“¤ì–´ê°„ë‹¤. ìµëª… ê°ì²´ë¥¼ í†µí•´ Comparator ë¥¼ ìƒì„±í•´ì„œ ë„£ì„ ìˆ˜ë„ ìˆì§€ë§Œ, `Comparators.comparing()` ì„ í†µí•´ primitive í˜¹ì€ ì–´ë–¤ íŠ¹ì •í•œ í´ë˜ìŠ¤ì˜ ì •ë ¬ ì¡°ê±´ì„ ë”°ë¥´ê²Œ ê°„ë‹¨íˆë„ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤.

{% highlight java %}
List<Integer> numbers = Arrays.asList(5, 2, 8, 1);
List<Integer> sortedDesc = numbers.stream()
                                  .sorted((a, b) -> b - a)
                                  .toList();
System.out.println(sortedDesc); // [8, 5, 2, 1]

class Person {
    String name;
    int age;
    Person(String name, int age) { this.name = name; this.age = age; }
    @Override public String toString() { return name + "-" + age; }
}

List<Person> people = Arrays.asList(
    new Person("Alice", 25),
    new Person("Bob", 20),
    new Person("Charlie", 30)
);

// ë‚˜ì´ ìˆœìœ¼ë¡œ ì •ë ¬
List<Person> sortedByAge = people.stream()
                                 .sorted(Comparator.comparingInt(p -> p.age))
                                 .toList();

System.out.println(sortedByAge); 
// [Bob-20, Alice-25, Charlie-30]

// comparing ë©”ì„œë“œ
List<Person> sortedByNameThenAge = people.stream()
    .sorted(Comparator.comparing((Person p) -> p.name)
                      .thenComparingInt(p -> p.age))
    .toList();
{% endhighlight %}

##### peek()

`peek` ëŠ” `forEach` ì™€ ë¹„ìŠ·í•˜ì§€ë§Œ `forEach` ëŠ” ìµœì¢… ì—°ì‚°ìë¡œì„œ ì‘ìš©ë˜ê³ , `peek` ëŠ” ì¤‘ê°„ì—°ì‚°ìë¡œ ì‘ë™í•œë‹¤. ì¤‘ê°„ì— ë°ì´í„°ê°€ ì–´ë–»ê²Œ ì²˜ë¦¬ë˜ëŠ”ì§€ ë³´ê³  ì‹¶ê±°ë‚˜ ì¤‘ê°„ë°ì´í„°ë¥¼ ì¨ì•¼ í•  ê²½ìš°ì— ì‚¬ìš©í•œë‹¤.

{% highlight java %}
stream.peek(Consumer<? super T> action)
{% endhighlight %}

ë‚´ë¶€ì ìœ¼ë¡œ `Consumer` ë¥¼ ë„£ì–´ì•¼ í•˜ë©°, stream ë‚´ì˜ ë°ì´í„°ì— ëŒ€í•´ ì†Œë¹„ë¥¼ í•˜ëŠ” functional interface ê°€ ë“¤ì–´ê°€ë©´ ëœë‹¤.

##### reduce()

`reduce` ëŠ” `stream` ì˜ ë°ì´í„°ë¥¼ ì¶•ì†Œ, í•©ì¹˜ëŠ” ì—°ì‚°ì„ ìˆ˜í–‰í•œë‹¤. ì²« ë²ˆì§¸ ì¸ìëŠ” ì´ˆê¸°ê°’ì¸ë° ì„ íƒì´ë‹¤. ë‘ ë²ˆì§¸ ì¸ìëŠ” `BinaryOperator` í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ë¥¼ ë„£ì–´ì£¼ë©´ ëœë‹¤.

{% highlight java %}
public class ReduceExample {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

        // í•©ê³„ êµ¬í•˜ê¸° (ì´ˆê¸°ê°’ ìˆìŒ)
        int sum = numbers.stream()
            .reduce(0, (a, b) -> a + b);
        System.out.println("í•©ê³„: " + sum); // 15

        // í•©ê³„ êµ¬í•˜ê¸° (ë©”ì„œë“œ ì°¸ì¡°)
        int sum2 = numbers.stream()
            .reduce(0, Integer::sum);
        System.out.println("í•©ê³„2: " + sum2); // 15

        // ìµœëŒ“ê°’ êµ¬í•˜ê¸° (ì´ˆê¸°ê°’ ì—†ìŒ)
        Optional<Integer> max = numbers.stream()
            .reduce(Integer::max);
        max.ifPresent(n -> System.out.println("ìµœëŒ“ê°’: " + n)); // 5

        // ë¬¸ìì—´ ì—°ê²°
        List<String> words = Arrays.asList("Hello", " ", "World", "!");
        String sentence = words.stream()
            .reduce("", String::concat);
        System.out.println(sentence); // Hello World!
    }
}
{% endhighlight %}

##### collect()

{% highlight java %}
<R, A> R collect(Collector<? super T, A, R> collector)
{% endhighlight %}

ìœ„ API ë¥¼ ë³´ê¸° ì „ì— `Collector` ë¥¼ ë¨¼ì € ë³´ì.

{% highlight java %}
public interface Collector<T, A, R> {
    // ...
}
{% endhighlight %}

Collector ëŠ” ì¸í„°í˜ì´ìŠ¤ë¡œ ì„ ì–¸ë˜ì–´ ìˆë‹¤.

- T: ìŠ¤íŠ¸ë¦¼ ìš”ì†Œ íƒ€ì…
- A: ëˆ„ì ê¸°, ìŠ¤íŠ¸ë¦¼ ìš”ì†Œë¥¼ ì„ì‹œë¡œ ëª¨ì•„ë‘ëŠ” ê°ì²´
- R: ìµœì¢… ë°˜í™˜ íƒ€ì…(collect í›„ ì–»ëŠ” ê²°ê³¼)

{% highlight java %}
Collector<Employee, ?, Integer> summingSalaries
         = Collectors.summingInt(Employee::getSalary))
{% endhighlight %}

ì»¬ë ‰í„° ëŠ” 3ê°œì˜ parametric type ì´ ë“¤ì–´ê°€ê¸´ í•˜ì§€ë§Œ ìƒëµë„ ê°€ëŠ¥í•˜ë‹¤. ì´ë ‡ê²Œ `?` ë¡œ ìƒëµí•  ìˆ˜ ìˆëŠ” ì´ìœ ëŠ” ë‚´ë¶€ì ìœ¼ë¡œ `Integer` ë¥¼ ëˆ„ì í•˜ê¸° ìœ„í•´ ì–´ë–¤ ê°ì²´ `A` ë¥¼ ì‚¬ìš©í•˜ê² ì§€ë§Œ, ì™¸ë¶€ì—ì„œëŠ” `R` ë§Œ ì•Œë©´ ì¶©ë¶„í•˜ê¸° ë•Œë¬¸ì´ë‹¤. ì´ëŠ” ì»´íŒŒì¼ëŸ¬ê°€ ìë™ìœ¼ë¡œ íƒ€ì… ìœ ì¶”ë¥¼ í•˜ì—¬ ëˆ„ì ê¸° `A` ì˜ íƒ€ì…ì„ ìë™ìœ¼ë¡œ ê²°ì •í•˜ê¸° ë•Œë¬¸ì´ë‹¤.

ìœ„ ë‚´ìš©ì„ ëª°ë¼ë„ `Collector` ë¥¼ ìƒì„±í•  ë•ŒëŠ” `Collectors` ë¥¼ í†µí•´ ë” ì‰½ê²Œì‰½ê²Œ ìƒì„±í•  ìˆ˜ ìˆë‹¤.

{% highlight java %}
public class CollectorsExample {
    public static void main(String[] args) {
        List<Student> students = Arrays.asList(
            new Student("Alice", 85, "CS"),
            new Student("Bob", 92, "Math"),
            new Student("Charlie", 78, "CS"),
            new Student("David", 88, "Physics"),
            new Student("Eve", 95, "Math")
        );

        // toListë¡œ ìˆ˜ì§‘
        List<String> names = students.stream()
            .map(Student::getName)
            .collect(Collectors.toList());

        // toSetìœ¼ë¡œ ìˆ˜ì§‘
        Set<String> departments = students.stream()
            .map(Student::getDepartment)
            .collect(Collectors.toSet());

        // toMapìœ¼ë¡œ ìˆ˜ì§‘
        Map<String, Integer> nameToScore = students.stream()
            .collect(Collectors.toMap(
                Student::getName,
                Student::getScore
            ));

        // joiningìœ¼ë¡œ ë¬¸ìì—´ ê²°í•©
        String allNames = students.stream()
            .map(Student::getName)
            .collect(Collectors.joining(", "));
        System.out.println("ëª¨ë“  í•™ìƒ: " + allNames);
        // ëª¨ë“  í•™ìƒ: Alice, Bob, Charlie, David, Eve
    }

    static class Student {
        private String name;
        private int score;
        private String department;

        public Student(String name, int score, String department) {
            this.name = name;
            this.score = score;
            this.department = department;
        }

        // getter ë©”ì„œë“œë“¤
        public String getName() { return name; }
        public int getScore() { return score; }
        public String getDepartment() { return department; }
    }
}
{% endhighlight %}

#### ìµœì¢… ì—°ì‚°

##### allMatch, anyMatch, noneMatch

{% highlight java %}
boolean allMatch(Predicate<? super T> predicate)
boolean anyMatch(Predicate<? super T> predicate)
boolean noneMatch(Predicate<? super T> predicate)
{% endhighlight %}

`Predicate` ë¥¼ ë„£ì–´ true/false ë¥¼ ë°˜í™˜í•˜ë„ë¡ í•˜ë©°, all ì€ ëª¨ë“ , any ëŠ” ì–´ë–¤, none ì€ ëª¨ë“ ì˜ ë¶€ì •ìœ¼ë¡œì„œ ì‘ìš©í•œë‹¤. stream ì„ ë°˜í™˜í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì— ìµœì¢…ì—°ì‚°ì´ë‹¤.

{% highlight java %}
import java.util.*;
import java.util.stream.*;

public class MatchExample {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(2, 4, 6, 8, 10);

        boolean allEven = numbers.stream()
                                 .allMatch(n -> n % 2 == 0);  // ëª¨ë“  ìˆ˜ê°€ ì§ìˆ˜ì¸ê°€?
        System.out.println("allEven: " + allEven);  // true

        boolean anyGreaterThan5 = numbers.stream()
                                        .anyMatch(n -> n > 5);  // 5ë³´ë‹¤ í° ìˆ˜ê°€ ìˆëŠ”ê°€?
        System.out.println("anyGreaterThan5: " + anyGreaterThan5); // true

        boolean noneNegative = numbers.stream()
                                     .noneMatch(n -> n < 0); // ìŒìˆ˜ê°€ ì—†ëŠ”ê°€?
        System.out.println("noneNegative: " + noneNegative); // true
    }
}
{% endhighlight %}

##### findFirst, findAny

ìµœì¢… ì—°ì‚°ìì´ë©°, ë©”ì„œë“œ ëª…ëŒ€ë¡œ ì²«ë²ˆì§¸ë¥¼ ì°¾ê±°ë‚˜ 
- `findFirst()`: ìŠ¤íŠ¸ë¦¼ì— ë°ì´í„°ê°€ ì—†ìœ¼ë©´ `Optional.<T>empty()` ê°€ ë°˜í™˜ëœë‹¤
- `findAny()`: ì–´ë–¤ ìš”ì†Œë“  í•˜ë‚˜ë¥¼ ë°˜í™˜í•œë‹¤(ë³‘ë ¬ ìŠ¤íŠ¸ë¦¼ì—ì„œ ì£¼ë¡œ ì‚¬ìš©í•˜ë©°, ì„±ëŠ¥ ìµœì í™”ê°€ ê°€ëŠ¥í•˜ë‹¤)

> ì¦‰, ìˆœì°¨ ìŠ¤íŠ¸ë¦¼ì—ì„œëŠ” `findFirst` = `findAny` ì´ê³ , ë³‘ë ¬ ìŠ¤íŠ¸ë¦¼ì—ì„œëŠ” `findAny` ê°€ ìˆœì„œë¥¼ ë³´ì¥í•˜ì§€ ì•Šê³  ê·¸ëƒ¥ ë¹ ë¥´ê²Œ ì˜¨ ìš”ì†Œë¥¼ ë°”ë¡œ ë°˜í™˜í•˜ê¸° ë•Œë¬¸ì— `findFirst` ë³´ë‹¤ ë” ì„±ëŠ¥ì´ ì¢‹ë‹¤.

##### ì§‘ê³„ ì—°ì‚°

ì§‘ê³„ ì—°ì‚°ë„ ìµœì¢… ì—°ì‚°ì— í¬í•¨ëœë‹¤. í•˜ì§€ë§Œ ì§‘ê³„ë¥¼ í•œ í›„ì—ë„ ë‹¤ë¥¸ ì²˜ë¦¬ê°€ í•„ìš”í•  ìˆ˜ë„ ìˆëŠ”ë° ê·¸ë•ŒëŠ” stream ìœ¼ë¡œ ë‹¤ì‹œ ìƒì„±ì‹œì¼œì¤˜ì•¼ í•œë‹¤.

**count**
{% highlight java %}
import java.util.*;
import java.util.stream.*;

public class CountExample {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(2, 4, 6, 8, 10);

        long count = numbers.stream()
                            .filter(n -> n > 5)  // 5ë³´ë‹¤ í° ìˆ˜ë§Œ
                            .count();

        System.out.println("5ë³´ë‹¤ í° ìˆ˜ ê°œìˆ˜: " + count); // 3
    }
}
{% endhighlight %}

**max**
{% highlight java %}
Optional<Integer> maxValue = numbers.stream()
                                    .max(Integer::compareTo);

maxValue.ifPresent(v -> System.out.println("ìµœëŒ“ê°’: " + v)); // 10
{% endhighlight %}

**min**
{% highlight java %}
class Person {
    String name;
    int age;
    Person(String name, int age) { this.name = name; this.age = age; }
}

List<Person> people = Arrays.asList(
    new Person("Alice", 25),
    new Person("Bob", 20),
    new Person("Charlie", 30)
);

Optional<Person> youngest = people.stream()
                                  .min(Comparator.comparingInt(p -> p.age));

youngest.ifPresent(p -> System.out.println("ê°€ì¥ ì–´ë¦° ì‚¬ëŒ: " + p.name)); // Bob
{% endhighlight %}

##### groupingBy

`collect` ì™€ í•¨ê»˜ ì‚¬ìš©ë˜ëŠ” ìµœì¢… ì—°ì‚°ìš© `Collector` ì˜ ê¸°ëŠ¥ì´ë‹¤.

{% highlight java %}
Map<K, List<T>> grouped = stream.collect(
    Collectors.groupingBy(classifier)
);
{% endhighlight %}

ê¸°ë³¸ì ìœ¼ë¡œ `Collectors.groupingBy` ë¥¼ ì‚¬ìš©í•˜ì—¬ K ì— ëŒ€í•œ ê¸°ì¤€ì ì„ `classfier` ë¡œ ì¡ê³  ë¬¶ê³ , K ì— í•´ë‹¹í•˜ëŠ” ìš”ì†Œë“¤ì„ `List<T>` ë¡œ ë¬¶ì–´ `Map` ì„ ë°˜í™˜í•˜ê²Œ ëœë‹¤.

{% highlight java %}
import java.util.*;
import java.util.stream.*;

public class GroupingByExample {
    static class Student {
        String name;
        int score;
        String department;

        Student(String name, int score, String department) {
            this.name = name;
            this.score = score;
            this.department = department;
        }

        @Override
        public String toString() {
            return name + "-" + score;
        }
    }

    public static void main(String[] args) {
        List<Student> students = Arrays.asList(
            new Student("Alice", 85, "CS"),
            new Student("Bob", 92, "Math"),
            new Student("Charlie", 78, "CS"),
            new Student("David", 88, "Physics"),
            new Student("Eve", 95, "Math")
        );

        // í•™ê³¼ë³„ë¡œ ê·¸ë£¹í™”
        Map<String, List<Student>> grouped = students.stream()
            .collect(Collectors.groupingBy(s -> s.department));

        System.out.println(grouped);
    }
}
{% endhighlight %}

ë˜í•œ ë‹¨ìˆœíˆ `Map` ìœ¼ë¡œ `grouping` ì„ í•˜ëŠ” ê²ƒ ì™¸ì— ë‘ ë²ˆì§¸ ì¸ì downstream ìœ¼ë¡œ `Collector` ë¥¼ ë˜ ë„£ì–´ì„œ ì§‘ê³„ í•¨ìˆ˜ì²˜ëŸ¼ ì‚¬ìš©ì´ ê°€ëŠ¥í•˜ë‹¤.

> n ê·¸ë£¹ìœ¼ë¡œ ë‚˜ë‰¨

{% highlight java %}
// í•™ê³¼ë³„ í‰ê·  ì ìˆ˜ ê³„ì‚°
Map<String, Double> avgScore = students.stream()
    .collect(Collectors.groupingBy(
        s -> s.department,
        Collectors.averagingInt(s -> s.score)
    ));

System.out.println(avgScore);
{% endhighlight %}

##### partitioningBy

íŠ¹ì • parameter ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë¶„í•  í•  ìˆ˜ ìˆëŠ” ê¸°ëŠ¥ ë˜í•œ ìˆë‹¤.

{% highlight java %}
import java.util.*;
import java.util.stream.*;

public class PartitioningExample1 {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1,2,3,4,5,6,7,8,9,10);

        Map<Boolean, List<Integer>> evenOdd = numbers.stream()
            .collect(Collectors.partitioningBy(n -> n % 2 == 0));

        System.out.println("ì§ìˆ˜: " + evenOdd.get(true));  // [2, 4, 6, 8, 10]
        System.out.println("í™€ìˆ˜: " + evenOdd.get(false)); // [1, 3, 5, 7, 9]
    }
}
{% endhighlight %}

ì—¬ê¸°ì„œ `partitioningBy` ëŠ” ë¬´ì¡°ê±´ Key ê°€ `Boolean` í˜•íƒœë¡œ ë‚˜ì˜¤ê²Œ ë˜ê³ , ì´ëŠ” 2ê°œì˜ ê·¸ë£¹ìœ¼ë¡œë§Œ ë‚˜ë‰˜ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆë‹¤.

> 2ê°œ ê·¸ë£¹ìœ¼ë¡œ ë‚˜ë‰¨

#### Parallel Stream

ì´ëŸ° stream ì€ ë³‘ë ¬ ì²˜ë¦¬ê°€ ê°€ëŠ¥í•œë°, ì»¬ë ‰ì…˜ ì¸í„°í˜ì´ìŠ¤ì—ì„œëŠ” ë””í´íŠ¸ ë©”ì„œë“œë¡œ `parallelStream()` ì´ë¼ëŠ” ë©”ì„œë“œë¥¼ ì§€ì›í•œë‹¤. ë˜í•œ `stream()` í›„ì— `parallel()` ì„ í˜¸ì¶œí•˜ì—¬ë„ ëœë‹¤.

**ìƒì„± ë°©ë²•**
- `parallelStream()`
- `stream().parallel()`

ì´ë ‡ê²Œ ìƒì„±ëœ ìŠ¤íŠ¸ë¦¼ë“¤ì€ ì—°ì‚°ë“¤ì´ ë³‘ë ¬ì ìœ¼ë¡œ ì‹¤í–‰ë˜ê²Œ ë˜ë©° ë‹¤ìŒ ì£¼ì˜ì‚¬í•­ì„ í¬í•¨í•œë‹¤:
1. ì‘ì—… ë‹¨ìœ„ê°€ ì¶©ë¶„íˆ í¬ì§€ ì•Šìœ¼ë©´ ì„±ëŠ¥ ì €í•˜ê°€ ë¨
    - ë‚´ë¶€ì ìœ¼ë¡œ `ForkJoinPool` ì´ë¼ëŠ” ìŠ¤ë ˆë“œ í’€ì„ ì‚¬ìš©í•˜ëŠ”ë°,  
    ìŠ¤ë ˆë“œë¥¼ ìª¼ê°œê³  í•©ì¹˜ëŠ” ì˜¤ë²„í—¤ë“œê°€ ìˆê¸°ì—, ìš”ì†Œ ìˆ˜ê°€ ì ì–´ ì—°ì‚°ì´ ê°€ë²¼ìš¸ ì‹œ ì§ë ¬ ìŠ¤íŠ¸ë¦¼ë³´ë‹¤ ë” ëŠë¦¬ë‹¤.

2. ê³µìœ  ìƒíƒœ(Shared State) ì ‘ê·¼ ì‹œ ì£¼ì˜
    - ë³‘ë ¬ ìŠ¤íŠ¸ë¦¼ì€ ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— ì‘ì—…í•˜ê¸° ë•Œë¬¸ì—, **ì™¸ë¶€ì—ì„œ ê³µìœ ë˜ëŠ” ê°€ë³€ ìƒíƒœ(mutable state)**(ìë°”ëŠ” PF ê°€ ì•„ë‹ˆê¸° ë•Œë¬¸)ë¥¼ ê±´ë“œë¦¬ë©´ ë™ê¸°í™” ë¬¸ì œê°€ ë°œìƒí•œë‹¤.
    - **Race Condition** ì„ ë§‰ê¸° ìœ„í•´ ë™ê¸°í™” ë©”ì»¤ë‹ˆì¦˜ì´ ë°˜ë“œì‹œ í•„ìš”í•˜ë‹¤.

3. ìˆœì„œê°€ ì¤‘ìš”í•œ ì—°ì‚°ì—ì„œ ì£¼ì˜
    - ë³‘ë ¬ ì²˜ë¦¬ëŠ” ìˆœì„œë¥¼ ë³´ì¥í•˜ì§€ ì•Šê¸°ì— ê²°ê³¼ ì²˜ë¦¬ë¥¼ ì£¼ì˜í•˜ì.

4. ìŠ¤ë ˆë“œ í’€ ì œì•½
    - `parallelStream` ì€ ê¸°ë³¸ì ìœ¼ë¡œ `ForkJoinPool` ì„ ì‚¬ìš©í•œë‹¤
    - **ë‹¤ë¥¸ ë³‘ë ¬ ì‘ì—…ê³¼ ê³µìœ ë  ìˆ˜ ìˆê¸° ë•Œë¬¸ì—**, ì˜ˆê¸°ì¹˜ ì•Šê²Œ ì„±ëŠ¥ì´ ì €í•˜ë  ìˆ˜ ìˆìœ¼ë©°, ì§ì ‘ ì»¤ìŠ¤í…€ ForkJoinPool ì„ ì“°ê³  ì‹¶ë‹¤ë©´ `stream().parallel().collect(...)` ëŒ€ì‹  `poolsubmit(() -> stream.parallel()...)` ê³¼ ê°™ì€ íŒ¨í„´ì„ ì‚¬ìš©í•´ì•¼ í•œë‹¤.

5. **Boxing / Unboxing** ë¹„ìš©
    - ë‚´ë¶€ì ìœ¼ë¡œ Stream<Integer> ì´ë¼ë©´ **Auto Boxing** ì—ì„œ (**-128 ~ 127** ëŠ” ê°ì²´ ìƒì„±ì´ ì¼ì–´ë‚˜ì§€ ì•ŠìŒ, ì´ë¯¸ ìƒì„±ë˜ì–´ ìˆê¸° ë•Œë¬¸) ê´œì°®ì§€ë§Œ í° ê°’ì€ ë§¤ë²ˆ ê°ì²´ë¥¼ ìƒì„±í•˜ì—¬ Heap ì„ ì‚¬ìš©í•˜ê²Œ ëœë‹¤.
    - ì´ ë§ì€ ê¸°ë³¸í˜•ì€ ìŠ¤íƒ/ë ˆì§€ìŠ¤í„° ìˆ˜ì¤€ì—ì„œ ì²˜ë¦¬ë˜ì§€ë§Œ, ë˜í¼ íƒ€ì…ì€ í™ ê°ì²´ë¡œ ì°¸ì¡°ëœë‹¤ëŠ” ì˜ë¯¸ì¸ë°, int ì˜ primitive ëŠ” ê¸°ë³¸ì ìœ¼ë¡œ 4 byte ì¸ë° ë°˜í•´ `Integer` ëŠ” 8 byte ì˜ ë ˆí¼ëŸ°ìŠ¤í˜• ì´ë¯€ë¡œ í™ì— ìƒì„±ë˜ëŠ”ê²Œ ë‹¹ì—°í•˜ë‹¤. í•˜ì§€ë§Œ `Integer` ì—ì„œë„ ì‘ì€ ê°’(-128 ~ 127) ì— ëŒ€í•´ì„œëŠ” ìºì‹±ì´ ë˜ì–´ì„œ í™ì„ ì‚¬ìš©í•˜ì§€ ì•Šì•„ ë¹„ìš©ì´ ê·¸ë ‡ê²Œ í¬ì§€ ì•Šë‹¤ë¼ëŠ” ì˜ë¯¸ì´ë‹¤.
    - ìœ„ì™€ ê°™ì€ ìƒí™©ì´ ë˜ë©´ GC ë¶€í•˜ê°€ ì¦ê°€ê°€ë˜ë©°, ë¶ˆí•„ìš”í•œ **Boxing** ìœ¼ë¡œ ê°ì²´ê°€ ë‚¨ë°œë˜ì–´ì„œ GC ë¶€ë‹´ì´ ì»¤ì§€ê²Œ ëœë‹¤.
    - ê¸°ë³¸í˜•ì€ CPU ëª…ë ¹ì–´ í•˜ë‚˜ë¡œ ê³„ì‚°ì´ ê°€ëŠ¥í•˜ê³ , ë˜í¼ íƒ€ì…ì€ **Unboxing** í›„ ê³„ì‚°ì„ í•˜ê¸° ë•Œë¬¸ì— ë‹¤ì‹œ **Boxing** ì„ ë˜ í•´ì•¼í•˜ë¯€ë¡œ ì¶”ê°€ ì˜¤ë²„í—¤ë“œê°€ ë°œìƒí•œë‹¤.

> ì‚¬ì‹¤ Integer ì— í—¤ë” ìì²´ê°€ ë³´í†µ 12 ~ 16 byte ê°€ ë  ìˆ˜ë„ ìˆê³ , ìµœì†Œ 16 byte ì´ìƒ ì°¨ì§€í•  ìˆ˜ë„ ìˆë‹¤(JVM êµ¬í˜„ì— ë”°ë¼ ë‹¤ë¥´ë‹¤).

##### ì–¸ì œ ì‚¬ìš©í•˜ë©´ ì¢‹ì„ê¹Œ?

â­•ï¸ ê¸°ë³¸ì ìœ¼ë¡œ ë‹¤ìŒì„ ì „ë¶€ ë§Œì¡±í•  ë•Œ ì‚¬ìš©í•˜ë©´ ì¢‹ë‹¤.

- **CPU Bound ì—°ì‚°**
    - `map()`
    - `filter()`
    - `reduce()`: ìˆœì„œ ì˜ì¡´ì´ ì—†ëŠ” ê²½ìš°ë§Œ
    - `collect()`: ìˆœì„œ ì—†ëŠ” ìë£Œí˜•ì˜ collecting
    - `distinct()`
- ë°ì´í„° í¬ê¸°ê°€ ë§¤ìš° í´ ë•Œ
- ìˆœì„œê°€ ì¤‘ìš”í•˜ì§€ ì•Šì€ ì—°ì‚°
- ë¶ˆë³€ ë°ì´í„° ì‚¬ìš© ì‹œ

âŒ ë‹¤ìŒì—ëŠ” ì‚¬ìš©í•˜ì§€ ë§ì
- `findFirst()`
- `forEachOrdered()`
- `groupingBy()`
- ì‘ì€ ë°ì´í„°ì— ëŒ€í•œ ëª¨ë“  ì²˜ë¦¬

Boxing / Unboxing ì„ í”¼í•˜ëŠ” ë°©ë²•ì„ ë³´ì.

- `Stream<Integer>` ë³´ë‹¤ëŠ” `IntStream`, `LongStream`, `DoubleStream` ìœ¼ë¡œ primitive stream ì‚¬ìš©

- `Stream<Integer>` ë¡œ ë˜ì—ˆì„ ë•ŒëŠ” `.mapToInt` ì™€ ê°™ì€ **Unboxing** ê¸°ëŠ¥ìœ¼ë¡œ primitive ë³€í™˜ í›„ì— ë³‘ë ¬ ì²˜ë¦¬ ì‚¬ìš© ì´í›„ì—ëŠ” `.boxed()` ë¡œ ë‹¤ì‹œ **Boxing** ì²˜ë¦¬

- ìë°” í‘œì¤€ì—ëŠ” ì—†ì§€ë§Œ, `fastutil`, `Trove`, `HPPC` ê°™ì€ ì™¸ë¶€ ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” `IntList`, `IntSet`, `Int2IntMap` ê°™ì€ primitive ì»¬ë ‰ì…˜ì„ ì œê³µ â†’ List<Integer>ë³´ë‹¤ ë©”ëª¨ë¦¬ / ì„±ëŠ¥ íš¨ìœ¨

- `Integer.valueOf()` ê°€ ~128 ~ 127 ë²”ìœ„ëŠ” ìºì‹±í•˜ëŠ” ê²ƒì²˜ëŸ¼ ì§ì ‘ ìºì‹œ í…Œì´ë¸” êµ¬í˜„ ê°€ëŠ¥

- `Optional` ë„ `primitive` ë²„ì „ì„ í™œìš©
    - `OptionalInt`, `OptionalLong`, `OptionalDouble`
