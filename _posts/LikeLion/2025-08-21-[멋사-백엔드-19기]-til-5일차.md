---
layout: post
title:  "[멋사 백엔드 19기] TIL 5일차"
date:   2025-08-21 11:09:00 +0900
categories: 멋쟁이사자처럼 멋사 백엔드 TIL Java
---

<!--more-->

## 📂 목차

- [Parameter](#parameter)
    - [Pass-by-value](#pass-by-value)
    - [가변 길이 매개변수 받기](#가변-길이-매개변수-받기)
- [Static](#static)
    - [Static Field](#static-field)
    - [Static Method](#static-method)
    - [static 초기화 블록](#static-초기화-블록)
    - [Nested Class](#nested-class)
        - [Static Nested Class](#static-nested-class)
        - [Inner Class](#inner-class)
- [⭐️ JVM 의 메모리 공간](#️-jvm-의-메모리-공간)
    - [ClassLoader](#classloader)
    - [GC 가 메모리를 회수](#gc-가-메모리를-회수)
        - [Generational Collection Theory](#generational-collection-theory)
    - [Hotspot JVM](#hotspot-jvm)
        - [Virtual Machine Stack & Native Machine Stack](#virtual-machine-stack--native-machine-stack)
        - [Metaspace](#metaspace)

---

## 📚 본문

참고: [JVM 밑바닥까지 파헤치기](https://jaeseo0519.tistory.com/467?category=1260842#2.%20Java%20Heap%20Overflow-1)

### Parameter

**parameter** 는 메서드 선언부에 정의된 변수이며, 그 매개 변수 내의 값을 argument 라고 한다.

#### Pass-by-value

모든 매개변수 전달 시 값에 의한 전달 방식을 사용한다. 매개체에 따라 두 가지 전달 유형이 있는데

1. **Primitive type** 을 전달할 때에는 값 자체가 복사되어 메서드로 전달하며, 메서드 내부에서 변경해도 원본에 영향이 없다.

2. **Reference type** 을 전달할 때에는 주소가 복사되어 전달되므로 객체 내부 상태는 수정 가능하며, 참조 자체를 다르게 바꾸면 원본에는 영향이 없게 된다.

#### 가변 길이 매개변수 받기

자바에서 메서드의 파라미터에는 매개변수를 가변길이로 받을 수 있도록 ... 기능을 넣어주셨는데, 다음 규칙을 따라야 한다:

- String... args 형태로 선언할 수 있다. 이는 내부적으로 String Array 와 동일하여 컴파일러가 자동으로 처리해준다.
- 한 메서드에서 가변 매개변수는 매개변수들 맨 뒤에 선언해주어야 한다.
- 한 메서드에서 가변 매개변수는 오로지 하나만 가능하다.
- null 값이 들어갈 수 있으므로 `NPE` 예외처리를 해주어야 한다.
- 성능을 고려하여 빈번한 호출 시 성능에 부담을 줄 수 있으므로 가급적 primitive 변수를 넘겨주는게 좋다.
- 만약 같은 타입의 가변 길이 메서드와 그냥 여러 개 매개변수 받는 메서드가 있다면, 개수에 따라 여러 개 매개변수를 우선으로 한다.

> 초보자는 `가변 길이 매개변수`를 쓰지 말자. [] 로도 충분히 인자를 받을 수 있다.

### Static

`static` 은 특별한 키워드이다. **정적**의 의미를 가지며, 정적 이라는 소리는 동적과는 반대되는 의미이다. 동적이라는 것은 움직이는, 변하는의 의미를 가진다. 정적은 그 메모리 그대로 변하지 않는 이라는 의미를 가진다 바뀔 수 있지만 가르키는 곳은 변화하지 않는다.

따라서 정적이라는 것은 동적과는 다르게 변하지 않을 것이며, 항상 메모리에서 유일하게 하나로 존재할 것이다. 그것이 **JVM 이 loading 될 때의 그 세상에 하나 메모리에 하나의 의미를 지니게** 될 것이다.

> 더 깊이있게 나아가자면, static 변수 정의 정보가 Method Area에 올라가며, JVM 이 올라가고 나서 Heap 에 로딩된다.

#### Static Field

필드는 클래스가 가지는 변수이다. 이 변수가 유일하다는 것이다.

이런 변수들은 `class` 가 `public` 하고 `field` 가 `public static` 이면 다른 객체가 변경을 할 수 있게 된다.

이미 메모리에 올라와져 있는 이 `static` 키워드가 붙은 field 값을 굳이 `instance initializing` 을 하지 않아도 접근이 가능하다.

```java
public class C { public static final int N = 42; }
// C.N 접근 가능
```

> 주의! 공유 상태이기 때문에 `volatile` / `Atomic` / `Lock` 으로 가시성, 원자성 보장이 필요하다.

#### Static Method

이 또한 마찬가지이다. `static` 이 붙었기에 메모리에 미리 올라와 있으며, 굳이 instance 를 선언해주지 않아도 유틸 기능을 가지는 함수들을 이렇게 정의하여 사용할 수 있도록 한다.

다만 `extends` 할 때를 보자. 이때는 오버라이딩을 하면 선언된 변수의 타입에 맞춰서 함수를 실행하게 된다. 이해가 안되면 밑을 보자.

```java
class P { static void hi(){ System.out.println("P"); } }
class C extends P { static void hi(){ System.out.println("C"); } }

P p = new C();
p.hi();      // 컴파일타임 타입 P 기준으로 "P" 출력
C.hi();      // "C"
```

> 즉, 오버라이딩이 아닌 `메서드 숨김(hiding)` 이 일어나게 된다. 이 또한 공유이기 때문에 만약 해당 객체의 데이터를 수정한다, 삭제한다 등의 변경 사항이 일어날 때 `synchronized static` 을 붙여줘야 한다.


#### static 초기화 블록

클래스 **초기화 시에 딱 한 번**만 시행한다(JVM 이 올라갈 때 말하는 것).

클래스에 대해 딱 한 번 실행하고 싶은 코드가 있다면 이를 사용할 수 있다. 이 코드 스코프에서 던져지는 예외는 `ExceptionalInInitializerError` 로 래핑되어 던져지며, 이 이후에 클래스를 다시 쓰면 `NoClassDefFoundError` 가 일어나게 된다. 이 상황을 만들어보자.

```java
class Bed {
    static {
        if (true) {
            throw new RuntimeException("boom");
        }
    }
}
```

클래스는 무조건 `Exception` 을 띄운다. 이때 JVM 이 `Bed` 클래스를 처음 로드 & 초기화를 할 때 `static` 블록이 실행되는데,

```java
public class Main{
    public static void main(String[] args) {
        Bed bed = new Bed(); // Exception 발생
    }
}
```

여기서 처음 `ExceptionInIntializerError` 가 발생되며 이는 초기화가 제대로 수행되지 않았다는 소리가 된다. 당연히 `Exception` 이 발생하여 트랩을 발생시키면 제어권을 OS가 가져가게 되고, 이는 명령을 그때부터 더이상 수행할 수 없게 되는 것이다.

이제 이 클래스는 초기화 실패한 클래스로 JVM에 표시되어 있고, 이를 `new Bed()` 를 하거나 `Bed.(static 메서드)()` 를 하면 `ExceptionInInitializerError` 가 발생하게 된다.

```java
public class Main{
    public static void main(String[] args) {
        Bed bed = new Bed(); // Exception 발생
    }
}
```

#### Nested Class

`Nested(중복)` 클래스는 클래스 안에 클래스를 넣는 설계이다. 보통은 두 종류가 있다(함수 내부에서 선언하는 class 도 있음):

- `static` 키워드가 붙은 `Static Nested Class`

- `Inner Class(static 없음)`

##### Static Nested Class

`static` 키워드가 붙은 중첩 클래스이며, 바깥 클래스의 인스턴스 멤버에는 접근이 불가한 형태이다. 바깥 클래스의 `static` 멤버에는 대신 접근이 가능하다.

이것 또한 JVM 을 심도 있게 안다면 바로 알 수 있는 내용인데 `static` 자체는 JVM 이 올라가고 나서 인스턴스 및 변수가 `Heap` 영역에 로드, 위치하게 된다.

**따라서 `Static Nested Class` 는 바깥 클래스의 인스턴스에 종속된게 아니다.** static 으로 되어진 변수나 함수는

1. JVM 이 올라가고
2. 클래스 로딩이 끝나고
3. `static nested class` 의 클래스 메타데이터가 `Method Area` 에 올라간 후
4. `Heap` 영역에 static 변수나 함수를 먼저 올리는 것을 알 수 있다.

이 말은 바깥 클래스의 객체 상태(`this`)와는 독립적으로 존재하기 때문에(initializing 을 안하여도 존재하기 때문에), 바깥 클래스의 인스턴스 필드에 접근할 수 없고 오직 정적 멤버만 참조 가능하다는 것이다(아직 초기화하지 않았기 때문). <- 이거는 `public static void main` 에서 `static` 이 아닌 method 를 불러올 때도 마찬가지로 에러가 뜸을 볼 수 있는 것과 동일한 원리다.

만약 `Static Nested Class` 가 설계된 `.class` 파일을 `javac` 로 컴파일 하게 되면 `Outer$StaticNestedClass.class` 와 같은 별도의 클래스 파일이 생성됨을 볼 수 있을 것이다(중요).

또한 이때 `GC` 가 이 `Static Nested Class` 에 대해서도 이미 컴파일된 파일 자체가 독립적으로 되었기 때문에 이는 바깥 클래스 인스턴스의 생명주기와 얽히지 않고 독립적으로 관리하는 것으로 유추해볼 수 있다.

따라서 다음 특징으로 정리해볼 수 있겠다:
- Memory Independence
- 역할과 책임의 분리

##### Inner Class

`static` 키워드가 없다. 이는 바깥 클래스의 모든 멤버에 접근이 가능하다는 것이며, 대신 바깥 클래스의 인스턴스가 반드시 존재할 때 이 또한 비로소 접근을 할 수 있을 터이다.

> 우선 초기화를 해야 메모리에 적재가 되기 때문

하지만 이 `Inner Class` 는 많이 사용하지는 않는데, 숨은 참조가 발생하여 바깥 클래스를 암묵적으로 참조하여 `GC` 가 `Outer` 인스턴스를 수거해갈 수 없는 상황이 발생할 수 있기 때문에 메모리 누수가 발생할 수 있다. 진짜 그 클래스와 의미론적으로 강한 연관(`Node` 와 `List` 간의 관계)이 있는게 아닌 이상 굳이 사용하지 않는다.

### ⭐️ JVM 의 메모리 공간

![JVM7-8-Memory]({{ site.baseurl }}/assets/img/JVM7-8-Memory.png)

더 깊이 있게 들어가보자. JVM 은 프로그램을 실행할 때 OS 위에서 자바 프로세스만의 메모리 공간을 따로 확보해서 운영한다.

> 마크 서버를 운영해보면 알 수 있다.

이 할당된 JVM 의 메모리 구조는 다음 영역으로 다시 구분되게 되는데:
- `Method Area / Metaspace` 클래스 수준의 정보가 올라가는 공간
    - 클래스 로딩 정보(`ClassLoader` 가 읽어들인 바이트 코드)
    - `static` 변수
    - `static class`
    - 메서드, 생성자 코드
    - 모든 스레드가 공유하는 영역

> Java 7 까지는 PermGen 이라는 명칭이었다. 바뀐 후에는 Native Memory 를 사용하게 되고 이름도 Metaspace 나 Method Area 로 불리게 된다.

- `Heap`: 객체가 생성되는 공간
    - `new` 붙은 놈들
    - `GC` 의 대상
    - `Constant Pool`
    - 스레드 간에 공유할 수 있음

- `Stack`: 각 스레드 마다 독립적으로 존재하는 메모리 영역
    - 메서드 호출 시마다 `Stack Frame`(가상 메모리 공간에서의 프로세스 하나 당 기본 단위와 유사한 개념) 이 쌓임
    - {지역 변수, 피연산자 스택, 현재 메서드의 `Constant Pool` 참조 등등}으로 구성
    - 메서드 종료 시 스택 프레임이 제거됨

- `PC Register`: 각 스레드 마다 하나씩 존재(여기서 주의할 점은 실제 하드웨어 PC를 말하는게 아니다... 그냥 SW의 추상화된 형태로 PC를 제공한다 Java 가 독립적인 이유에 한 몫 하는 변수이다)
    - 현재 실행 중인 JVM 명령어의 주소를 저장
    - 스레드 전환 시, 다시 돌아왔을 때 실행 위치를 잃지 않도록 함.

- `Native Method Stack`: Java 가 아닌 네이티브(C, C+) 코드 등의 **JNI(Java Native Interface)** 호출 을 실행할 때 사용하는 스택
    - 일반 자바 스택과 유사하지만, 네이티브 라이브러리를 위한 공간임
    - ex. `System.arraycopy()`, `Object.hashCode()`, `Object.clone()` 등등 네이티브로 구현됨
    - 왜 있냐? 모든 기능을 자바로 구현하기는 힘듦. OS/HW의 밀접하게 의존해야 할 때는 더 `low-level` 의 언어가 필요함. 이때 C, C++을 사용하지만, 언어 자체가 달라서 이를 호환시키도록 하는게 **JNI**

> `JNI` 를 쓸때는 그래서 그냥 `Stack` 이 아닌 `Native Method Stack` 이 사용된다. 이는 C 함수의 호출 처럼 동작하게 됨. 네이티브 코드 실행은 GC의 관리영역 밖이기 때문에 사용에 주의해야 하며, 보안 검사 등도 유의해야 한다... 꼭 필요한 경우만 사용하자.

```
┌──────────────────────────┐
│        Method Area        │ ← 클래스 정보, static, 상수 풀
│        (Metaspace)        │
├──────────────────────────┤
│           Heap            │ ← 객체 저장, GC 대상
├──────────────────────────┤
│      PC Register (T)      │ ← 각 스레드별 현재 실행 주소
│        Java Stack (T)     │ ← 각 스레드별 메서드 실행
│  Native Method Stack (T)  │ ← 각 스레드별 네이티브 코드 실행
└──────────────────────────┘
```

![jvm-memory]({{ site.baseurl }}/assets/img/jvm-memory.png)

#### ClassLoader

이제 JVM 의 메모리 개념을 이해했다면 `ClassLoader` 를 이해할 수 있게 되는데, 이름 그대로 자바에서 `.class` 바이트 코드를 JVM 메모리에 적재하는 역할을 한다.

실행 시점에서 **동적으로 클래스 로딩**을 하기 때문에 자바는 한 번 컴파일을 하면 어디서든 실행된다는 특징을 가질 수 있다.

**클래스 로딩 과정**

클래스 로더의 순서는 `Bootstrap ClassLoader` -> `Extension ClassLoader` -> `Application ClassLoader` 순으로 진행되며 각각은 다음 과정을 거친다.

1. Loading
    - `.class` 파일들 JVM 에 적재
    - `ClassLoader` 가 파일 읽음
2. Linking
    - Verify: 바이트코드가 JVM 규칙 위반하는지 안하는지
    - Prepare: `static` 변수에 메모리 할당
    - Resolve: 심볼릭 참조를 실제 참조로 변환
3. Initialization
    - `static` 변수에 값 할당
    - `static` 블록 실행
    - 최초 클래스가 사용될 때 한 번 만 실행됨

> 이 과정을 보면 알겠지만, `static` 이 여기서 올라감을 볼 수 있다.

**Bootstrap ClassLoader**

JVM 자체에 내장되어 있고, `JAVA_HOME/lib` 안의 핵심 클래스(`java.lang.*`, `java.util.*`) 로딩

제일 먼저 동작하고, 다른 클래스 로더의 부모 역할 함.

**Extension ClassLoader(Platform ClassLoader)**

`Bootstrap` 이 찾지 못한 클래스들을 로딩하며, JDK 확장 라이브러리(`lib/ext` 또는 모듈)을 로드한다. 예를들면 `javax.*` 가 있겠다(사실 잘 모른다 그런 추측이다. `javax` 는 `java` 에서 extension 이 붙어서 다양한 기능으로 서드 파티가 구현한게 자주 쓰여서 실제로 공식 `java` 라이브러리에도 등록되어서 쓰고 있는 것으로 안다).

**Application ClassLoader(System ClassLoader)**

`Extension ClassLoader` 가 못찾은 클래스만 로딩한다. 

우리가 설계한 어플리케이션 `.class` 파일이 최종적으로 적재되는 것(우리는 구현되어 있는걸 가져다 쓰기 때문에 가장 최후에 선언됨).

#### GC 가 메모리를 회수

java 는 실행할 때 할당할 수 있는 메모리 영역을 지정할 수 있다.

```java
-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError
```

> 메모리가 overflow됐을 때 JVM이 예외 발생 시점의 힙 메모리 snapshot을 파일러 저장(dump)해주는 옵션

반드시 쓰이지 않는 것은 `null` 로 바꾸어 해제시켜주자.

##### Generational Collection Theory

아직 이를 공부하기에는 굳이 인 느낌이 있지만, 적어놓고 나중에 다시 보려고 한다. 옛날 이론이라 지금이랑 또 다를 수 있다.

통계학적으로 다음이 밝혀졌다:
- 대부분 객체는 얼마 지나지 않아 사용하지 않는다
- 오래된 객체에서 젊은 객체로의 참조는 아주 적게 존재한다.

메모리 회수 관점에서 GC들이 이걸 참조한다고 한다.

이 이론에 따르면 다음과 같이 메모리 영역을 구분한다:
- 신세대(new generation)
    - 에덴 영역(Eden): 가장 처음 객체가 메모리에 할당되는 공간, GC 가 1회 수행 후에는 Survivor 영역 중 하나로 이동
    - 생존자 영역: from, to 두 부분으로 나뉘며, 둘 중 하나는 반드시 비어있다.  여러 번 생존에 성공 시 구세대로 승격한다.
- 구세대(old generation)
    - 신세대에서 오래 살아남은 객체들의 정보가 복사되어 있는 공간임  
    GC는 적게 발생하고, 신세대에 비해 큰 메모리를 할당받게 된다.
    - `Card Table`: 구세대에서 신세대 영역으로의 참조 테이블을 말하며, 512 bytes chunk 로 구성된다고 한다(옛날 정보)
- 영구세대(permanent generation)
    - 고정 메모리 크기 공간이며 -XX 옵션으로 지정한다.
    - 위 세대 영역들과 아무런 관련이 없으며, GC 가 발생 여부도 독립적이다.

PermGen 이 이 영역이며, 이 이론을 토대로 설계를 했지만 지금은 삭제하고 없음을 볼 수 있다.

#### Hotspot JVM

JVM은 추상화된 개념이지 실제 있는건 아니다. 이 구현체가 바로 Hotspot JVM 이며, JVM 구현체 중 하나이다. 위 그림도 이 Hotspot JVM에서 나온 것이다.

##### Virtual Machine Stack & Native Machine Stack

네이티브 머신 스택은 이미 얘기했다. 가상 머신 스택을 얘기하자.

JVM 내부에서 각 스레드 마다 독립적으로 존재하는 메모리 공간이다. 여기가 우리가 일반적으로 말하는 Stack 이며, Stack Frame 을 쌓게 된다.

##### Metaspace

원래는 Constant Pool을 갖던 애였는데, `JDK8` 이상 부터 상수풀이라는 것이 Java Heap 으로 옮겨졌다.

> 이 다음에는 JVM 밑바닥까지 파헤치기 책을 읽어보는 것을 해볼 것이다.