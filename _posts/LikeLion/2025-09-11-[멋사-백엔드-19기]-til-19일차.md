---
layout: post
title:  "[멋사 백엔드 19기] TIL 19일차"
date:   2025-09-11 22:32:08 +0900
categories: 멋쟁이사자처럼 멋사 백엔드 TIL Database
---

<!--more-->


## 📂 목차
- [JOIN](#join)
    - [CROSS JOIN](#cross-join)
    - [INNER JOIN](#inner-join)
        - [JOIN 성능 측면](#join-성능-측면)
    - [OUTER JOIN](#outer-join)
    - [SELF JOIN](#self-join)
- [Sub Query](#sub-query)
- [Correlated Subquery](#correlated-subquery)
- [다양한 기능들](#다양한-기능들)
    - [Set Operation](#set-operation)
    - [Window 함수](#window-함수)

---

## 📚 본문

### JOIN

JOIN은 여러 테이블의 데이터들을 연결시켜 하나의 결과 집합으로 만드는 방법이다.

{% highlight sql %}
table_references:
    escaped_table_reference [, escaped_table_reference] ...

escaped_table_reference: {
    table_reference
  | { OJ table_reference }
}

table_reference: {
    table_factor
  | joined_table
}

table_factor: {
    tbl_name [PARTITION (partition_names)]
        [[AS] alias] [index_hint_list]
  | [LATERAL] table_subquery [AS] alias [(col_list)]
  | ( table_references )
}

joined_table: {
    table_reference {[INNER | CROSS] JOIN | STRAIGHT_JOIN} table_factor [join_specification]
  | table_reference {LEFT|RIGHT} [OUTER] JOIN table_reference join_specification
  | table_reference NATURAL [INNER | {LEFT|RIGHT} [OUTER]] JOIN table_factor
}

join_specification: {
    ON search_condition
  | USING (join_column_list)
}

join_column_list:
    column_name[, column_name] ...

index_hint_list:
    index_hint[ index_hint] ...

index_hint: {
    USE {INDEX|KEY}
      [FOR {JOIN|ORDER BY|GROUP BY}] ([index_list])
  | {IGNORE|FORCE} {INDEX|KEY}
      [FOR {JOIN|ORDER BY|GROUP BY}] (index_list)
}

index_list:
    index_name [, index_name] ...
{% endhighlight %}

MySQL 문법 정의서 인데, FROM 절에서 테이블 참조 를 어떻게 쓸 수 있는지에 대한 규칙을 나열한 것이다. SELECT 문에서도 당연히 봤을 것이다.

#### CROSS JOIN

카테시안 곱이며, 그냥 가능한 모든 조합의 경우를 결과로 내뱉는다. 하지만 이는 잘 사용하지 않으며, 여러 열이 있다면 굉장히 많은 행이 생성되므로 성능적으로 문제가 있다.

크로스 조인은 그냥 두 테이블을 FROM 절에 놓으면 된다.

{% highlight sql %}
SELECT *
FROM customers c, orders o;  -- 조인 조건 없음
{% endhighlight %}

보통은 JOIN 을 할 때는 그래서 조건을 주는게 오버헤드가 없다.

> 만약 여러 테이블을 JOIN한다면, N개의 테이블을 JOIN할 때 최소 (N-1)개의 조인 조건이 필요, 그래야 불필요한 Cartesian Product 를 방지할 수 있다.

#### INNER JOIN

{% highlight sql %}
-- 전통적인 조인 방식
SELECT 
    e.first_name,
    e.last_name,
    d.department_name
FROM 
    employees e, 
    departments d
WHERE 
    e.department_id = d.department_id;
{% endhighlight %}

예전에는 위처럼 코딩을 했지만, 테이블을 FROM 에 나열하고 WHERE 조건을 지정하게 되면 조인 조건과 필터 조건이 섞여 있어서 헷갈릴 수가 있다. 또한 실수로 조인 조건을 빼먹으면 CROSS JOIN 이 되어버려 모든 조합의 데이터가 만들어지게 된다.

따라서 지금은 ANSI SQL 표준 JOIN 문법을 사용한다.

{% highlight sql %}
-- JOIN ~ ON
SELECT 
    e.first_name,
    e.last_name,
    d.department_name
FROM employees e
JOIN departments d ON e.department_id = d.department_id;

-- JOIN ~ USING (동일한 컬럼명일 때)
SELECT 
    e.first_name,
    e.last_name,
    d.department_name
FROM employees e
JOIN departments d USING(department_id);

-- NATURAL JOIN (자동으로 같은 이름 컬럼 조인)
SELECT * FROM employees NATURAL JOIN departments;
{% endhighlight %}

##### JOIN 성능 측면

**INDEXINg**
INNER JOIN 은 조건이 잘 걸려있으면 효율적이다. 예를 들어 대상 테이블의 index 가 걸려있었다고 해보자. 이때 필터링을 주는 테이블의 값들을 기준으로 이들을 찾아내기만 하면 되는데, 찾아낼 때도 searching 작업이 필요하기에 여기에 index 를 걸어주면 더 빠르게 찾아낼 수 있게 되는 것이다.

indexing 이 안걸려 있었다면 searching 작업이 느려지게 되어서 성능 이점을 볼 수가 없게 된다. 또한 JOIN 없이 쓰면 기본적으로 cartesian 이 수행되는데 이는 굉장히 느리다. JOIN 이 있기에 가능하다.

**테이블 크기와 순서에 따른 성능**

조인하는 테이블이 크면 클수록 성능 영향이 크다. 일부 DBMS는 조인 순서를 바꿔 최적화하는 기능이 있어 상관이 없지만, 큰 테이블을 먼저 JOIN 하면 임시 테이블이 커져서 느려질 수 있게 된다.

예를 들어 customers 테이블에 1000 개의 레코드가 있고, orders 테이블에 1000000 레코드가 있다고 하자.

{% highlight sql %}
-- orders(100만 행) 기준으로 먼저 customers 와 JOIN
SELECT o.id, o.order_date, c.name
FROM orders o
JOIN customers c
ON o.customer_id = c.id;
{% endhighlight %}

무조건 대상 테이블은 작아야 한다. 위처럼 order 테이블을 먼저 가져와버리면 많이 가져온 행에 대해서 검색해야 할 양이 늘어나게 된다. 또한 작은 테이블을 index 를 생성해야 index 크기가 작아져서 검색할 양이 줄어들기에 customers 의 테이블이 먼저 작성되어야 하는 것이다.

{% highlight sql %}
SELECT o.id, o.order_date, c.name
FROM customers c
JOIN orders o
ON c.id = o.customer_id
{% endhighlight %}

위처럼 작성해주면 되겠다. 그리고 WHERE 을 써서 넣는다면 대상 테이블 크기가 더 작아져서 더 효율적이게 되겠다. 밑은 그 예시다.

{% highlight sql %}
-- 특정 VIP 고객의 주문만 찾고 싶을 때
SELECT o.id, o.order_date, c.name
FROM customers c
JOIN orders o
ON c.id = o.customer_id
WHERE c.vip = true;
{% endhighlight %}

**Sub Query, CTE** 


#### OUTER JOIN

아우터 조인에는 LEFT JOIN 과 RIGHT JOIN 이 있는데 기준만 다를 뿐 둘의 동작 방식은 동일하다.

LEFT JOIN 은 왼쪽 테이블의 모든 행이 전부 결과 테이블에 포함되어야 되며 RIGHT JOIN 은 그 반대다.

**LEFT JOIN**
{% highlight sql %}
-- 부서가 없는 직원도 포함
SELECT 
    e.employee_id,
    e.first_name,
    d.department_name
FROM employees e
LEFT OUTER JOIN departments d 
ON e.department_id = d.department_id;

-- LEFT JOIN으로 축약 가능
SELECT 
    e.employee_id,
    e.first_name,
    d.department_name
FROM employees e
LEFT JOIN departments d 
ON e.department_id = d.department_id;
{% endhighlight %}

**RIGHT JOIN**

{% highlight sql %}
-- 직원이 없는 부서도 포함
SELECT 
    e.employee_id,
    e.first_name,
    d.department_name
FROM employees e
RIGHT OUTER JOIN departments d 
ON e.department_id = d.department_id;
{% endhighlight %}

가령 두 테이블의 튜플들 전부를 결과 테이블에 나오도록, 즉 LEFT, RIGHT 둘 다 되도록 하게 하고 싶을 수 있다. 이를 FULL OUTER JOIN 이라고 하는데 이는 MySQL 에서는 지원하지 않기 때문에 LEFT JOIN, RIGHT JOIN, UNION 을 합쳐서 사용할 수 있겠다.

{% highlight sql %}
-- 방법 1: LEFT JOIN + RIGHT JOIN + UNION
SELECT 
    e.employee_id,
    e.first_name,
    d.department_name
FROM employees e
LEFT JOIN departments d ON e.department_id = d.department_id
UNION
SELECT 
    e.employee_id,
    e.first_name,
    d.department_name
FROM employees e
RIGHT JOIN departments d ON e.department_id = d.department_id
WHERE e.department_id IS NULL;  -- 중복 제거를 위해 추가
{% endhighlight %}

**Postgres, Oracle 등등**
{% highlight sql %}
-- PostgreSQL, SQL Server, Oracle에서 가능한 구문
SELECT 
    e.employee_id,
    e.first_name,
    d.department_name
FROM employees e
FULL OUTER JOIN departments d 
ON e.department_id = d.department_id;
{% endhighlight %}

#### SELF JOIN

자기 자신을 그냥 JOIN 절의 테이블로 넣어버리면 된다.

{% highlight sql %}
-- 직원과 상사 정보 조회
SELECT 
    e.employee_id AS 사원ID,
    e.first_name AS 사원이름,
    m.employee_id AS 상사ID,
    m.first_name AS 상사이름
FROM employees e
JOIN employees m ON e.manager_id = m.employee_id;
{% endhighlight %}

### Sub Query

nested class 처럼 여기서는 쿼리를 중첩시키도록 할 수 있다.

보통 sub query 는 잘 쓰지는 않는다. 그냥 Join 이 더 최적화에 좋고, 재사용이 어려우며, 디버깅이 불편하다는 단점이 있다.

그럼에도 불구하고 단일 값만을 가져오고 싶을 때는 sub query 를 쓰는게 더 좋을 수도 있고, 상황마다 가끔 쓰긴 한다.

**Single-row Subquery**
{% highlight sql %}
-- 평균 급여보다 적은 급여를 받는 사원
SELECT ename, sal
FROM emp
WHERE sal < (
    SELECT AVG(sal)
    FROM emp
);

-- 가장 먼저 입사한 사원
SELECT ename, hiredate
FROM emp
WHERE hiredate = (
    SELECT MIN(hiredate)
    FROM emp
);
{% endhighlight  %}

**Multi-row Subquery**

{% highlight sql %}
-- IN 연산자 사용
SELECT ename, sal, deptno
FROM emp
WHERE deptno IN (
    SELECT deptno
    FROM dept
    WHERE loc IN ('NEW YORK', 'DALLAS')
);

-- ANY 연산자 사용
SELECT ename, sal
FROM emp
WHERE sal > ANY (
    SELECT sal
    FROM emp
    WHERE deptno = 30
);

-- ALL 연산자 사용
SELECT ename, sal
FROM emp
WHERE sal > ALL (
    SELECT sal
    FROM emp
    WHERE deptno = 30
);
{% endhighlight %}

#### Correlated Subquery

외부 쿼리와 내부 쿼리가 서로 연관되어 있는 서브쿼리이다.

{% highlight sql %}
-- 자신이 속한 부서의 평균 급여보다 많이 받는 사원
SELECT o.ename, o.sal, o.deptno
FROM emp o
WHERE o.sal > (
    SELECT AVG(i.sal)
    FROM emp i
    WHERE i.deptno = o.deptno
);
{% endhighlight %}

별 특별할건 없다.

### 다양한 기능들

#### Set Operation

- UNION
- MINUS
- INTERSECT

#### Window 함수

보통 OVER 과 함께 동반되며, 사용할 때는 검색 후에 사용하는게 좋다.

- RANK
- ROW_NUMBER
- DENSE_RANK