---
layout: post
title:  "[멋사 백엔드 19기] TIL 38일차"
date:   2025-10-17 13:12:51 +0900
categories: 멋쟁이사자처럼 멋사 백엔드 TIL Java Spring
---

<!--more-->

## 📂 목차
- [Cookie](#cookie)
    - []()
    - []()
    - []()

- [Session]()
    - []()
    - []()

---

## 📚 본문

### Cookie

웹 브라우저와 서버 사이에서 정보를 작고 단순한 문자열 형태로 저장하고 주고 받는 방법이며, 서버가 브라우저에 데이터를 잠깐 기억해달라고 요청하면 브라우저는 이를 로컬에 저장하고 같은 도메인으로 요청할 때마다 서버에 다시 전달하게 된다.

**용도**
- 로그인 상태 유지(Session ID 저장)
- 사용자 선호 설정 저장(언어, 테마)
- 트래킹 및 분석(방문 기록, 장바구니 정보)

서버측에서는 응답으로 보낼때 쿠키를 저장해달라고 요청할 수 있고, 그때 HTTP 에는 `Set-Cookie` 헤더가 포함되게 된다. 이후에 브라우저가 요청을 서버에 한다면 자동으로 이 쿠키들이 전송되게 된다.

**서버 -> 브라우저 Set-Cookie 헤더**
{% highlight text %}
Set-Cookie: userId=park123; Path=/; Max-Age=3600; HttpOnly; Secure
{% endhighlight %}

**브라우저 -> 서버 Cookie**
{% highlight text %}
Cookie: userId=park123
{% endhighlight %}

> HTTP 상태를 보존하는 가장 낮은 레벨의 메커니즘이 바로 Cookie 이다.

#### Cookie 의 구성요소

- `Name`: 이름
- `Value`: 값
- `Domain`: 쿠키가 적용될 도메인
- `Path`: 쿠키가 적용될 경로
- `Max-Age`: 쿠키 유효기간(-1 이면 창을 껏다 키면 사라지는 옵션)
- `Secure`: HTTPS 에서만 전송
- `HttpOnly`: JS 에서 접근 불가, XSS 방어용
- `SameSite`: CSRF 공격 방지(`Strict`, `Lax`, `None`)

#### Spring 에서 Cookie 다루기

**@CookieValue 어노테이션을 통해 읽어오기**
{% highlight java %}
@GetMapping("/viewCookie")
public String viewCookie(@CookieValue(value = "userId", required = false) String userId,
                         Model model) {
    model.addAttribute("userId", userId);
    return "cookie_view";
}
{% endhighlight %}

> 브라우저에 쿠키가 저장되어 있고 `userId` 라는 이름의 쿠키가 있다면 들고옴 없으면 `null`

**쿠키 생성 및 저장**
{% highlight java %}
@PostMapping("/addCookie")
public String addCookie(CookieRequest cookieRequest, /* @ModelAttribute 생략 가능 */
                        HttpServletResponse response) {

    Cookie cookie = new Cookie(cookieRequest.cookieName(), cookieRequest.cookieValue());
    cookie.setPath("/");
    cookie.setMaxAge(-1);

    response.addCookie(cookie);

    return "redirect:/viewCookie";
}
{% endhighlight %}

> `@ModelAttribute` 는 하나의 object 만이 요청으로 오게 되면 생략이 가능하다.

**쿠키 삭제**
{% highlight java %}
@GetMapping("/delCookie")
public String deleteCookie(HttpServletResponse response) {
    Cookie cookie = new Cookie("userId", null);
    cookie.setMaxAge(0); // 만료
    cookie.setPath("/");
    response.addCookie(cookie);
    return "cookie_deleted";
}
{% endhighlight %}

> 브라우저에서 쿠키를 제거하려면 같은 이름, 같은 `Path`, `MaxAge=0` 으로 다시 보내야 함

##### setHttpOnly

자바스크립트에서 쿠키에 접근하는 것을 차단한다. 즉, `document.cookie` 로 접근할 수 없게 된다.

- `XSS` 공격 방지용
- `SessionID` 가 드러나지 않도록

##### setSecure

HTTPS 연결에서만 쿠키를 전송하도록 제한을하며, HTTP 요청에서는 이 쿠키가 전송되지 않는다.

- 네트워크 상에서 쿠키가 노출되는 것을 방지하고
- HTTP 의 암호화 부재로, 누군가 트래픽 감청 시 세션ID 가 노출되면 안된다

##### setSameSite

`CSRF` 공격 방지를 위해 쿠키가 어떤 요청 상황에서 전송될 수 있는지를 제한하는 옵션이다. 기본값은 `Lax` 이다.

> `CSRF` 는 요청을 보낸 페이지의 도메인 과 요청을 받는 서버의 도메인이 다를 수 있는데 이럴때 크로스 사이트 요청이라고 한다. 기본적으로 다른 사이트의 요청은 쿠키를 전송하지 않는다.

### Session

웹에서 `HTTP` 는 `stateless` 프로토콜이다. 즉, 요청 -> 응답 사이에 서버는 사용자를 기억하지 못하는데, 대부분의 웹 어플리케이션은 사용자 상태 유지가 필요하다.

여기서 등장하는 것이 `session` 이며, 세션은 서버가 클라이언트 별로 유지하는 일시적 데이터 저장 공간이라고 볼 수 있다.

#### Session 동작 원리

1. 사용자가 브라우저로 요청을 보냄
2. 서버는 세션 객체를 생성하고, 고유한 Session ID 를 발급 받음
3. 세션 ID 는 주로 쿠키(JSESSIONID) 를 통해 클라이언트에 전달됨
4. 클라이언트는 이후 요청마다 세션 ID 를 서버에 보내고, 서버는 이를 사용하여 세션 저장소를 조회하게 된다.

##### Session 생성

Spring MVC 에서 Session 은 `HttpSession` 인터페이스를 통해 제공되지만, 실제로는 `Servlet` 컨테이너(Tomcat, Jetty 등)에서 관리한다. 즉, Spring 이 직접 세션 객체를 만드는 것이 아니라 요청 시 `Servlet` 컨테이너가 세션을 정하고 Spring 은 그걸 활용한다.

따라서 `DispatcherServlet` 에서 받아진 `HttpServletRequest` 안에 `Session` 이 들어있게 된다.

1. `request.getSession()` 호출
    1. 요청 쿠키에 JSESSIONID 를 확인
    2. 없으면 새로운 세션 객체 새성
    3. 고유한 세션 ID 를 생성(UUID 또는 랜덤 문자열)
    4. 서버 메모리(기본은 HashMap 등)에 세션 저장
    5. 클라이언트에게 `Set-Cookie: JSESSIONID=랜덤값` 전송
2. 이후 요청에서 세션 사용
    1. 브라우저가 `JSESSIONID` 쿠키를 보내면 컨테이너가 세션 객체를 조회해서 반환
    2. Spring `Controller` 에서 바로 `session.getAttribute("user")` 등으로 접근 가능

#### Session 구조

- `HttpSession`: 인터페이스
- `StandardSession` (Tomcat 구현)
    - `id`: 세션 식별자
    - `creationTime`: 세션 생성 시간
    - `lastAccessedTime`: 마지막 접근 시간
    - `attributes`: 세션에 저장된 key-value `Map`

> Servlet 이 생성함을 알고 있자

#### Session 활용 예시

{% highlight java %}
@GetMapping("/login")
public String login(HttpSession session) {
    // 로그인 성공 후 사용자 정보를 세션에 저장
    session.setAttribute("user", "park");
    session.setAttribute("role", "admin");
    return "home";
}
{% endhighlight %}

> 이때 String, `Object` 로 들어가는데, `Object` 는 `Serializable` 해야 한다.

**SessionAttribute**

`@ModelAttribute` 처럼 여기서도 `@SessionAttribute` 의 `name` 옵션은 생략 가능하다.

{% highlight java %}
@GetMapping("/dashboard")
public String dashboard(@SessionAttribute(name="user", required=false) String user) {
    if (user == null) return "redirect:/login";
    return "dashboard";
}
{% endhighlight %}

**SessionAttributes**

이 어노테이션은 살짝 헷갈릴 수 있는데, 새롭게 접속하는 클라이언트는 쓸려는 `key` 가 `Session` 에 없기 때문에 `@ModelAttribute` 로 `key` 가 생성되면 `@SessionAttributes` 덕분에 이 값이 세션에도 저장되게 된다. 즉, HTTP Session 이 생성될 때마다 자동으로 저장하도록 지정한다.

{% highlight java %}
@SessionAttributes("visitCount")
public class SessionController {

	// HTTP Request 에서 모델에 값이 없을 때만 호출되는 애너테이션이다.
    // 하지만, 위에서 SessionAttributes 로 HTTP Session 범위로 만들었기 때문에 해당 key 는 세션이 끝날때까지 계속 유지
	@ModelAttribute("visitCount")
	public Integer initVisitCount() {
		System.out.println("initVisitCount");
		return 0;
	}

    ...
}
{% endhighlight %}

> 만약 클라이언트가 같은 컨트롤러의 다른 요청을 다시 보내게 되면 세션에 이미 `key` 가 존재해서, 이 값을 자동으로 `Model` 에 적용하고, 이 어노테이션은 `Controller` 단위로 적용되므로 다른 컨틀롤러에서는 해당 `key-value` 를 못쓴다. 다만, 다른 컨트롤러에서 동일 key 를 수동으로 꺼내서 쓰는건 가능하다. 세션은 공유 영역이기 때문

### JWT 토큰

JSON 기반의 URL-safe 토큰으로, 인증과 정보 전달에 사용한다. 서버가 발급한 토큰 안에 **claim** 이라는 정보가 들어있고, 클라이언트가 요청 시 토큰을 보내면 서버는 세션이 없이도 사용자 상태를 검증할 수 있게 된다(세션이 없기에 서버는 굉장히 가벼워짐).

- `Stateless` 인증가능
- 토큰 자체가 `Signature` 되어서 위변조를 방지한다

**Header.Payload.Signature 구조**

{% highlight java %}
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyMSIsImlhdCI6MTY5NTQ2NDg5OCwiZXhwIjoxNjk1NDY4NDk4fQ.Z7kY0lFzFZKxjH7g
{% endhighlight %}

#### JWT 구조

- `Header`: 토큰 타입(JWT), 서명 알고리즘명

> `{"alg":"HS256","typ":"JWT"}`

- `Payload`: 사용자 정보(claims), 만료 시간 등

> `{"sub":"user1","iat":1234567890,"exp":1234567990}`

- ⭐️ `Signature`: `HMACSHA256(Header + Payload, secret)`

> Z7kY0lFzFZKxjH7g...  
> ⭐️ Signature = HMACSHA256(base64UrlEncode(header) + “.” + base64UrlEncode(payload), secretKey) 의 코드를 거치게 된다.  
> signature 는 위변조를 방지하기 위해 넣는다.

최종적으로 `Header.Payload.Signature` 를 이어 붙이면 `JWT` 가 완성된다.

#### JWT 생성하기

스프링에서는 라이브러리를 사용하면 매우 간단히 `JWT` 토큰을 생성할 수 있다. 다음 의존성을 추가해준다.

{% highlight java %}
implementation 'org.springframework.boot:spring-boot-starter-security'
implementation 'org.springframework.boot:spring-boot-starter-oauth2-resource-server'
{% endhighlight %}

이제 다음 코드를 통해 간단히 생성할 수 있다.

{% highlight java %}
import com.auth0.jwt.JWT;
import com.auth0.jwt.algorithms.Algorithm;

public class JwtGenerator {
    public static void main(String[] args) {
        String token = JWT.create()
                .withSubject("user1")
                .withClaim("role", "ADMIN")
                .sign(Algorithm.HMAC256("secret-key"));
        System.out.println(token);
    }
}
{% endhighlight %}

####