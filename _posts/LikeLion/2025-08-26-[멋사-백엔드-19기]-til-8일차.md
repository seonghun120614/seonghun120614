---
layout: post
title:  "[멋사 백엔드 19기] TIL 8일차"
date:   2025-08-26 13:03:19 +0900
categories: 멋쟁이사자처럼 멋사 백엔드 TIL Java
---

<!--more-->

## 📂 목차
- [Abstract Class](#abstract-class)
- [Exception](#exception)

---

## 📚 본문

### Abstract Class

사실 추상 클래스는 잘못 구현되었다고 실제 James Gosling 이 말한 바 있다.

문제는 다음과 같다:

- 다중 상속 불가: 다중 상속을 막은 것에서 부터 공통 기능과 계약(메서드 시그니처)을 섞어야 하는 경우, abstract class 는 불편함.

```java
// 계약만 정의
interface Drivable {
    void drive();
}

// 공통 기능 포함
abstract class Vehicle {
    String model;

    public Vehicle(String model) {
        this.model = model;
    }

    // 공통 기능
    public void printModel() {
        System.out.println("Model: " + model);
    }

    // 추상 메서드 (계약)
    public abstract void startEngine();
}
```

```java
// Car는 Vehicle을 상속해야 하고 Drivable도 구현해야 함
class Car extends Vehicle implements Drivable {

    public Car(String model) {
        super(model);
    }

    @Override
    public void startEngine() {
        System.out.println("Car engine started!");
    }

    @Override
    public void drive() {
        System.out.println("Car is driving!");
    }
}

// 만약 다른 클래스도 상속해야 하면 abstract class 상속은 하나만 가능
class SportsCar extends Car /*extends SomeOtherClass*/ { 
    // 자바는 다중 상속을 막아서, Vehicle + SomeOtherClass 동시에 상속 불가
}
```

이는 굉장히 유연하지 못함.

- 인터페이스와 혼동: default 가 있는데도 이는 추상 클래스의 목적을 인터페이스가 흡수하게 된 것.

- 기능 제한: 생성자, 필드, 메서드 구현 모두 가능하지만, 서브 클래스가 이미 다른 클래스를 상속하고 있다면 abstract class 를 못쓰는 구조적 제약이 있음

이러한 이유로 **abstract class** 는 진짜 최상단 부모가 아니라면 쓰지 않는 것이 좋다.

#### Abstract Class 의 접근제한자

abstract class 를 선언할 때에는 `public`, `default` 로만 선언할 수 있다. 당연히 두 접근제한자는 클래스에 적용되는 접근제한자 규약이랑 똑같다.

- `public`: 모든 패키지 접근
- `default`: 같은 패키지 내에 접근

`protected` 가 없는 이유는 당연하다. 상속을 위한 기능인데 당연히 상속된 것들은 다 접근 가능해야 할 것이다.

> 메서드의 접근제한자는 private 를 제외하고 다 가능하다.  
이 이유는 서브클래스에서 이를 접근할 수 없게 되므로 구현하지 못하게 된다.

Constructor 에서의 접근제한자는 private 까지 가능하지만, 호출이 불가하기 때문에 거의 쓰이지 않는다.

#### 추상 클래스 구현 시 유의할 점

자바는 단일 상속만 지원하기 때문에 이미 다른 클래스를 상속받고 있는 경우 Abstract Class 를 추가로 상속할 수 없다. 따라서 공통 기능 + 계약을 묶어서 abstract class 로 만들면 유연성이 떨어진다.

가능하면 **공통 기능은 default 메서드가 있는 인터페이스로 대체**한다.

abstract class 는 진짜 상속 계층의 최상단 부모로서 **common state나 field 가 필요할 때만 사용하는 것**으로 한다.

또한 추상 클래스는 `static`, `final` 이 붙을 수 있지만, 해당 개념의 의미를 정확히 파악하여 이게 정말로 초기화가 가능한지, 접근이 가능한지를 따지면 어디에 `static` 이 붙을 수 있고 안 붙을 수 있는지 파악 할 수 있다.

### java.lang.Throwable

이제 자바에서 처리되는 유사 **Trap** 을 본다.

```
java.lang.Throwable
├── java.lang.Error                // 주로 JVM 레벨 문제
│   ├── VirtualMachineError
│   │   ├── OutOfMemoryError
│   │   └── StackOverflowError
│   ├── AssertionError
│   └── LinkageError
└── java.lang.Exception      // 프로그램에서 처리 가능한 예외
    ├── java.lang.RuntimeException // Unchecked Exception
    │   ├── NullPointerException
    │   ├── IndexOutOfBoundsException
    │   │   ├── ArrayIndexOutOfBoundsException
    │   │   └── StringIndexOutOfBoundsException
    │   ├── ArithmeticException
    │   ├── ClassCastException
    │   ├── IllegalArgumentException
    │   │   └── NumberFormatException
    │   ├── IllegalStateException
    │   ├── UnsupportedOperationException
    │   └── ConcurrentModificationException
    ├── java.io.IOException          // Checked Exception (입출력 관련)
    │   ├── FileNotFoundException
    │   ├── EOFException
    │   ├── InterruptedIOException
    │   └── ObjectStreamException
    │       ├── InvalidClassException
    │       ├── NotSerializableException
    │       └── OptionalDataException
    ├── java.sql.SQLException
    ├── ClassNotFoundException
    ├── NoSuchMethodException
    ├── NoSuchFieldException
    ├── InstantiationException
    └── ReflectiveOperationException
        ├── IllegalAccessException
        └── InvocationTargetException
```

우리가 마주하는 대부분의 예외는 `java.lang.RuntimeException`, `java.io.IOException` 이다.

여기서 `Error` 는 보통 처리하지 않고, `Exception` 을 try-catch 문으로 처리를 한다.

#### Checked Exception

Checked Exception 은 반드시 try-catch 문 혹은 throws 선언이 필요하다.

**필수**
- try-catch
- throws 문

이런게 없다면 컴파일이 실행되지 않는다.

#### Unchecked Exception

보통 처리하지 않으며, 선택적으로 try-catch 를 사용하여 에러 메시지를 띄울 수 있다.

```java
import java.io.*;

public class ExceptionExample {
    public static void main(String[] args) {
        // Checked Exception 예시: 파일 읽기
        try {
            FileReader reader = new FileReader("nonexistent.txt");
            reader.read();
            reader.close();
        } catch (FileNotFoundException e) {
            System.out.println("파일이 존재하지 않습니다: " + e.getMessage());
        } catch (IOException e) {
            System.out.println("파일 입출력 오류 발생: " + e.getMessage());
        }

        // Unchecked Exception 예시: 0으로 나누기
        try {
            int a = 10 / 0;
        } catch (ArithmeticException e) {
            System.out.println("산술 오류 발생: " + e.getMessage());
        }
    }
}
```

#### Error

보통 프로그램에서 처리하지 않고 JVM 레벨에서 실행이 종료된다거나 처리된다.

필요시 catch 가 가능하긴 하지만 권장되지는 않는다.

> 실제로 Checked Exception 을 마주칠 일이 없는데 필자는 BufferedWriter 을 사용할 때, 해당 함수를 사용하는 다른 함수들한테 전부 throws IOException 시그니처를 적용시켜줘야 하여 번거로웠다. 이때는 try-catch 를 활용하여 catch 스코프에서 Unchecked Exception 으로 던져주는 것이 좋을 듯하다.


### Interface

인터페이스도 Abstract Class 와 마찬가지로

- public
- default

를 사용 가능하다. 기능 목적은 똑같다.

#### Interface Field

인터페이스의 필드는 무조건 `public static final` 이어야 한다. 이는 별도로 명시하지 않아도 무조건 `public static final` 이 기본이 된다.

#### Interface Method

모든 인터페이스의 메서드는 기본적으로 public 이며, default, private 까지 사용 가능하다. static 도 당연 사용 가능하다.

---

## ✒️ 용어

###### 

---

## 🔗 관련 출처
- []()
