---
layout: post
title:  "[ë©‹ì‚¬ ë°±ì—”ë“œ 19ê¸°] TIL 30ì¼ì°¨ ë©€í‹°ìŠ¤ë ˆë”© ì‘ìš© í´ë˜ìŠ¤"
date:   2025-09-29 09:30:38 +0900
categories: ë©‹ìŸì´ì‚¬ìì²˜ëŸ¼ ë©‹ì‚¬ ë°±ì—”ë“œ TIL Java
---

<!--more-->

## ğŸ“‚ ëª©ì°¨
- [ì“°ë ˆë“œ ì‹¬í™”](#ì“°ë ˆë“œ-ì‹¬í™”)
    - [ì“°ë ˆë“œì™€ ìì›](#ì“°ë ˆë“œì™€-ìì›)
    - [wait(), notify(), notifyAll()](#wait-notify-notifyall)
    - [Producer-Consumer Problems](#producer-consumer-problems)
        - [êµ¬í˜„](#êµ¬í˜„)
    - [ExecutorService](#executorservice)
        - [shutdown()](#shutdown)
        - [Callable & Future](#callable--future)
    - [ReentrantLock](#reentrantlock)
        - [Condition](#condition)
    - [CountDownLatch](#countdownlatch)
    - [BlockingQueue](#blockingqueue)
    - [CyclicBarrier](#cyclicbarrier)
- [ëŒë‹¤](#ëŒë‹¤)
    - [First-Class Citizen](#First-Class-Citizen)
    - [Functional Programming Language](#functional-programming-language)
    - [ìµëª… êµ¬í˜„ ê°ì²´](#ìµëª…-êµ¬í˜„-ê°ì²´)
    - [FunctionalInterfaces](#functionalinterfaces)

---

## ğŸ“š ë³¸ë¬¸

### ì“°ë ˆë“œ ì‹¬í™”

ì‹¤ë¬´ì— ê·¼ê±°í•˜ì—¬ ë” ì˜ í™œìš©í•  ìˆ˜ ìˆê²Œ ë‹¤ì–‘í•œ ë©”ì„œë“œë“¤ì„ ë³¸ë‹¤.

#### ì“°ë ˆë“œì™€ ìì›

ì“°ë ˆë“œëŠ” ì²˜ë¦¬ íë¦„, ìì›ì€ ë°ì´í„°ë¡œ í™•ì‹¤íˆ êµ¬ë¶„ì‹œì¼œì•¼ í•œë‹¤. ê·¸ëŸ° ê´€ì ì—ì„œ ë³¼ë•Œ, repository, service ë“±ë“±ì€ ì „ë¶€ íë¦„ì´ê³ (Inmemory ëŠ” ì˜ˆì™¸), db, ì„ì‹œ ì €ì¥ ê³µê°„(ì„¸ì…˜, êµ¬ì„± ì •ë³´) ë“±ë“±ì€ ì „ë¶€ ìì›ì´ ë  ê²ƒì´ë‹¤.

synchronized ë¥¼ ê±¸ë•ŒëŠ” íŠ¸ë˜í”½ì´ ë§ì„ ë•Œ ì„œë²„ ì„±ëŠ¥ì´ ëŠë ¤ì§€ì§€ ì•Šì„ì§€ë¥¼ ê³ ë¯¼í•´ì•¼ í•œë‹¤.

{% highlight java %}
public Book addBook(String title,
                    String author) {
    var builder = new Book.Builder().setTitle(title)
                                    .setAuthor(author);
    Book book;

    // ë™ì‹œì„± ì´ìŠˆê°€ ìˆëŠ” ë¶€ë¶„ì˜ ì½”ë“œë§Œ lock ê±¸ê¸°
    synchronized (bookRepository) {
        book = builder.build(bookRepository.count() + 1);
        if (bookRepository.add(book) == null)
            throw new SystemException("ì±… ì €ì¥ ì‹¤íŒ¨");
    }

    return book;
}
{% endhighlight %}

#### wait(), notify(), notifyAll()

`wait`, `notify`, `notifyAll` ì€ ëª¨ë‹ˆí„° ë½ì„ ë³´ìœ í•œ ìƒíƒœì—ì„œ í˜¸ì¶œ ê°€ëŠ¥í•˜ë©°, critical region ì— ë“¤ì–´ê°€ëŠ” thread ë§Œì´ ì´ ë©”ì„œë“œë“¤ì„ ì“¸ ìˆ˜ ìˆë‹¤(Object ë¼ê³  ë‹¤ ì“¸ ìˆ˜ ìˆì§€ë§Œ ì½”ë“œ ë¸”ëŸ­ ìˆ˜ì¤€ì— ì œì•½ì´ ìˆìŒ).

> `sleep(ms)` ê³¼ì˜ ì°¨ì´ëŠ” lock ì„ ì¥” ì±„ë¡œ ëŒ€ê¸°í•˜ê¸°ì— ì–˜ëŠ” critical region ì— ì—†ë”ë¼ë„ í˜¸ì¶œ ê°€ëŠ¥í•˜ë‹¤.

#### Producer-Consumer Problems

Object ì—ëŠ” `wait`, `notify` ê°€ ìˆì–´ì„œ ëª¨ë“  í´ë˜ìŠ¤ë“¤ì— ëŒ€í•´ í•´ë‹¹ ë©”ì„œë“œë¥¼ ìˆ˜í–‰í•¨ì„ ë³¼ ìˆ˜ ìˆë‹¤.

ì—¬ê¸°ì„œëŠ” **Producer-Consumer** ë¬¸ì œë¡œ ì´ë¥¼ ë‹¤ë¤„ë³´ì. ìƒì‚°ìëŠ” ë°ì´í„°ë¥¼ ìƒì„±í•˜ì—¬ ë²„í¼ì— ê³µê¸‰ì„ í•œë‹¤. ì†Œë¹„ìëŠ” **Buffer** ì—ì„œ ë°ì´í„°ë¥¼ êº¼ë‚´ì–´ ì‚¬ìš©ì„ í•œë‹¤. ë²„í¼ëŠ” ìƒì‚°ìì™€ ì†Œë¹„ìê°€ ë°ì´í„°ë¥¼ ì£¼ê³ ë°›ëŠ” ê³µìœ  ê³µê°„ì´ë©°, ì§„ì—´ëŒ€ë¼ê³  ìƒê°í•˜ë©´ ëœë‹¤.

ë‹¤ìŒê³¼ ê°™ì€ ë¬¸ì œê°€ ë°œìƒí•œë‹¤:
- ë²„í¼ê°€ ê°€ë“ ì°¼ì„ ë•Œ: ìƒì‚°ìê°€ ë°ì´í„°ë¥¼ ë„£ìœ¼ë ¤ë©´ ëŒ€ê¸°í•´ì•¼ í•œë‹¤
- ë²„í¼ê°€ ë¶€ì¡± í•  ë•Œ: ì†Œë¹„ìê°€ ë°ì´í„°ê°€ ë“¤ì–´ì˜¬ ë•Œê¹Œì§€ ëŒ€ê¸°í•´ì•¼ í•œë‹¤
- ë™ì‹œ ì ‘ê·¼ ë¬¸ì œ: ì—¬ëŸ¬ ì†Œë¹„ìê°€ ë™ì‹œì— ë°ì´í„°ë¥¼ ì†Œë¹„í•˜ë ¤ê³  í•  ë•Œ ë°ì´í„°ê°€ ê¹¨ì§€ê±°ë‚˜ ëˆ„ë½ë  ìˆ˜ë„ ìˆë‹¤

##### êµ¬í˜„

ìš°ì„  ìƒí™© ì„¸íŒ…ì„ í•´ì£¼ì. ê¸°ë³¸ì ìœ¼ë¡œ ì§„ì—´ëŒ€ê°€ í•„ìš”í•  ìˆ˜ ìˆë‹¤.

{% highlight java %}
static final Object lock = new Object();
static final int MAX_SIZE = 10;
static boolean[] buffer = new boolean[MAX_SIZE];
static int consumeIdx;
{% endhighlight %}

ê·¸ ë‹¤ìŒ ìƒì‚°ìëŠ” ì´ buffer ì— ì±„ìš°ëŠ” 'í–‰ìœ„' ë¥¼ í•´ì•¼ í•œë‹¤.

{% highlight java %}
// ìƒì‚°
public static void produce() throws InterruptedException {
    synchronized (lock) {
        while(buffer[MAX_SIZE - 1])
            lock.wait();
        Arrays.fill(buffer, true);
        lock.notifyAll();
    }
    System.out.println("ìƒì‚° ì™„ë£Œ !!!, ëŒ€ê¸° ëª¨ë“œ on");
}
{% endhighlight %}

buffer ë¥¼ true ë¡œ ì±„ìš´ë‹¤.

{% highlight java %}
// ì†Œë¹„
public static void consume() throws InterruptedException {
    synchronized (lock) {
        while (!buffer[MAX_SIZE - 1]) {
            System.out.println("ì†Œë¹„ ëŒ€ê¸°ì¤‘");
            lock.wait();
        }
        buffer[consumeIdx] = false;
        consumeIdx = (consumeIdx + 1) % MAX_SIZE;
        lock.notify();
        System.out.println("ì†Œë¹„í•¨ í˜„ì¬ ì¬ê³ : " + Arrays.toString(buffer) + ", consumeIdx: " + consumeIdx);
    }
}
{% endhighlight %}

ì†Œë¹„ìëŠ” ìœ„ì™€ ê°™ì´ ì†Œë¹„í•˜ê²Œ ëœë‹¤. ë©”ì¸ì—ì„œëŠ” ì¬ê³ ë¥¼ ì±„ìš°ê³  ì†Œë¹„í•˜ë©´ì„œ ê°’ì´ ë°”ë€ë‹¤

{% highlight java %}
Thread produce = new Thread(() -> {
    while(true) {
        produce();
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }
});

Thread consume = new Thread(() -> {
    while(true) {
        consume();
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }
});

produce.start();
consume.start();
{% endhighlight %}

ìœ„ì™€ ê°™ì€ ìƒí™©ì€ ë¹„ì •ìƒì ì¸ ìƒí™©ì´ ì˜ ë§Œë“¤ì–´ì§€ì§€ ì•Šì§€ë§Œ, ì—¬ëŸ¬ ì†Œë¹„ìê°€ ë“¤ì–´ê°€ê²Œ ë˜ë©´ ë§ì´ ë‹¤ë¥´ë‹¤.

{% highlight java %}
Thread produce = new Thread(() -> {
    while(true) {
        try {
            produce();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        try {
            Thread.currentThread().sleep(1000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }
});

Thread consume1 = new Thread(() -> {
    while(true) {
        try {
            consume();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        try {
            Thread.currentThread().sleep(1000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }
});

Thread consume2 = new Thread(() -> {
    while(true) {
        try {
            consume();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        try {
            Thread.currentThread().sleep(1000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }
});

Thread consume3 = new Thread(() -> {
    while(true) {
        try {
            consume();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        try {
            Thread.currentThread().sleep(1000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }
});

produce.start();
consume1.start();
consume2.start();
consume3.start();
{% endhighlight %}

**consumer idx ê°€ ì ì ˆí•˜ê²Œ ì¦ê°€í•˜ì§€ ì•ŠëŠ” ìƒí™©**
> ì†Œë¹„í•¨ í˜„ì¬ ì¬ê³ : [true, true, false, false, false, false, false, false, false, false], consumeIdx: 0  
ì†Œë¹„í•¨ í˜„ì¬ ì¬ê³ : [false, false, false, false, false, false, false, false, false, false], consumeIdx: 2  
ì†Œë¹„í•¨ í˜„ì¬ ì¬ê³ : [false, false, false, false, false, false, false, false, false, false], consumeIdx: 2

**ìƒì‚°ë˜ê¸°ë„ ì „ì— ì†Œë¹„**
>ì†Œë¹„í•¨ í˜„ì¬ ì¬ê³ : [false, false, true, true, true, true, false, false, false, false], consumeIdx: 2  
ì†Œë¹„í•¨ í˜„ì¬ ì¬ê³ : [false, true, true, true, true, true, false, false, false, false], consumeIdx: 1  
ì†Œë¹„í•¨ í˜„ì¬ ì¬ê³ : [false, false, false, true, true, true, false, false, false, false], consumeIdx: 3  
6 ë§Œí¼ ì±„ì›€ í˜„ì¬ ì¬ê³ : [false, true, true, true, true, true, false, false, false, false], prodIdx: 6

ì´ë¥¼ ì •ìƒì ìœ¼ë¡œ ë§Œë“¤ê¸° ìœ„í•´ `consumer` ëŠ” ë²„í¼ì— ì¬ê³ ê°€ ìˆì„ ë•Œ, ë‹¤ì‹œ ë§í•˜ë©´ ì—†ì„ ë•ŒëŠ” ëŒ€ê¸° ìƒíƒœì— ë“¤ì–´ê°”ë‹¤ê°€, `producer` ê°€ ìƒì‚°í–ˆì„ ë•Œ ì¼ì–´ë‚˜ì„œ ì†Œë¹„ë¥¼ í•´ì•¼í•œë‹¤.

`producer` ëŠ” `consumer` ê°€ ë” ì´ìƒ ì†Œë¹„í•  ìˆ˜ ìˆëŠ” ì¬ê³ ê°€ ì—†ì„ ë•Œ ì¼ì–´ë‚˜ì•¼ í•œë‹¤. ê·¸ë ‡ë‹¤ë©´ ì“°ë ˆë“œ ê°„ì— ì„œë¡œ ê¹¨ìš´ë‹¤, ëŒ€ê¸°í•´ë¼ ë¼ëŠ” ì†Œí†µì„ í•´ì•¼í•˜ëŠ” ì°½êµ¬ê°€ í•„ìš”í•˜ë‹¤. ê·¸ ì°½êµ¬ê°€ ë°”ë¡œ ìì› `lock` ì´ë‹¤.

{% highlight java %}
static final Object lock = new Object();
...
public static void produce() throws InterruptedException {
    synchronized (lock) {
        while(buffer[MAX_SIZE - 1])
            lock.wait();
        Arrays.fill(buffer, true);
        lock.notifyAll();
    }
    System.out.println("ìƒì‚° ì™„ë£Œ !!!, ëŒ€ê¸° ëª¨ë“œ on");
}

public static void consume() throws InterruptedException {
    synchronized (lock) {
        while (!buffer[MAX_SIZE - 1]) {
            System.out.println("ì†Œë¹„ ëŒ€ê¸°ì¤‘");
            lock.wait();
        }
        buffer[consumeIdx] = false;
        consumeIdx = (consumeIdx + 1) % MAX_SIZE;
        lock.notify();
        System.out.println("ì†Œë¹„í•¨ í˜„ì¬ ì¬ê³ : " + Arrays.toString(buffer) + ", consumeIdx: " + consumeIdx);
    }
}
{% endhighlight %}

ì´ì œ ê³„ì†ì ìœ¼ë¡œ ìƒì‚° ì†Œë¹„ê°€ ë°˜ë³µë  ê²ƒì´ë‹¤.

#### ExecutorService

ìŠ¤ë ˆë“œ í’€ì„ ìƒì„±í•˜ì—¬ ë†€ê³  ìˆëŠ” ìŠ¤ë ˆë“œì— ëª…ë ¹ì„ ê°„í¸í•˜ê²Œ ë‚´ë¦´ ìˆ˜ ìˆë‹¤. ìŠ¤ë ˆë“œ í’€ì˜ ì‚¬ì´ì¦ˆëŠ” ìŠ¤ë ˆë“œ ê°œìˆ˜ì™€ ë˜‘ê°™ê³ , ìƒì„±ì€ Executors ì˜ ì •ì  ë©”ì„œë“œë¡œ í•œë‹¤.

{% highlight java %}
// ê³ ì • ìŠ¤ë ˆë“œ í’€
ExecutorService executor = Executors.newFixedThreadPool(4);
// ë‹¨ì¼ ìŠ¤ë ˆë“œ í’€
ExecutorService executor = Executors.newSingleThreadExecutor();
// ìºì‹œí˜• ìŠ¤ë ˆë“œ í’€: í•„ìš”í•  ë•Œ ìŠ¤ë ˆë“œ ë§Œë“¤ê³  ë†€ê³  ìˆëŠ” ìŠ¤ë ˆë“œê°€ ìˆìœ¼ë©´ ì¬ì‚¬ìš©
ExecutorService executor = Executors.newCachedThreadPool();

// ìŠ¤ì¼€ì¤„ë§ ê°€ëŠ¥í•œ í’€
ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);
// 5ì´ˆ ë’¤ì— ì‹¤í–‰
executor.schedule(() -> System.out.println("5ì´ˆ ë’¤ ì‹¤í–‰"), 5, TimeUnit.SECONDS);
// 1ì´ˆ ë’¤ ì‹œì‘, ì´í›„ 2ì´ˆ ê°„ê²©ìœ¼ë¡œ ë°˜ë³µ ì‹¤í–‰
executor.scheduleAtFixedRate(() -> System.out.println("ì£¼ê¸° ì‹¤í–‰"), 1, 2, TimeUnit.SECONDS);

// ë³‘ë ¬ ì²˜ë¦¬ íŠ¹í™” í’€
ExecutorService executor = ForkJoinPool.commonPool();
{% endhighlight %}

ìœ„ì²˜ëŸ¼ ì•ˆí•˜ê³  ë°‘ì²˜ëŸ¼ ì„¸ë°€í•œ ì¡°ì •ìœ¼ë¡œ í’€ì„ ìƒì„±í•  ìˆ˜ ìˆë‹¤.

**Custom Thread Pool ìƒì„±**
{% highlight java %}
ExecutorService executor = new ThreadPoolExecutor(
        2,                // core pool size
        4,                // maximum pool size
        60L,              // idle thread keep-alive time
        TimeUnit.SECONDS, // ì‹œê°„ ë‹¨ìœ„
        new LinkedBlockingQueue<>(100) // ì‘ì—… í
);
{% endhighlight %}

##### shutdown()

ìŠ¤ë ˆë“œ í’€ì„ ì¢…ë£Œí•˜ëŠ” ë©”ì„œë“œì´ë‹¤.

{% highlight java %}
executor.shutdown();
{% endhighlight %}

- ì´ë¯¸ ì œì¶œëœ ì‘ì—…ì€ ëª¨ë‘ ëê¹Œì§€ ì‹¤í–‰ë¨
- ìƒˆë¡œìš´ ì‘ì—… ì œì¶œì€ ê±°ë¶€ë¨

> `shutdownNow()` ëŠ” ê°•ì œë¡œ ëª¨ë“  ì‘ì—…ì„ ì¢…ë£Œí•˜ë©°, ì‹¤í–‰ ì¤‘ì¸ ìŠ¤ë ˆë“œëŠ” ì¸í„°ëŸ½íŠ¸ë¥¼ ë°œìƒì‹œì¼œ ì¦‰ì‹œ ì¢…ë£Œí•´ë²„ë¦°ë‹¤. ë°˜í™˜í•˜ëŠ” ê±´ List<Runnable> ì¸ë° ì‹¤í–‰ì¤‘ì¸ ìŠ¤ë ˆë“œì˜ ì‘ì—…ì— ëŒ€í•œ ê²ƒì€ ë°˜í™˜í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì— ì‘ì—…ì´ ë‚ ë¼ê°ˆ ìˆ˜ë„ ìˆë‹¤.


##### Callable & Future

í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ `Callable<V>` ì€ `V call()` ì„ êµ¬í˜„í•´ì•¼ í•˜ë©°, ë°˜í™˜ê°’ì´ ìˆëŠ” ì‘ì—…ì„ ì •ì˜í•  ìˆ˜ ìˆë‹¤. ì´ë¥¼ í†µí•´ `ExecutorService` ì—ê²Œ `submit(Callable callable)` ì— ë„£ì–´ ì œì¶œí•  ìˆ˜ ìˆë‹¤.

{% highlight java %}
import java.util.concurrent.*;

public class SumExample {
    public static void main(String[] args) throws Exception {
        ExecutorService executor = Executors.newFixedThreadPool(3);

        int[] numbers = new int[10];
        for (int i = 0; i < numbers.length; i++) numbers[i] = i + 1; // 1~10

        // ë°°ì—´ì„ 3ë¶€ë¶„ìœ¼ë¡œ ë‚˜ëˆ ì„œ í•© ê³„ì‚°
        Callable<Integer> sumPart1 = () -> {
            int sum = 0;
            for (int i = 0; i < 3; i++) sum += numbers[i];
            return sum;
        };
        Callable<Integer> sumPart2 = () -> {
            int sum = 0;
            for (int i = 3; i < 7; i++) sum += numbers[i];
            return sum;
        };
        Callable<Integer> sumPart3 = () -> {
            int sum = 0;
            for (int i = 7; i < 10; i++) sum += numbers[i];
            return sum;
        };

        Future<Integer> f1 = executor.submit(sumPart1);
        Future<Integer> f2 = executor.submit(sumPart2);
        Future<Integer> f3 = executor.submit(sumPart3);

        int totalSum = f1.get() + f2.get() + f3.get();
        System.out.println("ì´ í•©ê³„: " + totalSum);

        executor.shutdown();
    }
}
{% endhighlight %}

ì œì¶œ í›„ì— ì–»ìœ¼ë ¤ë©´ `Future<V>` ì´ í•„ìš”í•œë°, ë¹„ë™ê¸° ì‘ì—…ì— ëŒ€í•œ ê²°ê³¼ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ê°ì²´ì´ë‹¤. `V get()`, `V get(long timeout, TimeUnit unit)` ìœ¼ë¡œ ê°’ì„ ì–»ì–´ì˜¬ ìˆ˜ ìˆë‹¤.

**ì—¬ëŸ¬ ê°œ ê°’ ê°€ì ¸ì˜¤ê¸°**
{% highlight java %}
ExecutorService executor = Executors.newFixedThreadPool(3);

List<Callable<String>> tasks = List.of(
    () -> { Thread.sleep(1000); return "A ì™„ë£Œ"; },
    () -> { Thread.sleep(2000); return "B ì™„ë£Œ"; },
    () -> { Thread.sleep(1500); return "C ì™„ë£Œ"; }
);

List<Future<String>> futures = executor.invokeAll(tasks);

for (Future<String> f : futures) {
    System.out.println(f.get());
}

executor.shutdown();
{% endhighlight %}

#### ReentrantLock

ìì›ì— ëŒ€í•œ ë™ì‹œì„± ì œì–´ ë©”ì»¤ë‹ˆì¦˜ì´ë‹¤. ì´ì „ì—ëŠ” íë¦„ì´ ì£¼ëœ ì œì–´ ë©”ì»¤ë‹ˆì¦˜ì´ì—ˆë‹¤. `ReentrantLock` ì€ ì´ë¦„ ê·¸ëŒ€ë¡œ ê°™ì€ ìŠ¤ë ˆë“œê°€ ê°™ì€ ë½ì„ ì—¬ëŸ¬ ë²ˆ íšë“ í•œë‹¤.

{% highlight java %}
java.util.concurrent.locks.ReentrantLock
{% endhighlight %}

**ê¸°ë³¸ ì‚¬ìš©**

{% highlight java %}
import java.util.concurrent.locks.ReentrantLock;

class SharedResource {
    private final ReentrantLock lock = new ReentrantLock();
    private int count = 0;

    public void increment() {
        lock.lock();
        try {
            count++;
            System.out.println(Thread.currentThread().getName() + " : " + count);
        } finally {
            lock.unlock();
        }
    }
}
{% endhighlight %}

**ì‹œê°„ ì œí•œ**

{% highlight java %}
if (lock.tryLock()) {
    try {
        // ë½ ì–»ì—ˆì„ ë•Œë§Œ ì‹¤í–‰
    } finally {
        lock.unlock();
    }
} else {
    System.out.println("ë½ì„ ì–»ì§€ ëª»í•´ ë‹¤ë¥¸ ì‘ì—… ìˆ˜í–‰");
}

// ì¼ì • ì‹œê°„ë§Œ ì‹œë„
if (lock.tryLock(2, TimeUnit.SECONDS)) {
    try {
        // 2ì´ˆ ì•ˆì— ë½ ì–»ìœ¼ë©´ ì‹¤í–‰
    } finally {
        lock.unlock();
    }
}
{% endhighlight %}

##### Condition

{% highlight java %}
import java.util.concurrent.locks.*;

class BoundedBuffer {
    private final ReentrantLock lock = new ReentrantLock();
    private final Condition notFull  = lock.newCondition();
    private final Condition notEmpty = lock.newCondition();
    private final int[] buffer = new int[10];
    private int count, putPtr, takePtr;

    public void put(int x) throws InterruptedException {
        lock.lock();
        try {
            while (count == buffer.length) {
                notFull.await();  // ë²„í¼ ê½‰ ì°¨ë©´ ëŒ€ê¸°
            }
            buffer[putPtr] = x;
            putPtr = (putPtr + 1) % buffer.length;
            count++;
            notEmpty.signal();   // ì†Œë¹„ì ê¹¨ìš°ê¸°
        } finally {
            lock.unlock();
        }
    }

    public int take() throws InterruptedException {
        lock.lock();
        try {
            while (count == 0) {
                notEmpty.await(); // ë²„í¼ ë¹„ì—ˆìœ¼ë©´ ëŒ€ê¸°
            }
            int x = buffer[takePtr];
            takePtr = (takePtr + 1) % buffer.length;
            count--;
            notFull.signal();    // ìƒì‚°ì ê¹¨ìš°ê¸°
            return x;
        } finally {
            lock.unlock();
        }
    }
}
{% endhighlight %}

`wait`/`notify`/`notifyAll` ì„ `await`/`signal`/`signalAll` ë¡œ ëŒ€ì²´í•˜ê³  ì—¬ëŸ¬ ê°œì˜ Condition ì„ ë‚˜ëˆ„ì–´ ê´€ë¦¬í•˜ê³  ì‹¶ì„ ë•Œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

#### CountDownLatch

lock ì„ ì—¬ëŸ¬ê°œ ë†“ì„ ìˆ˜ ìˆë‹¤ê³  ë³´ë©´ ëœë‹¤. 0ì´ ë ë•Œê¹Œì§€ ëŒ€ê¸°í•  ìˆ˜ ìˆëŠ” ë©”ì»¤ë‹ˆì¦˜ì´ ìˆìœ¼ë©°, ì´ˆê¸°í™”ëœ ê°’ì„ ë‹¤ count í–ˆì„ ë•ŒëŠ” ì‚¬ìš©ì´ ë” ì´ìƒ ë¶ˆê°€í•˜ë‹¤.

{% highlight java %}
import java.util.concurrent.CountDownLatch;

public class CountDownLatchExample {
    public static void main(String[] args) throws InterruptedException {
        int nThreads = 3;
        CountDownLatch latch = new CountDownLatch(nThreads);

        for (int i = 0; i < nThreads; i++) {
            final int id = i;
            new Thread(() -> {
                System.out.println("ìŠ¤ë ˆë“œ " + id + " ì¤€ë¹„ ì™„ë£Œ");
                latch.countDown(); // ì¤€ë¹„ ì™„ë£Œ
            }).start();
        }

        System.out.println("ëª¨ë“  ìŠ¤ë ˆë“œ ì¤€ë¹„ë  ë•Œê¹Œì§€ ëŒ€ê¸°...");
        latch.await(); // ì¹´ìš´íŠ¸ê°€ 0ì´ ë  ë•Œê¹Œì§€ ëŒ€ê¸°
        System.out.println("ëª¨ë“  ìŠ¤ë ˆë“œ ì¤€ë¹„ ì™„ë£Œ! ì‘ì—… ì‹œì‘!");
    }
}
{% endhighlight %}

#### BlockingQueue

{% highlight java %}
public class BlockingQueueExample {
    public static void main(String[] args) {
        BlockingQueue<String> queue = new ArrayBlockingQueue<>(5);

        // ìƒì‚°ì
        Thread producer = new Thread(() -> {
            try {
                for (int i = 1; i <= 10; i++) {
                    String item = "Item-" + i;
                    queue.put(item); // íê°€ ê°€ë“ ì°¨ë©´ ëŒ€ê¸°
                    System.out.println("ìƒì‚°: " + item);
                    Thread.sleep(500);
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        // ì†Œë¹„ì
        Thread consumer = new Thread(() -> {
            try {
                for (int i = 0; i < 10; i++) {
                    String item = queue.take(); // íê°€ ë¹„ë©´ ëŒ€ê¸°
                    System.out.println("ì†Œë¹„: " + item);
                    Thread.sleep(1000);
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        producer.start();
        consumer.start();
    }
}
{% endhighlight %}

#### CyclicBarrier

{% highlight java %}
import java.util.concurrent.*;

public class CyclicBarrierExample {
    public static void main(String[] args) {
        int nThreads = 3;

        CyclicBarrier barrier = new CyclicBarrier(nThreads, () -> {
            System.out.println("ëª¨ë“  ìŠ¤ë ˆë“œê°€ ë„ì°©í–ˆìŠµë‹ˆë‹¤. ë‹¤ìŒ ë‹¨ê³„ë¡œ ì§„í–‰!");
        });

        for (int i = 0; i < nThreads; i++) {
            int id = i;
            new Thread(() -> {
                try {
                    System.out.println("ìŠ¤ë ˆë“œ " + id + " ì‘ì—… ì¤‘...");
                    Thread.sleep((id + 1) * 1000);
                    System.out.println("ìŠ¤ë ˆë“œ " + id + " barrier ë„ì°©");
                    barrier.await(); // ëª¨ë“  ìŠ¤ë ˆë“œê°€ ì—¬ê¸°ì„œ ëŒ€ê¸°
                    System.out.println("ìŠ¤ë ˆë“œ " + id + " ë‹¤ìŒ ë‹¨ê³„ ì‹¤í–‰");
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }).start();
        }
    }
}
{% endhighlight %}


### ëŒë‹¤

ì €ë²ˆì— ë‹¤ë¤˜ê¸°ì— ì´ë²ˆì—ëŠ” ì´ë¡ ì ìœ¼ë¡œ ì¡°ê¸ˆ ë¹ ì‚­í•˜ê²Œ ì‚´í´ë³´ê³  ê°€ì.

#### First-Class Citizen

**ì¡°ê±´**
- ë³€ìˆ˜ì— ë‹´ì„ ìˆ˜ ìˆì–´ì•¼ í•¨
- í•¨ìˆ˜ì˜ ì¸ìë¡œ ì „ë‹¬í•  ìˆ˜ ìˆì–´ì•¼ í•¨
- í•¨ìˆ˜ì˜ ë°˜í™˜ê°’ìœ¼ë¡œ ì „ë‹¬í•  ìˆ˜ ìˆì–´ì•¼ í•¨

ìë°”ëŠ” í•¨ìˆ˜ë¥¼ `First-Class Citizen` ìœ¼ë¡œì¨ ì‚¬ìš© ê°€ëŠ¥í•˜ì§€ë§Œ, FP ì–¸ì–´ëŠ” ì•„ë‹ˆë‹¤.

#### Functional Programming Language

ìë°”ëŠ” í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì´ ì•„ë‹ˆë‹¤. í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì´ ë˜ë ¤ë©´ ë‹¤ìŒì„ ë§Œì¡±ì‹œì¼œì•¼ í•œë‹¤.

1. ìˆœìˆ˜ í•¨ìˆ˜(Pure Function)
    - ë™ì¼ ì…ë ¥ -> ë™ì¼ ì¶œë ¥
    - í•¨ìˆ˜ ë‚´ë¶€ì—ì„œ ì™¸ë¶€ ìƒíƒœë¥¼ ë³€ê²½í•  ìˆ˜ ì—†ìŒ(ì¦‰, **side effect** ì—†ìŒ)
2. ë¶ˆë³€ì„±(Immutability)
    - ë°ì´í„°ëŠ” í•œ ë²ˆ ìƒì„±í•˜ë©´ ë³€ê²½í•˜ì§€ ì•ŠìŒ
    - ìƒíƒœ ë³€ê²½ ëŒ€ì‹  ìƒˆë¡œìš´ ë°ì´í„° ìƒì„±
3. ê³ ì°¨ í•¨ìˆ˜(Higher-order Function)
    - í•¨ìˆ˜ë¥¼ ì¸ìë¡œ ë°›ê±°ë‚˜ í•¨ìˆ˜ë¥¼ ë°˜í™˜ ê°€ëŠ¥
4. í•¨ìˆ˜ ì¡°í•©(Function Composition)
    - ì‘ì€ í•¨ìˆ˜ë¥¼ ì¡°í•©í•´ ë” í° í•¨ìˆ˜ë¥¼ ë§Œë“¦
5. ì„ ì–¸í˜• í”„ë¡œê·¸ë˜ë°(Declarative)
    - ë¬´ì—‡ì„ í•  ì§€ ì¤‘ì‹¬, ì–´ë–»ê²Œ í•  ì§€ëŠ” ìµœì†Œí™”

ìë°”ì—ì„œëŠ” ìˆœìˆ˜ í•¨ìˆ˜ëŠ” ì•„ë‹ˆë©°, ê°ì²´ ìƒíƒœë¥¼ ë³€ê²½í•  ìˆ˜ ìˆê¸°ì— í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì€ ì•„ë‹ˆë‹¤. ë‹¤ë§Œ FP ë¥¼ í‰ë‚´ë‚´ê³  ìˆëŠ” ê²ƒì´ë‹¤.

#### ìµëª… êµ¬í˜„ ê°ì²´

ìë°”ëŠ” í•¨ìˆ˜ë§Œ ìˆœìˆ˜í•˜ê²Œ ì¡´ì¬í•  ìˆ˜ ì—†ì—ˆê¸°ì— FP í‰ë‚´ë¥¼ ë‚´ë ¤ê³  `ìµëª… êµ¬í˜„ ê°ì²´`ë¥¼ ìƒì„±í•œë‹¤
.
{% highlight java %}
// Runnableì„ êµ¬í˜„í•˜ëŠ” ì´ë¦„ ì—†ëŠ” ê°ì²´
Runnable r = new Runnable() {
    public void run() {
        System.out.println("ìµëª… êµ¬í˜„ ê°ì²´ê°€ ì¶œë ¥í•©ë‹ˆë‹¤.");
    }
};
r.run();
{% endhighlight %}

`@FunctionalInterface` ê°€ ë¬´ì—‡ì¸ì§€, `Runnable` ì´ ë¬´ì—‡ì¸ì§€ëŠ” ì´ë¯¸ ì „ì— ë‹¤ë¤˜ìœ¼ë¯€ë¡œ ë„˜ì–´ê°„ë‹¤. ë˜í•œ ìˆ˜ë§ì€ ë¯¸ë¦¬ ì •ì˜ëœ `FunctionalInterface` ë“¤ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.

#### FunctionalInterfaces

- Runnable: ì…ë ¥ X, ë°˜í™˜ X
- Callable: ì…ë ¥ X, ë°˜í™˜ O, ë¹„ë™ê¸°  

- Supplier: ì…ë ¥ X, ë°˜í™˜ O
    - IntSupplier
    - LongSupplier
    - DoubleSupplier

- Consumer: ì…ë ¥ X, ë°˜í™˜ X
    - IntConsumer
    - LongConsumer
    - DoubleConsumer
    - ObjIntConsumer: ì œë„ˆë¦­ ê°ì²´ + int ê°’ì„ ì…ë ¥
    - ObjLongConsumer
    - ObjDoubleConsumer

- Predicate
    - IntPredicate
    - LongPredicate
    - DoublePredicate

- Function<T, R>
    - IntFunction<R>
    - LongFunction<R>
    - DoubleFunction<R>
    - ToIntFunction<T>
    - ToLongFunction<T>
    - ToDoubleFunction<T>

- UnaryOperator
    - IntUnaryOperator
    - LongUnaryOperator
    - DoubleUnaryOperator

---

- BiConsumer
- BiPredicate
- BiFunction
- BinaryOperator
    - IntBinaryOperator
    - LongBinaryOperator
    - DoubleBinaryOperator

êµ³ì´ ì„¤ëª…ì€ ë”°ë¡œ í•˜ì§€ ì•Šìœ¼ë©°, ê·¸ë•Œê·¸ë•Œ ì°¾ì•„ì„œ ì“°ëŠ” ê²ƒìœ¼ë¡œ í•œë‹¤.