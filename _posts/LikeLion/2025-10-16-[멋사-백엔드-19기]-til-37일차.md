---
layout: post
title:  "[멋사 백엔드 19기] TIL 37일차"
date:   2025-10-16 13:55:33 +0900
categories: 멋쟁이사자처럼 멋사 백엔드 TIL Java Spring
---

<!--more-->

## 📂 목차
- [Spring MVC](#spring-mvc)
    - [Controller 설계](#controller-설계)
        - [@RequestMapping](#requestmapping)
        - [@PathVariable](#pathvariable)
        - [@RequestParam](#requestparam)
        - [@RequestBody](#requestbody)
        - [⭐️ RequestHeader](#️-requestheader)
        - [고급 옵션](#고급-옵션)
    - [Model & View](#model--view)
        - [Thymeleaf](#thymeleaf)
        - [Thymeleaf 에러 메시지 처리](#thymeleaf-에러-메시지-처리)
        - [Forwarding 과정](#forwarding-과정)
        - [Redirecting 과정](#redirecting-과정)
        - [Forward vs Redirect 비교 요약](#forward-vs-redirect-비교-요약)

---

## 📚 본문

### Spring MVC

`Model-View-Controller` 패턴을 기반으로 하는 웹 애플리케이션 프레임워크

- Model: 비즈니스 데이터 + 로직
- View: 사용자에게 보여지는 화면 (HTML, JSON 등)
- Controller: 요청을 받고 Model과 View 를 연결

![spring-mvc-pattern.png]({{ site.baseurl }}/img/spring-mvc-pattern.png)

Spring 은 MVC 2.0 버전 패턴으로 위와 같이 적용하고 있다. DispatcherServlet 은 모든 HTTP 요청의 진입점이며, 톰캣과 디스패쳐가 연결되어 있다. 처리 과정을 자세히 살펴보자.

1. 브라우저에서 요청, `DispatcherServlet` 이 받음
2. `HandlerMapping`가 어떤 `Controller` 가 이 요청을 처리할지 찾음
3. `HandlerAdapter`가 알맞은 `Controller` 메서드를 호출함
4. `Controller` 는 메서드 호출 받았을 때, `Model` 데이터를 만들고 `View` 이름을 반환하게 된다.
    - 모델을 어떤 view 에 적용시켜줄지를 알려주어야 하니 view 이름을 반환하는 것이다.
5. `ViewResolver` 가 `View` 객체를 생성한다.
6. `View` 는 생성된 Model 을 읽어들여서 데이터를 적용한다
7. `View` 가 사용자에게 결과를 전달한다.

{% highlight text %}
Browser Request
      ↓
DispatcherServlet
      ↓
HandlerMapping → 어떤 Controller인지 결정
      ↓
HandlerAdapter → Controller 호출
      ↓
Controller → Model 생성 / View 이름 반환
      ↓
ViewResolver → View 객체 생성
      ↓
View → 사용자에게 HTML / JSON 응답
{% endhighlight %}

개발자가 관여할 것은 보라색 뿐이다. 이제 이를 설계해보자.

#### Controller 설계

{% highlight java %}
@RestController
@RequestMapping("/users")
public class UserController {

    @GetMapping("/{id}")
    public UserDto getUser(@PathVariable Long id) {
        return userService.getUserById(id);
    }

    @PostMapping("/")
    public UserDto createUser(@RequestBody UserDto userDto) {
        return userService.createUser(userDto);
    }
}
{% endhighlight %}

하나하나 뜯어본다.

`@Controller` 는 Spring MVC에서 웹 요청을 처리하는 클래스임을 나타내는 애너테이션이다. 즉, 이 클래스 안의 메서드들이 HTTP 요청과 응답을 담당하게 된다.

**역할**
- 클래스 레벨에 붙음 → 이 클래스가 `Controller` 임을 Spring 에 알림
- Spring Bean 으로 등록 → IoC 컨테이너에서 관리

> ⭐️ 중요: **@RestController** = `@Controller` + `@ResponseBody` 의 결합이며 반환값을 **JSON, HTTP Body** 로 바로 전달하고 싶을 때 쓴다.

##### @RequestMapping

`Controller` 에 들어가는 함수들은 전부 제 기능을 하기 위해 `@RequestMapping` 이 주로 붙는다.

{% highlight java %}
@RequestMapping(value = "/users", method = RequestMethod.GET)
public List<User> getAllUsers() { ... }
{% endhighlight %}

이때 위 애너테이션은 다음과도 같다.

{% highlight java %}
@GetMapping("/users")
public List<User> getAllUsers() { ... }
{% endhighlight %}

더 쉽게 제공하는 편이다. 이런게 4개 더 있다.

| 매핑 어노테이션 | 설명           | 예시                       |
|-----------------|----------------|----------------------------|
| `@GetMapping`   | GET 요청 처리  | `@GetMapping("/users")`    |
| `@PostMapping`  | POST 요청 처리 | `@PostMapping("/users")`   |
| `@PutMapping`   | PUT 요청 처리  | `@PutMapping("/users/{id}")` |
| `@DeleteMapping`| DELETE 요청 처리 | `@DeleteMapping("/users/{id}")` |
| `@PatchMapping` | PATCH 요청 처리 | `@PatchMapping("/users/{id}")` |


{% highlight java %}
@RestController
@RequestMapping("/users")
public class UserController {

    @GetMapping("/{id}")
    public String getUser(@PathVariable Long id) {
        return "사용자 조회: " + id;
    }

    @PostMapping("/")
    public String createUser(@RequestBody String userName) {
        return "사용자 생성: " + userName;
    }

    @PutMapping("/put/{id}")
    public String updateUser(@PathVariable Long id, @RequestBody String newName) {
        return "사용자 수정: " + id + " -> " + newName;
    }

    @DeleteMapping("/delete/{id}")
    public String deleteUser(@PathVariable Long id) {
        return "사용자 삭제: " + id;
    }

    @PatchMapping("/patch/{id}")
    public String patchUser(@PathVariable Long id, @RequestBody String newEmail) {
        return "사용자 이메일 수정: " + id + " -> " + newEmail;
    }
}
{% endhighlight %}

위와 같이 사용 가능하다. 여기서 잘 보면 `@RequestMapping` 어노테이션을 클래스 레벨에 두어 내부 메서드 레벨의 `@RequestMapping` 들에 대해서 prefix 를 적용하는 것처럼 된다. 

이제 파라미터에 대한 매핑을 보자.

**파라미터 매핑**
| 어노테이션        | 설명                                  |
|------------------|------------------------------------|
| `@PathVariable`   | **URL 경로의 변수 값**을 매핑          |
| `@RequestParam`   | **쿼리 파라미터 값**을 매핑             |
| `@RequestBody`    | **요청 Body(JSON 등)를 객체**로 매핑   |
| `@RequestHeader`  | **HTTP Header 값** 매핑             |
| `@CookieValue`    | **쿠키 값** 매핑                     |
| `@ModelAttribute` | **폼 데이터를 객체**에 바인딩           |

하나하나 다 중요한 것들이니 자세히 본다.

##### @PathVariable

Url 에 있는 값을 그대로 받을 수도 있다. 이는 사용자 검색을 더 편리하게 할 수 있고, 스크래핑 정보도 제공하기 편리하게 할 수 있다.

{% highlight java %}
@GetMapping("/users/{id}")
public String getUser(@PathVariable Long id) {
    return "사용자 조회: " + id;
}
{% endhighlight %}

##### @RequestParam

url 전체의 query 부분으로 key-value 를 보낼때 이를 받게 할 수도 있다.

{% highlight java %}
// GET /users/search?name=홍길동&age=20
@GetMapping("/search")
public String searchUser(
        @RequestParam String name,
        @RequestParam int age) {
    return "검색 사용자: " + name + ", 나이: " + age;
}

@GetMapping("/search")
public String searchUser(
        @RequestParam(name = "name", required = false, defaultValue = "익명") String name,
        @RequestParam(name = "age", required = false, defaultValue = "0") int age) {
    return "검색 사용자: " + name + ", 나이: " + age;
}

// GET /users/filter?roles=ADMIN&roles=USER&roles=GUEST
@GetMapping("/filter")
public String filterUsers(@RequestParam List<String> roles) {
    return "필터 역할: " + roles;
}
{% endhighlight %}

`PostMapping` 을 통해서 form 으로 `password`, `username` 등도 받을 수 있다.

> 여러 개를 받을 때는 &로 연결하고 key 를 중복해서 선언해주면 된다.

##### @RequestBody

보통 API 만들 용도로 쓰인다 왜냐면 body 자체가 구조화된 데이터 형태로 들어와야 자바 객체로 변환하기 편하며, 클라이언트가 보낸 JSON 등의 데이터를 객체로 직접 받을 때 사용하면 된다.

{% highlight java %}
@PostMapping("/")
public String createUser(@RequestBody UserDto userDto) {
    return "사용자 생성: " + userDto.getName() + ", 나이: " + userDto.getAge();
}
{% endhighlight %}

> `@RequestBody`: HTTP 요청의 Body 부분(JSON, XML, 텍스트 등)을 자바 객체로 바로 변환해주는 역할(보통 JSON 등으로 매핑)

##### ⭐️ RequestHeader

{% highlight java %}
/*
 GET /users/header
 Authorization: Bearer abc123
 User-Agent: Chrome
*/

@GetMapping("/header")
public String getHeader(
        @RequestHeader("Authorization") String authHeader,
        @RequestHeader(value = "User-Agent", required = false) String userAgent) {

    return "인증 헤더: " + authHeader + ", 브라우저: " + userAgent;
}
{% endhighlight %}

보통 인증 토큰이 있는지 없는지 판별할 때 쓸 수 있겠다.

- 토큰 인증
- API 키 검증

##### 고급 옵션

`RequestMapping` 에서 붙일 수 있는 옵션이며, 단순히 요청 뿐 아니라 형식, 파라미터, 헤더에 따라 매핑을 더 세밀히 제어할 수 있도록 한다.

| 옵션      | 설명                                      |
|-----------|------------------------------------------|
| `consumes`| 요청 Content-Type 제한 (`application/json`) |
| `produces`| 응답 Content-Type 지정 (`application/json`) |
| `params`  | 특정 요청 파라미터 존재 여부로 매핑       |
| `headers` | 특정 HTTP 헤더 존재 여부로 매핑           |

**사용 예시**

`consumes` 는 **요청 Content-Type** 을 제한하는데, 쉽게 말해서 JSON 요청만 처리하게 제한하도록 할 수 있고 다른 다양한 것들이 있다.

**consumes**
{% highlight java %}
@PostMapping(value = "/users", consumes = "application/json")
public String createUser(@RequestBody UserDto userDto) {
    return "JSON으로 사용자 생성: " + userDto.getName();
}
{% endhighlight %}

produces 는 **응답의 Content-Type** 을 지정한다. 위랑 다르다. 만약 다음과 같이 입력되었다면 JSON 형태로만 응답하도록 지정하는 것과 같다.

**produces**
{% highlight java %}
@GetMapping(value = "/users/{id}", produces = "application/json")
public UserDto getUser(@PathVariable Long id) {
    return new UserDto(id, "홍길동", 25);
}
{% endhighlight %}

params 는 특정 쿼리 파라미터 조건이 있을 때만 매핑을 하게 된다. 예를 들어 admin 이라는 parameter key 에 value 로 `true` 가 아니라면 해당 함수는 매핑이 안되게 된다. 따라서 두 메서드는 다른 메서드로 동작되고 중복 선언으로 오류가 안뜬다.

**params**
{% highlight java %}
// 예: /users/search?admin=true 일 때만 매핑됨
@GetMapping(value = "/users/search", params = "admin=true")
public String searchAdminUsers() {
    return "관리자 계정 검색";
}

// 예: /users/search?role=user 일 때만 매핑됨
@GetMapping(value = "/users/search", params = "role=user")
public String searchNormalUsers() {
    return "일반 사용자 검색";
}
{% endhighlight %}

headers 는 요청이 오는 HTTP 헤더에 조건이 있을때만 매핑을 하게 된다. 브라우저 별로 사용하는 API 가 달라서 그에 호환되는 처리를 할 수도 있다.

**headers**
{% highlight java %}
@GetMapping(value = "/users/version", headers = "X-API-VERSION=1")
public String getUserV1() {
    return "API Version 1 호출됨";
}

@GetMapping(value = "/users/version", headers = "X-API-VERSION=2")
public String getUserV2() {
    return "API Version 2 호출됨";
}
{% endhighlight %}

이제 Model 과 View 를 보자.

#### Model & View

모델은 단순히 데이터를 담는 통(Bean) 이며, 요청과 응답 사이에서 데이터를 전달하는 핵심 매개체이다. Spring MVC 에서는 다음 3가지 형태로 `Model` 을 다룬다.

- `org.springframework.ui.Model`: 단순 key-value 저장소
- `ModelMap`: Model 과 유사하나 `LinkedHashMap` 기반
- `ModelAndView`: `Model` + `ViewName` 을 한번에 관리

1.	사용자의 요청이 들어오면 `DispatcherServlet` 이 해당 `Controller` 메서드를 호출한다.
2.	`Controller` 메서드는 비즈니스 로직을 수행하고, 그 결과를 `Model` 에 담는다.
3.	`DispatcherServlet` 은 `Model` 에 담긴 데이터를 `View` 에 전달한다.
4.	`View(예: Thymeleaf, JSP)` 는 `${key}` 또는 `*{key}` 문법으로 데이터를 참조한다.

**String 예시**
{% highlight java %}
@Controller
@RequestMapping("/example")
public class ExampleController {

    @GetMapping("/model")
    public String modelExample(Model model) {
        // Model에 데이터 담기
        model.addAttribute("message", "Hello, Model!");
        model.addAttribute("number", 42);

        // view 이름 반환 (hello.html)
        return "hello";
    }
}
{% endhighlight %}

**ModelMap 예시**
{% highlight java %}
@Controller
@RequestMapping("/example")
public class ExampleController {

    @GetMapping("/modelmap")
    public String modelMapExample(ModelMap modelMap) {
        // ModelMap에 데이터 담기
        modelMap.put("message", "Hello, ModelMap!");
        modelMap.put("number", 123);

        // view 이름 반환 (hello.html)
        return "hello";
    }
}
{% endhighlight %}

**ModelAndView 예시**
{% highlight java %}
@Controller
@RequestMapping("/example")
public class ExampleController {

    @GetMapping("/modelandview")
    public ModelAndView modelAndViewExample() {
        ModelAndView mav = new ModelAndView();

        // view 이름 지정
        mav.setViewName("hello");

        // 데이터 추가
        mav.addObject("message", "Hello, ModelAndView!");
        mav.addObject("number", 999);

        return mav;
    }
}
{% endhighlight %}

> redirect 방식은 `ModelAndView("redirect:(path)")` 처럼 `ModelAndView` 에서도 사용 가능하다.

---

##### Thymeleaf

Java spring 에서 자주 사용하는 HTML 렌터링 서버사이드 템플릿 엔진이다.

기본 구조는 다음과 같고, `resorces/templates/` 폴더에 html 을 저장하게 된다.

{% highlight html %}
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <title>Thymeleaf 예제</title>
</head>
<body>
    <h1 th:text="${message}">Hello</h1>
</body>
</html>
{% endhighlight %}

꼭 html 에 태그로 `xmlns:th="http://www.thymeleaf.org"` 를 넣어주어야 한다. th 는 자유다. Thymeleaf 는 `View` 계층에 포함되는 애이며, 여기에 들어가는 데이터들이 전부 `Model` 에서 가져오게 되겠다.

**텍스트 표현**
- `th:text="${var}`: 변수 값 출력
- `th:utext="${var}`: HTML 태그를 포함한 문자열 출력 (escape 안함)
- `th:inline="text"`: 텍스트 인라인 표현 가능 ${var} 사용

**속성 바인딩**
- `th:href="@{/home}"`: 링크 URL 바인딩
- `th:src="@{/images/logo.png}"`: 이미지 src 바인딩
- `th:class="@{condition ? 'active' : ''}` 조건부 클래스 적용

**조건문**
- `th:if`: 조건이 true 면 해당 태그 렌더링
- `th:unless`: 조건이 false 면 해당 태그 렌더링

> `<p th:text="${user.age >= 18 ? '성인' : '미성년'}"></p>` 처럼 쓸 수도 있다.

**반복문**
- `th:each="(for 내부 변수) : ${var}"`: 컬렉션 반복

**URL 링크 처리**
- `th:href=@{경로}`: 컨텍스트 경로 자동 적용이 된다. `${}` 와 같이 경로 안에 파라미터 포함 가능

> 실습 코드에서는 다음과 같이 되어 있는데, `<a th:href="@{/users/{id}(id=${user.id})}">View Profile</a>` {} 는 단순 변수이며 $ 나 * 등이 없다. 이때는 () 를 통해 id 에 직접 넣을 수 있도록 할 수 있다.

**변수 표현식**
- `${var}`: 일반 변수
- `*{field}`: form 객체의 field (th:object 안에서)

{% highlight java %}
<!-- Form 처리 -->
<form th:action="@{/users}" th:object="${userForm}" method="post">
    <input type="text" th:field="*{username}" />
    <input type="email" th:field="*{email}" />
    <button type="submit">Submit</button>
</form>
{% endhighlight %}

- `#{msg.key}`: 메시지 국제화(i18n)
    - `messages.properties` 에 `greeting=안녕하세요, {0}님`의 key-value 가 있다고 쳐보자.  
    Thymeleaf 를 쓰는 HTML 에서는 다음과 같이 쓸 수 있다.  
    `<p th:text="#{greeting(${user.name})}">기본 인사</p>`

- `~{template}`: fragment/template 참조 아래를 통해 더 자세히 살펴보자.

**th:replace**
{% highlight java %}
<!-- header.html -->
<!-- fragment 등록 -->
<div th:fragment="header">
    <h1>사이트 헤더</h1>
</div>

<!-- main.html -->
<!-- fragment 사용 -->
<div th:replace="header :: header"></div>
{% endhighlight %}

템플릿의 위치는 `application.yml` 이나 프로퍼티에 `spring.thymeleaf.prefix=classpath:/templates/`, `spring.thymeleaf.suffix=.html` 처럼 기본적으로 넣어져있고, 이를 따로 지정하여 넣어줄 수 있다. 이때 그 하위의 html 에 대한 Thymeleaf 문법으로 작성된 문서들이 다 불러와지고, fragment 도 그때 등록된다. 추가로 더 알아볼 것은 `ClassLoaderTemplateResolver` 을 통해서도 이런 template 위치를 코드 내에서도 지정 가능하다(나중에 알아보자).

위 코드르 보면 :: 를 통해 자바의 정적 참조 문법과 비슷하며, `th:replace` 를 통해 `(파일 경로) :: (fragment 명)` 을 써서 지정 가능하다.

**실습**
{% highlight java %}
<!-- fragments/header.html -->
<header th:fragment="header">
    <nav class="navbar">
        <a th:href="@{/}">Home</a>
        <a th:href="@{/about}">About</a>
        <a th:href="@{/contact}">Contact</a>
    </nav>
</header>

<!-- fragments/footer.html -->
<footer th:fragment="footer">
    <p>&copy; 2024 My Application</p>
</footer>

<!-- main.html -->
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <title>My App</title>
</head>
<body>
    <div th:replace="~{fragments/header :: header}"></div>

    <main>
        <h1>Main Content</h1>
        <!-- Page specific content -->
    </main>

    <div th:replace="~{fragments/footer :: footer}"></div>
</body>
</html>
{% endhighlight %}

> fragment 의 단점은 경로 지정을 정확히 해주어야만 한다.

**폼 처리**
- `th:action`: form 제출 URL
- `th:method`: form method
- `th:field`: input, select, textarea value 바인딩

**기타 유용 속성**
- th:value
- th:checked
- th:selected
- th:disabled
- th:style
- th:onclick

> 가장 중요한 것은 th:(HTML 의 속성 명) 의 형태를 띠며, 값 내부에 java 코드를 일부 집어넣을 수 있다는 것이다. 굳이 외우지 말자.

##### Thymeleaf 에러 메시지 처리

프론트에서 에러 처리는 보통 입력쪽에 에러 메시지를 보내야하는 경우가 있다. 따라서 View 쪽에는 그런 피드백 책임이 있기에 이를 처리해줘야 한다.

{% highlight java %}
<form method="post">
    <div class="form-group">
        <label for="username">사용자 이름</label>
        <input type="text" id="username" th:field="*{username}" class="form-control" />
        <p class="error" th:if="${#fields.hasErrors('username')}" th:errors="*{username}">이름을 입력해주세요.</p>
    </div>
    <div class="form-group">
        <label for="email">이메일</label>
        <input type="email" id="email" th:field="*{email}" class="form-control" />
        <p class="error" th:if="${#fields.hasErrors('email')}" th:errors="*{email}">유효한 이메일을 입력해주세요.</p>
    </div>
    <button type="submit" class="btn btn-primary">제출</button>
</form>
{% endhighlight %}

여기서 보면 `th:object` 가 없는데도 불구하고 `*{}` 를 사용하는 것을 볼 수 있는데, thymeleaf 는 다음 경우에 `th:object` 가 없더라도 `*{}` 를 사용할 수 있다.

1. `@ModelAttribute` 로 넘겨 주는 객체가 딱 하나일 경우
2. 필드로 `@ModelAttribute` 를 사용해 넘겨줬을 경우

이다. 이때 `Post` 부분을 본다.

{% highlight java %}
@PostMapping("/register")
public String registerUser(@Valid @Mo₩delAttribute UserDto user,
                            BindingResult result,
                            RedirectAttributes redirectAttrs) {
    if (result.hasErrors()) {
        return "user/register";  // 폼 재표시
    }
{% endhighlight %}

Spring에서 `@ModelAttribute` 의 value 속성은 선택 사항이며, 이를 지정하지 않으면 기본적으로 매개변수의 이름이 모델 속성의 이름으로 사용한다.

따라서 `UserDto` 에 각각 `username`, `email` 이 들어가게 되고 `@Valid` 를 통해 도메인의 필드에 붙어있는 `jakarta.validation.constraints` 패키지의 어노테이션 검증 로직을 수행하게 된다. 만약 DTO 객체 없이 그냥 받고 싶다면 2번의 방식으로 `@ModelAttribute` 를 쓰면 된다.

{% highlight java %}
if (result.hasErrors()) {
    return "user/register";  // 폼 재표시
}

User savedUser = userService.register(user);
redirectAttrs.addFlashAttribute("message",
    "Registration successful!");

return "redirect:/users/" + savedUser.getId();
{% endhighlight %}

위는 `POST` 매핑의 내부 처리이다. 요청 받을 때 `Post` 로 `BindingResult` 에 결과를 받게 된다. 반드시 `@Valid` 나 `@Validated` 애너테이션과 항상 짝으로 사용된다. `Spring` 이 폼 데이터를 객체에 바인딩 하고, 그 과정에서 생긴 에러를 담는 객체로 보면 된다.

**BindingResult**
{% highlight java %}
@PostMapping("/register")
public String registerUser(
        @Valid @ModelAttribute UserDto user,
        BindingResult result) {
    
    if (result.hasErrors()) {
        return "user/register";
    }

    return "redirect:/users/success";
}
{% endhighlight %}

따라서 `hasErrors()` 를 토대로 입력 값에 대해 `Validation` 를 수행했을때 에러가 있었는지를 검사하고, 검사가 끝나면 로직 수행으로 넘어가게 된다.

**RedirectAttributes**

이제 리다이렉트 시점에서 데이터 전달을 도와주는 스프링 인터페이스가 바로 `RedirectAttributes` 이다. 내부적으로 FlashAttribute(일시적 세션) 을 사용해서 한 번만 전달되는 데이터를 저장하여 전달해준다.

{% highlight java %}
@PostMapping("/register")
public String registerUser(
        @Valid @ModelAttribute UserDto user,
        BindingResult result,
        RedirectAttributes redirectAttrs) {

    if (result.hasErrors()) {
        return "user/register"; // forward — 모델 데이터 그대로 유지
    }

    userService.register(user);

    // redirect 시 데이터 전달
    redirectAttrs.addFlashAttribute("message", "회원가입이 완료되었습니다!");
    redirectAttrs.addAttribute("userId", user.getId());

    return "redirect:/users/{userId}";
}
{% endhighlight %}

따라서
- `Model` 은 forward 시 데이터 유지
- `RedirectAttributes` 는 redirect 시 데이터 유지
로 정리할 수 있다.

주요 메서드들은 다음과 같다:
- `addAttribute(String key, Object value)`: 쿼리 파라미터로 추가
- `addFlashAttribute(String key, Object value)`: 세션에 임시 저장 후 redirect 이후 1회성으로 꺼냄

아래는 이를 이해 후 사용하는 예시다.

**addAttribute()**

{% highlight java %}
redirectAttrs.addAttribute("id", user.getId());
redirectAttrs.addAttribute("status", "success");
return "redirect:/users/detail";
{% endhighlight %}

리다이렉트 후 최종 URL 은 다음과 같게 된다.

> `/users/detail?id=10&status=success`

**addFlashAttribute()**

{% highlight java %}
redirectAttrs.addFlashAttribute("message", "회원가입 완료!");
return "redirect:/users/welcome";
{% endhighlight %}

리다이렉트 후:
- URL 에는 아무것도 안 붙고
- 내부적으로 세션에 잠시 저장이 된다
    - 다음 요청에서 꺼내거나 요청 끝났을 시 삭제가 됨
    - 즉, 일시적 세션으로, 리다이렉트 직후 한 번만 유지되고, 새로고침하면 사라짐

{% highlight java %}
@GetMapping("/users/welcome")
public String welcomePage(Model model) {
    model.getAttribute("message"); // "회원가입 완료!"
    return "welcome";
}
{% endhighlight %}

> Spring 이 내부적으로 세션을 직접 건드리지 않아도 `FlashMap` 을 사용하여 리다이렉트 후 URL 노출 방지로 사용하게 된다.

##### Forwarding 과정

이제 `Forwarding` 이 어떻게 동작하는지 완벽히 이해가 가능하다.

1. HTTP `POST` 요청을 통해 WAS 를 거쳐 `HttpServletRequest` 와 `HttpServletResponse` 를 생성하게 된다.
    - `HttpServletRequest` 와 `HttpServletResponse` 객체는 요청-응답 생명주기를 대표하는 객체

2. `DispatcherServlet` 가 이를 받고 받은 `HttpRequest` 에서의 path 를 `HandlerMapping` 에 주게 된다.

3. 받은 path 에 알맞은 mapping 함수를 `Controller` 에서 골라지게 된다.
    - 정확히는 `HandlerMapping` 목록을 순회하며, 이 URL 요청을 처리할 수 있는 `Controller` 의 메서드를 탐색한다.
    - 찾은 결과를 `HandlerExecutionChain` 객체로 래핑 후 반환한다.
    - 여기에 실제 `Controller` 메서드와 `Interceptor` 체인이 포함되게 된다.

4. `DispatcherServlet` 은 `HandlerAdapter` 를 통해 받았던 데이터(`header`, `body` 등등)를 `Controller` 에 넘겨 주게 된다.
    - `Controller` 마다 호출 방식이 다르기 때문에 `DispatcherServlet` 은 `HandlerAdapter` 를 사용해 호출 과정을 추상화한다.
    - Spring 은 기본적으로 `RequestMappingHandlerAdapter` 를 사용하고, `ArgumentResolver` 와 `ReturnValueHandler` 체계를 통하여 매개변수를 분석(`@RequestParam`, `@ModelAttribute`, `@RequestBody` 등)하고, 반환값을 해석 하게 된다(`String`, `ModelAndView`, `ResponseBody` 등)

5. 이제 `Controller` 는 내부적으로 비즈니스 로직을 실행시켜 알맞은 결과값을 반환 후

6. `Model` 을 통해 넘겨줄 데이터들을 정해준 후에 뷰 이름을 `HandlerAdapter` 에게 반환하게 된다.
    - 여기서 `Controller` 가 리턴한 값을 받아 `ModelAndView` 객체로 통합하게 된다.
    - 만약 반환 타입이 `String` 이면 `viewName` 으로 해석하고,
    - 별도로 `Model` 에 저장된 데이터를 함께 담는다.
    - 이때 4번 단계에서 `ModelAndView`, `ResponseBody` 등으로 리턴하면 수행 단계가 조금 달라지긴 한다. 그 자체를 그대로 사용하게 된다.

> `ModelAndView` 로 이미 `Controller` 에서 `HandlerAdapter` 에게 반환되었다면 6번 과정은 생략하고 다음 단계로 이동한다.

7. 그러고 `DispatcherServlet` 이 `HandlerAdapter` 로 부터 받은 `viewName` 을 가지고, `ViewResolver` 에게 어떤 view 를 쓸 지를 정하게 되고,
    - `DispatcherServlet` 은 `viewName` 을 `ViewResolver` 에게 넘긴다(`ModelAndView` 를 받았다면 이 과정은 없다).
    - `ViewResolver` 는 논리 뷰 이름(logical view name) 을 물리적 리소스 경로로 변환하여 `View` 객체(`ThymeleafView`, `JstlView` 등)으로 변환한다 (`ThymeleafViewResolver`, `InternalResourceViewResolver` 등이 `ViewResolver` 의 대표적 구현체이다)
    - 최종적으로 `View` 가 생성된다.

8. 그 다음 `DispatcherServlet` 은 받았던 `HttpServletResponse` 와 함께 View 로 `forwarding` 을 해주고,
    - `DispatcherServlet` 은 선택된 `View` 객체의 `render()` 메서드를 호출하고, 이때 `HttpServletRequest`, `HttpServletResponse` 이 전달된다.

9. `View` 에서는 `ViewResolver` 를 통해 알맞은 `View` 가 생성되고, `View` 는 `Model` 을 참조하여서 결과들을 가져오고 완전한 문서를 만들게 된다
    - `View` 는 `Model` 의 데이터를 참조하고, 렌더링 결과는 `HttpServletResponse` 의 body 로 직접 작성되게 된다.
    - 렌더링이 끝나면 `DispatcherServlet` 이 `response.flushBuffer()` 후 요청-응답 객체는 소멸된다.

##### Redirecting 과정

이제 `Redirecting` 이 어떻게 동작하는지 완벽히 이해가 가능하다.

**Controller 의 return 값이 `"redirect:"` 접두어를 포함한 String 일 때**

1. 사용자가 `POST` 요청을 보낸다. WAS(Tomcat 등)가 이를 받아 `HttpServletRequest`, `HttpServletResponse` 객체를 생성하고 `DispatcherServlet` 에게 요청을 전달한다.

2. `DispatcherServlet` 은 요청의 URI 정보를 확인하여 `HandlerMapping` 에게 어떤 `Controller` 가 처리해야 하는지 조회를 맡긴다.  
   - `HandlerMapping` 은 요청 정보를 기반으로 적절한 `@RequestMapping` 메서드를 찾아 `HandlerExecutionChain` 으로 감싸 반환한다.  
   - 이 객체에는 **Controller 메서드**와 **Interceptor 체인**이 포함된다.

3. `DispatcherServlet` 은 `HandlerAdapter` 를 통해 해당 `Controller` 메서드를 실행한다.  
   - 이때 `HandlerAdapter` 는 `ArgumentResolver`, `ReturnValueHandler` 를 통해 요청 데이터를 파라미터에 바인딩하고, 반환 타입(`String`, `ModelAndView`, `ResponseBody`) 을 분석한다.

4. `Controller` 가 비즈니스 로직을 처리한 후, `return "redirect:/users/welcome";` 처럼 `"redirect:"` 로 시작하는 문자열을 반환한다.  
   - 이 접두어는 Spring MVC 내부에서 **RedirectView** 로 자동 변환되도록 트리거한다.

5. ⭐️ `DispatcherServlet` 은 반환된 뷰 이름을 확인하고, `"redirect:"` 접두어가 포함되어 있음을 감지하면 **`RedirectView`** 를 생성한다.  
   - ⭐️ 이때는 **ViewResolver** 를 거치지 않는다.
   - ⭐️ 대신 `RedirectView` 의 `render()` 가 호출되어 `HttpServletResponse` 에 `302 Found` 상태 코드와 `Location` 헤더를 설정한다.

6. 응답이 클라이언트(브라우저)로 전송된다.  
   - 응답 헤더 예시:
     ```
     HTTP/1.1 302 Found
     Location: /users/welcome
     ```
   - 브라우저는 이를 보고 `/users/welcome` 으로 **새로운 GET 요청**을 자동으로 보낸다.

7. 새로운 GET 요청이 발생하면 WAS 는 다시 `HttpServletRequest`, `HttpServletResponse` 를 새로 생성하고, 다시 1~4번의 **Forwarding 과정**과 동일한 `DispatcherServlet` 처리 흐름을 거친다.

8. 이때, 이전 요청의 `Model` 데이터는 유지되지 않는다.
   - 대신 `RedirectAttributes.addFlashAttribute()` 로 추가된 데이터는 **일시적 세션(FlashMap)** 에 저장되어 새 요청 시점에 한 번만 사용된다.
   - 이후 요청이 완료되면 `FlashMap` 데이터는 자동 소멸된다.

9. 새로운 `Controller` 메서드(`/users/welcome`) 가 호출되고, 뷰 렌더링이 완료되면 최종 HTML 응답이 브라우저에 전달된다.

> 즉, Redirect 는 **"요청이 두 번 일어난다"**.  
> 첫 번째 요청은 서버의 302 응답으로 끝나고,  
> 두 번째 요청이 실제 결과 페이지를 렌더링한다.  
> 따라서 Forward 와 달리 **URL 이 바뀌며, Model 데이터는 유지되지 않는다.**

##### Forward vs Redirect 비교 요약

| 구분 | Forward | Redirect |
|------|----------|-----------|
| 요청 횟수 | 1회 | 2회 (POST → GET) |
| URL 변경 | ❌ 그대로 유지 | ✅ 변경됨 |
| 데이터 전달 | `Model` 로 전달 | `FlashAttribute` 로 1회 전달 |
| 처리 방식 | 서버 내부 이동 | 클라이언트 재요청 |
| 주 용도 | 단순 뷰 렌더링 | `PRG(Post-Redirect-Get)` 패턴, URL 노출 변경 등 |

> `Forward` 는 "서버 내부 이동"  
> `Redirect` 는 "클라이언트 재요청"  
> — 이 한 줄만 정확히 기억하면, Spring MVC 흐름은 완전히 잡은 것이다.

