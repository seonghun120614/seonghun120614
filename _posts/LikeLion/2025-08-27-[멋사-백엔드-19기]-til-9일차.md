---
layout: post
title:  "[멋사 백엔드 19기] TIL 9일차"
date:   2025-08-27 10:56:28 +0900
categories: 멋쟁이사자처럼 멋사 백엔드 TIL Java
---

<!--more-->

## 📂 목차
- [Enum](#enum)
- [자주 사용하는 클래스](#)

---

## 📚 본문

### Enum

`enum` 으로 선언되어 있지만 사실상 class 이다.

#### 배경

```java
public class Direction {
    public static final int NORTH = 0;
    public static final int SOUTH = 1;
    public static final int EAST = 2;
    public static final int WEST = 3;
}
```

자바 1.5 이전에 상수를 보통 static final 로 정의했지만, 이에 대한 문제는
- 타입 안전성 보장 X
- 디버깅 시 상수 값만 보일 수 있음
- 유지보수가 어려움

이러한 문제점 등으로 타입 안전성과 가독성을 해결하기 위해 enum 이 탄생했다.

#### enum 선언

```java
public enum Direction {
    NORTH, SOUTH, EAST, WEST
}
```

이는 컴파일러 차원에서 잘못된 값은 넣지 못하기 때문에 사전에 타입 안전성을 가져갈 수 있다.

#### java.lang.Enum

자바 enum 은 위 클래스를 상속하는 클래스이며, 사실상 위 Direction 의 코드는 컴파일 시 다음과 같다.

```java
public final class Direction extends Enum<Direction> {
    public static final Direction NORTH = new Direction("NORTH", 0);
    public static final Direction SOUTH = new Direction("SOUTH", 1);
    public static final Direction EAST  = new Direction("EAST", 2);
    public static final Direction WEST  = new Direction("WEST", 3);

    private Direction(String name, int ordinal) {
        super(name, ordinal);
    }

    public static Direction[] values() { ... } // 모든 enum 반환
    public static Direction valueOf(String name) { ... } // 이름으로 검색
}
```

#### 필드와 생성자

실제로 클래스이기 때문에 필드와 생성자 또한 정의 할 수 있다.

```java
public enum Season {
    SPRING("꽃이 피는 계절"),
    SUMMER("더운 계절"),
    FALL("단풍이 드는 계절"),
    WINTER("눈이 오는 계절");

    private final String description;

    Season(String description) { // private 생성자
        this.description = description;
    }

    public String getDescription() {
        return description;
    }
}
```

또한 아래와 같이 abstract 메서드로 오버라이딩도 가능하다. 즉, 각 상수가 서로 다른 동작을 가질 수 있는 다형성까지 가져갈 수 있다.

```java
public enum Operation {
    PLUS {
        public int apply(int x, int y) { return x + y; }
    },
    MINUS {
        public int apply(int x, int y) { return x - y; }
    };

    public abstract int apply(int x, int y);
}
```

상속이 된다면 interface 도 집어넣을 수 있게 된다.

```java
public interface Printable {
    void print();
}

public enum Color implements Printable {
    RED, GREEN, BLUE;

    @Override
    public void print() {
        System.out.println("Color: " + this.name());
    }
}
```

> Enum 은 보통 switch 가독성을 위해 쓰이게 된다.

#### 주의점

- `ordinal()` 사용 지양: 상수의 순서가 바뀌면 로직이 깨지며 대신 name 과 같은 별도의 필드를 사용한다.
- 직렬화 시 주의해야 한다. enum 은 싱글턴 보장이라 역직렬화해도 같은 인스턴스가 유지된다.
- 상속 불가 enum 은 상속이 안된다(public final class 이기 때문).

> ordinal() 은 enum 내부에 구현되어 있는 것이고 로직에 직접 사용되지 않기 때문에 보지도 않을 것이다.

### 자주 사용하는 클래스

#### StringBuffer 와 String Builder

**StringBuffer**
- 동기화를 지원함
- 성능이 느림
- 스레드 세이프
- 멀티 스레드 환경에서 사용하면 좋다.

`Serializable` 이라는 인터페이스를 구현하지만 이는 메타데이터 용도로만 쓰이고

**StringBuilder**
- 비동기
- 성능이 빠름
- 쓰레드 세이프하지 않음
- 단일 스레드 환경에서 사용하면 좋다.