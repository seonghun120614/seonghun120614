---
layout: post
title:  8. Spring Boot Auto Configuration and Actuator
date:   2025-08-08 15:45:34 +0900
categories: Java Spring
---

<!--more-->

## 🪛 한계점


## 📂 목차
- []()
- []()

---

## 📚 본문

스프링 부트는 개발에 필요한 컴포넌트를 자동으로 설정해주는 기능이 있는데 이를 Auto Configuration 이라고 한다. 만약 `spring-boot-starter-web` 을 추가한다면, Spring Boot는 웹 어플리케이션 구동에 필요한 웹 서버가 필요할 것이라고 추론하고 아파치 톰캣(기본값임) 웹서버를 기본 웹 서버로 추가해준다. 톰캣 말고도 Jetty를 사용해도 무관하다. 그때는 dependencies를 Jetty를 사용하도록 수정해주면 된다(`spring-boot-starter-jetty`).

하지만 이게 모든 상황에 편리할 수는 없다. 예를 들어 개발팀1 에서 스프링 프레임워크를 사용해서 여러가지 프로젝트를 진행하고 있는데 spring bean 설정이 모든 팀(개발팀2, 개발팀3)에서 복사해서 사용하고 있으면 중복되는 bean 들을 여러 개 생성하는 것은 매우 비효율적일 것이다. 따라서 **공통 구성 설정** 이 필요할 수 있다.

### Common Context Configuration 설정

`@Configuration` 애너테이션을 통해 이 클래스를 스프링 설정으로 담당하는데, 따로 `CommonApplicationContextConfiguration` 이라는 클래스를 만들어서 이 클래스를 포함하는 프로젝트는 메이븐이나 그레이들 컴포넌트로 배포되고 개발 팀에서는 이 프로젝트를 의존 관로 추가해서 설정 클래스를 사용할 수 있을 터이다(중복된 설정 작업 막기).

{% highlight java %}
@Configuration
public class CommonApplicationContextConfiguration {
    @Bean
    public RelationalDataSourceConfiguration dataSourceConfiguration() {
        return new RelationalDataSourceConfiguration
    }
}
{% endhighlight %}

위는 `RelationalDataSourceConfiguration` 의 다른 모든 팀에서 자주 사용할 법한 그런 클래스들을 빈으로 정의하고 있다. 이렇게 정의해두면 다른 팀에서 이를 사용할 때 설정 파일 내용을 수정하는 수고를 덜 수 있다. 이제 이를 함의하는 다른 Application Context(IoC 컨테이너)를 정의하자. 영업팀은 다음을 사용할 수 있을 것이다.

{% highlight java %}
package com.example.study.config;

import org.springframework.context.annotation.*;

@Configuration
@Import(CommonApplicationContextConfiguration.class)
public class CommonBusinessApplicationContextConfiguration {
    // 영업팀의 Common ApplicationContext
}
{% endhighlight %}

### Conditional 을 통한 특정 Bean 제외하고 Import 하기

스프링 프레임워크는 스프링이 관리하는 컴포넌트의 생성을 제어할 수 있도록 `@Bean`, `@Component`, `@Configuration` 애너테이션과 함께 사용할 수 있는 `@Conditional` 애너테이션을 제공한다.

{% highlight java %}
@Configuration
public class CommonApplicationContextConfiguration {
    @Bean
    @Conditional(RelationalDatabaseCondition.class)
    public RelationalDataSourceConfiguration dataSourceConfiguration() {
        return new RelationalDataSourceConfiguration();
    }
}
{% endhighlight %}

Conditional 을 붙여 조건을 걸 수 있고, 조건에 해당하는 Context들에만 해당 Bean이 들어가게 된다. `RelationalDatabaseCondition` 은 `Condition` 인터페이스를 구현하는 클래스이고, `boolean matches()` 을 구현하도록 한다.

{% highlight java %}
package com.example.study.config;

import org.springframework.context.annotation.*;
import org.springframework.core.type.*;

public class RelationalDatabaseCondition implements Condition {

    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        return isMySqlDatabase();
    }

    private boolean isMySqlDatabase() {
        try {
            Class.forName("com.mysql.jdbc.Driver");
            return true;
        } catch (ClassNotFoundException e) {
            return false;
        }
    }
}
{% endhighlight %}

위에서는 `reflect` API를 활용하여 JVM에 jdbc.Driver 가 올라가 있는지를 살피는 로직이다. 안에 얼마든지 복잡한 로직을 사용하여 Application Context 를 유연하게 활용할 수 있다.

### @Condition 동작 방식

애너테이션만으로 조건부 빈 생성이 가능하지만, 스프링에서는 다양한 조건을 쉽게 사용할 수 있게 해주는 다양한 고수준의 애너테이션을 따로 제공한다. 몇 개만 외우자.

| 애너테이션 | 예시 | 예시 설명 |
|:===:|:===:|:===:|
| @ConditionalOnBean | @Conditional(DataSource.class) | 설정에서 DataSource 빈이 명시돼 있으면 true 반환 |
| @ConditionalOnClass | @ConditionalOnClass(DataSource.class) | 클래스 패스에 DataSource 클래스가 있으면 true 반환 |
| @ConditionalOnProperty | @ConditionalOnClass("some.property") | some.property 가 정의되어 있으면 true 반환 |
| @ConditionalOnCloud | @ConditionalOnCloud(CloudPlatform.KUBERNETES) | CloudPlatform 이 KUBERNETES로 설정돼있으면 true 반환 |
| @ConditionalOnJava | @ConditionalOnJava(JavaVersion.EIGHT) | Java 버전이 8을 지원하면 반환 |
| @ConditionalOnMissingBean | @ConditionalOnMissingBean(DataSource.class) | DataSource 빈이 설정돼 있지 않으면 true 반환 |
| @ConditionalOnMissingClass | @ConditionalOnMissingClass(DataSource.class) | 클래스 패스에 DataSource 빈이 설정돼 있지 않으면 true 반환 |
| @ConditionalOnNotWebApplication | @ConditionalOnNotWebApplication | 웹 어플이 아니면 true 반환 |
| @ConditionalOnSingleCandidate | @ConditionalOnSingleCandidate(DataSource.class) | DataSource 빈이 하나만 정의돼 있으면 true |

### spring.factories

모든 스프링 프로젝트는 spring-boot-autoconfigure 의 의존관계를 포함하고 있다.

![spring-boot-autoconfigure-jar.png](/assets/img/spring-boot-autoconfigure-jar.png)

이 모듈의 JAR 파일의 META-INF 폴더를 파헤치면

{% highlight txt %}
...

# Auto Configuration Import Listeners
org.springframework.boot.autoconfigure.AutoConfigurationImportListener=\
org.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListener

# Auto Configuration Import Filters
org.springframework.boot.autoconfigure.AutoConfigurationImportFilter=\
org.springframework.boot.autoconfigure.condition.OnBeanCondition,\
org.springframework.boot.autoconfigure.condition.OnClassCondition,\
org.springframework.boot.autoconfigure.condition.OnWebApplicationCondition

...
{% endhighlight %}

위와 같은 properties 가 보이며, Auto Configuration 으로 표시된 부분이 스프링 부트 컴포넌트, 서드 파티 라이브러리 등에 대한 자동 구성 정보가 포함돼 있는 곳이다.

위 Condition 들 순서대로 
1. OnBeanCondition
2. OnClassCondition
3. OnWebApplicationCondition

을 통해 걸러지고 남은 Configuration 들만 `@Configuration` 으로 처리된다.

### Auto Configuration 구성하기

모든 팀들이 공통적으로 사용할 데이터 소스의 자동 설정을 건드려보자.

- dev 환경: mysql, postgresql 사용
- test 환경: H2 사용
- prod 환경: mysql, postgresql 사용

각 환경마다 저렇게 구성하고 싶다고 해보자. properties 를 우선 설정하여 profiles 만 바꾸는 것만으로 `DataSource` 를 자동 변경을 시키도록 하고 싶을 것이다.

test 환경에서는 `spring.active.profiles` 라는 spring에서 지정된 key 에 의해 `application-{spring.active.profiles}.properties` 의 설정 정보를 읽어 들여 실행하게 된다. 이 값을 통해 Condition 을 짜보자.

{% highlight java %}
public class InMemoryDatabaseCondition implements Condition {
    @Override
    public boolean matches(
            ConditionContext context,
            AnnotatedTypeMetadata metadata) {
        Environment env = context.getEnvironment();
        String activeProfile = env.getProperty("spring.profiles.active");
        return // activeProfile == null ||
                activeProfile.equals("test");
    }
}
{% endhighlight %}

InMemory는 내장 RAM 을 통한 db source 를 구성하는 방식이다. context 를 통해서 들고 와도 되고, javax.lang.reflect를 통해 JVM에 올라간 driver class 의 name 을 검사해도 무방하다. 왠만해서는 Spring을 쓰자.

{% highlight java %}
@Configuration
@Conditional(InMemoryDatabaseCondition.class)
public class InMemoryDataSourceConfiguration {

    private final DataSourceProperties dsp;

    @Autowired
    public InMemoryDataSourceConfiguration(DataSourceProperties dataSourceProperties) {
        this.dsp = dataSourceProperties;
    }

    @Bean
    public DataSource dataSource() {
        HikariDataSource ds = new HikariDataSource();
        ds.setJdbcUrl(dsp.getUrl());
        ds.setUsername(dsp.getUsername());
        ds.setPassword(dsp.getPassword());
        return ds;
    }
}
{% endhighlight %}

공통 DB Configuration 을 선언하여 inner class 를 통해 다수의 class 를 들고 오게 할 수 있다. 이를 통해 각 DB에 대한 property 를 다르게 설정하여 들고 올 수 있고, NoSQL 을 사용하는 DB에 대해서도 추가적으로 확장할 수 있을 터이다. 여기서 DataSource 는 `HikariDataSource` 를 사용한다(경랑, 성능 좋음)(Spring 2.x 에서는 커넥션 풀이 Hikari 를 사용하기 때문에 따로 설정해줄 필요가 없다).

### Auto Configure 되는 DataSource 클래스 우회하기

Spring Boot는 DataSource 를 `spring.datasource` prefix 의 key-value 프로퍼티를 읽어들여서 DataSource를 구성하게 된다. 이때, 자신의 project 에 `DataSource` 타입의 Bean 이 존재하게 되면 내부의`@ConditionalOnMissingBean(DataSource.class)` 의 조건 때문에 원래의 Auto Configure 에 의한 DataSource 의존성 주입을 우회하게 된다. 이를 사용하면 다음을 구성할 수 있다.

{% highlight java %}
@Configuration
@Conditional(InMemoryDatabaseCondition.class)
public class InMemoryDataSourceConfiguration {

    private final DataSourceProperties dsp;

    @Autowired
    public InMemoryDataSourceConfiguration(DataSourceProperties dataSourceProperties) {
        this.dsp = dataSourceProperties;
    }

    @Bean
    public DataSource dataSource() {
        HikariDataSource ds = new HikariDataSource();
        ds.setJdbcUrl(dsp.getUrl());
        ds.setUsername(dsp.getUsername());
        ds.setPassword(dsp.getPassword());
        return ds;
    }
}
{% endhighlight %}

여기서 DataSource thread 개수들을 서버의 성능에 따라 달리 사용하여서 조정할 수 있을 것이다.



---

## ✒️ 용어

###### 

---

## 🔗 관련 출처
- []()
