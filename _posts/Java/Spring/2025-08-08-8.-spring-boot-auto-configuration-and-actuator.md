---
layout: post
title:  8. Spring Boot Auto Configuration and Actuator
date:   2025-08-08 15:45:34 +0900
categories: Java Spring
---

<!--more-->

## 🪛 한계점


## 📂 목차
- []()
- []()

---

## 📚 본문

스프링 부트는 개발에 필요한 컴포넌트를 자동으로 설정해주는 기능이 있는데 이를 Auto Configuration 이라고 한다. 만약 `spring-boot-starter-web` 을 추가한다면, Spring Boot는 웹 어플리케이션 구동에 필요한 웹 서버가 필요할 것이라고 추론하고 아파치 톰캣(기본값임) 웹서버를 기본 웹 서버로 추가해준다. 톰캣 말고도 Jetty를 사용해도 무관하다. 그때는 dependencies를 Jetty를 사용하도록 수정해주면 된다(`spring-boot-starter-jetty`).

하지만 이게 모든 상황에 편리할 수는 없다. 예를 들어 개발팀1 에서 스프링 프레임워크를 사용해서 여러가지 프로젝트를 진행하고 있는데 spring bean 설정이 모든 팀(개발팀2, 개발팀3)에서 복사해서 사용하고 있으면 중복되는 bean 들을 여러 개 생성하는 것은 매우 비효율적일 것이다. 따라서 **공통 구성 설정** 이 필요할 수 있다.

### Common Context Configuration 설정

`@Configuration` 애너테이션을 통해 이 클래스를 스프링 설정으로 담당하는데, 따로 `CommonApplicationContextConfiguration` 이라는 클래스를 만들어서 이 클래스를 포함하는 프로젝트는 메이븐이나 그레이들 컴포넌트로 배포되고 개발 팀에서는 이 프로젝트를 의존 관로 추가해서 설정 클래스를 사용할 수 있을 터이다(중복된 설정 작업 막기).

{% highlight java %}
@Configuration
public class CommonApplicationContextConfiguration {
    @Bean
    public RelationalDataSourceConfiguration dataSourceConfiguration() {
        return new RelationalDataSourceConfiguration
    }
}
{% endhighlight %}

위는 `RelationalDataSourceConfiguration` 의 다른 모든 팀에서 자주 사용할 법한 그런 클래스들을 빈으로 정의하고 있다. 이렇게 정의해두면 다른 팀에서 이를 사용할 때 설정 파일 내용을 수정하는 수고를 덜 수 있다. 이제 이를 함의하는 다른 Application Context(IoC 컨테이너)를 정의하자. 영업팀은 다음을 사용할 수 있을 것이다.

{% highlight java %}
package com.example.study.config;

import org.springframework.context.annotation.*;

@Configuration
@Import(CommonApplicationContextConfiguration.class)
public class CommonBusinessApplicationContextConfiguration {
    // 영업팀의 Common ApplicationContext
}
{% endhighlight %}

### Conditional 을 통한 특정 Bean 제외하고 Import 하기

스프링 프레임워크는 스프링이 관리하는 컴포넌트의 생성을 제어할 수 있도록 `@Bean`, `@Component`, `@Configuration` 애너테이션과 함께 사용할 수 있는 `@Conditional` 애너테이션을 제공한다.

{% highlight java %}
@Configuration
public class CommonApplicationContextConfiguration {
    @Bean
    @Conditional(RelationalDatabaseCondition.class)
    public RelationalDataSourceConfiguration dataSourceConfiguration() {
        return new RelationalDataSourceConfiguration();
    }
}
{% endhighlight %}

Conditional 을 붙여 조건을 걸 수 있고, 조건에 해당하는 Context들에만 해당 Bean이 들어가게 된다. `RelationalDatabaseCondition` 은 `Condition` 인터페이스를 구현하는 클래스이고, `boolean matches()` 을 구현하도록 한다.

{% highlight java %}
package com.example.study.config;

import org.springframework.context.annotation.*;
import org.springframework.core.type.*;

public class RelationalDatabaseCondition implements Condition {

    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        return isMySqlDatabase();
    }

    private boolean isMySqlDatabase() {
        try {
            Class.forName("com.mysql.jdbc.Driver");
            return true;
        } catch (ClassNotFoundException e) {
            return false;
        }
    }
}
{% endhighlight %}

위에서는 `reflect` API를 활용하여 JVM에 jdbc.Driver 가 올라가 있는지를 살피는 로직이다. 안에 얼마든지 복잡한 로직을 사용하여 Application Context 를 유연하게 활용할 수 있다.

### @Condition 동작 방식

애너테이션만으로 조건부 빈 생성이 가능하지만, 스프링에서는 다양한 조건을 쉽게 사용할 수 있게 해주는 다양한 고수준의 애너테이션을 따로 제공한다. 몇 개만 외우자.

| 애너테이션 | 예시 | 예시 설명 |
|:===:|:===:|:===:|
| @ConditionalOnBean | @Conditional(DataSource.class) | 설정에서 DataSource 빈이 명시돼 있으면 true 반환 |
| @ConditionalOnClass | @ConditionalOnClass(DataSource.class) | 클래스 패스에 DataSource 클래스가 있으면 true 반환 |
| @ConditionalOnProperty | @ConditionalOnClass("some.property") | some.property 가 정의되어 있으면 true 반환 |
| @ConditionalOnCloud | @ConditionalOnCloud(CloudPlatform.KUBERNETES) | CloudPlatform 이 KUBERNETES로 설정돼있으면 true 반환 |
| @ConditionalOnJava | @ConditionalOnJava(JavaVersion.EIGHT) | Java 버전이 8을 지원하면 반환 |
| @ConditionalOnMissingBean | @ConditionalOnMissingBean(DataSource.class) | DataSource 빈이 설정돼 있지 않으면 true 반환 |
| @ConditionalOnMissingClass | @ConditionalOnMissingClass(DataSource.class) | 클래스 패스에 DataSource 빈이 설정돼 있지 않으면 true 반환 |
| @ConditionalOnNotWebApplication | @ConditionalOnNotWebApplication | 웹 어플이 아니면 true 반환 |
| @ConditionalOnSingleCandidate | @ConditionalOnSingleCandidate(DataSource.class) | DataSource 빈이 하나만 정의돼 있으면 true |

### spring.factories

모든 스프링 프로젝트는 spring-boot-autoconfigure 의 의존관계를 포함하고 있다.

![spring-boot-autoconfigure-jar.png](/assets/img/spring-boot-autoconfigure-jar.png)

이 모듈의 JAR 파일의 META-INF 폴더를 파헤치면

{% highlight txt %}
# ApplicationContext Initializers
org.springframework.context.ApplicationContextInitializer=\
org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\
org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener

# Application Listeners
org.springframework.context.ApplicationListener=\
org.springframework.boot.autoconfigure.BackgroundPreinitializer

# Environment Post Processors
org.springframework.boot.env.EnvironmentPostProcessor=\
org.springframework.boot.autoconfigure.integration.IntegrationPropertiesEnvironmentPostProcessor

# Auto Configuration Import Listeners
org.springframework.boot.autoconfigure.AutoConfigurationImportListener=\
org.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListener

# Auto Configuration Import Filters
org.springframework.boot.autoconfigure.AutoConfigurationImportFilter=\
org.springframework.boot.autoconfigure.condition.OnBeanCondition,\
org.springframework.boot.autoconfigure.condition.OnClassCondition,\
org.springframework.boot.autoconfigure.condition.OnWebApplicationCondition

# Failure Analyzers
org.springframework.boot.diagnostics.FailureAnalyzer=\
org.springframework.boot.autoconfigure.data.redis.RedisUrlSyntaxFailureAnalyzer,\
org.springframework.boot.autoconfigure.diagnostics.analyzer.NoSuchBeanDefinitionFailureAnalyzer,\
org.springframework.boot.autoconfigure.jdbc.DataSourceBeanCreationFailureAnalyzer,\
org.springframework.boot.autoconfigure.jdbc.HikariDriverConfigurationFailureAnalyzer,\
org.springframework.boot.autoconfigure.jooq.NoDslContextBeanFailureAnalyzer,\
org.springframework.boot.autoconfigure.r2dbc.ConnectionFactoryBeanCreationFailureAnalyzer,\
org.springframework.boot.autoconfigure.r2dbc.MissingR2dbcPoolDependencyFailureAnalyzer,\
org.springframework.boot.autoconfigure.r2dbc.MultipleConnectionPoolConfigurationsFailureAnalyzer,\
org.springframework.boot.autoconfigure.r2dbc.NoConnectionFactoryBeanFailureAnalyzer,\
org.springframework.boot.autoconfigure.ssl.BundleContentNotWatchableFailureAnalyzer

# Template Availability Providers
org.springframework.boot.autoconfigure.template.TemplateAvailabilityProvider=\
org.springframework.boot.autoconfigure.freemarker.FreeMarkerTemplateAvailabilityProvider,\
org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAvailabilityProvider,\
org.springframework.boot.autoconfigure.mustache.MustacheTemplateAvailabilityProvider,\
org.springframework.boot.autoconfigure.thymeleaf.ThymeleafTemplateAvailabilityProvider,\
org.springframework.boot.autoconfigure.web.servlet.JspTemplateAvailabilityProvider

# DataSource Initializer Detectors
org.springframework.boot.sql.init.dependency.DatabaseInitializerDetector=\
org.springframework.boot.autoconfigure.flyway.FlywayMigrationInitializerDatabaseInitializerDetector

# Depends on Database Initialization Detectors
org.springframework.boot.sql.init.dependency.DependsOnDatabaseInitializationDetector=\
org.springframework.boot.autoconfigure.batch.JobRepositoryDependsOnDatabaseInitializationDetector,\ 
org.springframework.boot.autoconfigure.quartz.SchedulerDependsOnDatabaseInitializationDetector,\
org.springframework.boot.autoconfigure.session.JdbcIndexedSessionRepositoryDependsOnDatabaseInitializationDetector
{% endhighlight %}

위와 같은 properties 가 보이며, Auto Configure 로 표시된 부분이 스프링 부트 컴포넌트, 서드 파티 라이브러리 등에 대한 자동 구성 정보가 포함돼 있는 곳이다. 각각 value로 되어 있는 클래스들은 전부 `@Conditional` 애너테이션이 붙어있는 설정파일이다.

이를 통해 DataSource 공통 컨텍스트 설정을 해보자.

{% highlight java %}

{% endhighlight %}


---

## ✒️ 용어

###### 

---

## 🔗 관련 출처
- []()
