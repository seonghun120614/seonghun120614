---
layout: post
title:  1.4 Operating System Operations
date:   2025-06-15 16:06:00 +0900
categories: ComputerScience OS
---

<!--more-->
모든 컴퓨터 시스템의 구조를 보았기 때문에, 아래의 운영체제에 대해 상세히 살펴본다.

## 📂 목차
- [Bootstrap Program](#bootstrap-program)
    - [부팅 단계 요약](#부팅-단계-요약)
- [1.4.1 Multiprogramming and Multitasking](#141-multiprogramming-and-multitasking)
    - [다중프로그래밍의 원리](#다중프로그래밍의-원리)
    - [다중 작업(Multitasking)](#다중-작업multitasking)
    - [가상 메모리와 응답 시간 보장](#가상-메모리와-응답-시간-보장)
    - [파일 시스템](#파일-시스템)
- [1.4.2 Dual-Mode and Multimode Operation](#142-dual-mode-and-multimode-operation)
    - [Dual Mode](#dual-mode)
    - [Kernel Mode에서 실행되는 Privileged Instruction](#kernel-mode에서-실행되는-privileged-instruction)
    - [Additional Modes](#additional-modes)
    - [Mode 관점에서의 Virtualization](#mode-관점에서의-virtualization)
    - [System Call 을 통한 Kernel Mode 로의 전환](#system-call-을-통한-kernel-mode-로의-전환)
- [1.4.3 Timer](#143-timer)
    - [Linux Timer](#linux-timer)

---

## 📚 본문

운영체제는 프로그램이 실행되는 환경을 제공하는 소프트웨어 + 일부 하드웨어 이다.

내부적으로는 다양한 방식으로 조작될 수 있어서 운영체제 마다 다를 수 있겠지만, 전체적인 틀에서 **공통된 컴포넌트**들을 볼 것이다.

우선 운영체제가 어떻게 컴퓨터 내에서 생성이 되는지 보자.

### Bootstrap Program

컴퓨터가 전원이 켜지거나 재시작될 때, 가장 먼저 실행되어야 할 초기 프로그램이 필요하며, 이를 **부트스트랩 프로그램(Bootstrap Program)**이라고 한다.

부트스트랩 프로그램은
- Firmware 형태로 하드웨어에 내장됨
- 컴퓨터 시스템의 모든 구성 요소(CPU 레지스터 집합, 디바이스 컨트롤러, 메모리 내용 등)를 초기화
- 운영체제 커널을 어디서 찾을지, 어떻게 적재할지, 실행을 시작할지 담당한다.

#### 부팅 단계 요약

1. 부트스트랩 프로그램이 실행됨
2. 부트스트랩은 모든 구성요소 초기화를 함
3. 초기화 후 운영체제 커널을 찾아서 메모리에 적재함
4. **적재되면 운영체제의 [Daemon](#daemon)**들이 시작됨
5. 모든 서비스가 시작된 후 **외부 이벤트(I/O 인터럽트, 하드웨어 인터럽트, [Trap](#trap) 인터럽트(Exception 인터럽트), [system call](#system-call) 등)가 발생하길 기다리는 운영 상태**가 됨

여기서 **일부 서비스는 커널 외부에서 제공**되고 이는 부팅 시 메모리에 로드되어 **백그라운드**에서 항상 실행되는 **Daemon(시스템 프로그램) 형태로 동작**한다.

Linux 시스템에서는 이러한 시스템 프로그램 중 첫 번째가 **`[systemd](#systemd)`** 이며, 이 프로그램이 여러 다른 daemon들을 시작하게 한다.

이제 운영체제가 하는 일을 보자.

### 1.4.1 Multiprogramming and Multitasking

운영체제의 특징 중 하나는 여러 프로그램을 동시에 실행할 수 있는 능력이며, 이를 **Multiprogramming** 이라고 한다.

다음 장점을 얻을 수 있다:
- 프로그램들을 조직화하여 CPU의 사용률을 높임
- 사용자 만족도를 향상시킴

실행 중인 프로그램을 **Process** 라고 부른다

#### 다중프로그래밍의 원리

![memory-layout-for-a-multiprogramming-system]({{site.baseurl}}/assets/img/memory-layout-for-a-multiprogramming-system.png)

운영체제가 여러 개의 프로세스를 동시에 메모리에 유지한다.
1. 운영체제는 이 중 하나를 선택하여 실행을 시작함
2. 해당 프로세스가 I/O 작업 등으로 대기 상태로 진입
3. 이때 운영체제는 즉시 다른 프로세스로 전환하여 실행

#### 다중 작업(Multitasking)

**Multitasking** 은 다중 프로그래밍의 논리적 확장이다.

다중 작업 시스템에서는 운영체제가 짧은 시간에 **여러 프로세스를 매우 빠르게 전환**함으로써 **사용자가 여러 작업을 동시에 하는 것처럼 느끼게** 하는걸 **Multitasking** 이라고 한다.

#### 다중 프로세스를 위한 추가 고려 사항

메모리에 여러 프로세스를 동시에 유지하려면 **어떤 형태의 메모리 관리(Memory Management)**가 필요하며 이는 추후에 다룬다.

운영체제가 일단 메모리에 관해 하는 일로는 다음과 같다:
- **CPU Scheduling**: 여러 프로세스가 동시에 실행 ready 상태에 있다면, 운영체제는 어떤 프로세스를 먼저 실행할지 결정한다.
- 동시에 여러 프로세스를 실행하려면 **프로세스 간 상호 간섭을 방지**해야 한다. 이는 **프로세스 스케줄링, 디스크 저장소, 메모리 관리** 전반에 걸쳐 필요하다.

이는 추후에 다룬다.

#### 가상 메모리와 응답 시간 보장

다중 작업 시스템에서는 운영체제가 적절한 응답 시간을 보장해야 한다. 이를 위한 방법 중 하나가 **[Virtual Memory](#virtual-memory)** 이다.

가상 메모리는:
- 메모리에 완전히 올라오지 않은 프로세스도 실행 가능하게 해줌
- **[Physical Memory](#physical-memory)**보다 더 큰 프로그램도 실행 가능
- **[Logical Memory](#logical-memory)**와 **Physical Memory**를 분리하여, 메모리를 하나의 큰 연속 공간처럼 추상화

이 방식은 프로그래머가 메모리 제약을 고려하지 않아도 되는 장점을 가진다.

#### 파일 시스템

파일 시스템은 **Secondary Storage** 에 위치하며, **Storage Management** 가 제공되어야 한다.

또한, 부적절한 자원의 사용을 방지하기 위한 보호 기능이 여기에 들어가야 한다.

### 1.4.2 Dual-Mode and Multimode Operation

운영체제와 사용자들은 컴퓨터 시스템의 하드웨어 및 소프트웨어 자원을 공유하기 때문에 잘 설계된 운영체제는 오류가 있거나 악의적인 프로그램이 다른 프로그램이나 운영체제 자체가 잘못 실행되도록 방해하면 안된다.

#### Dual Mode

따라서 위 문제의 해결책으로 둘을 완전히 분리시키면 서로 영향을 주지 못하게 되기 때문에 이를 위해 나온 개념이:
- User Mode(사용자 모드)
- **Kernel Mode(커널 모드) = Supervisor Mode = System Mode = Privileged Mode**
이다.

![transition-from-user-to-kernel-mode]({{site.baseurl}}/assets/img/transition-from-user-to-kernel-mode.png)

하드웨어에 **Mode Bit**를 추가하여 현재 모드를 나타낼 수 있다.
- 0: Kernel Mode
- 1: User Mode

따라서 컴퓨터가 어플리케이션을 실행 중일 때는 사용자 모드이며, **운영체제의 서비스를 요청할 때(system call)**는 커널 모드로 전환한다.

> 커널 모드(0): 시스템부팅, Trap, Interrupt 발생 시  
> 유저 모드(1): 운영체제가 적재된 후

이런 모드 방식을 **Dual Mode** 라고 부르고 다음 기능을 하게 된다:
- 잘못된 사용자로 부터 보호
- 동시에 사용자들 간에도 상호 보호 할 수 있는 수단을 제공

#### Kernel Mode에서 실행되는 Privileged Instruction

여기서 시스템에 해를 끼치는 명령어들을 **Kernel Mode** 로만 실행해야하기 때문에 이런 명령어들을 **Privileged Instruction** 라고 한다.

만약 이런 명령어를 **User Mode**에서 실행한다면 **Trap**을 발생시켜 즉시 제어를 운영체제로 넘긴다.

커널 모드로 전환하는 명령어는 특권 명령어 뿐만 아니라, **입출력 제어, 타이머 관리, 인터럽트 관리** 등이 있다.

#### Additional Modes

모드의 개념을 통해 사용자마다 실행할 수 있는 명령어들을 제한시킬 수 있도록 할 수 있다. 즉, 모드를 여러 개로 가져가는 것이다.

운영체제 마다 기본적으로 제공하는 모드들이 다르고 개수도 다르다.

> Intel: **4 protection rings(0, 1, 2, 3)**, 0은 커널, 3이 유저 이다  
> ARMv8: 7 개의 모드를 제공한다

#### Mode 관점에서의 Virtualization

가상화를 지원하는 CPU는 **Virtual Machine Manager(VMM)** 가 시스템을 제어하고 있다는 것을 나타내기 위한 별도의 모드를 제공하기도 한다.

이 모드는 일반 사용자보다는 더 많은 권한을 가지기는 하지만, 커널보다는 적은 권한을 가진다(4 protection ring에서 2, 3 정도라고 보면 된다).

VMM은 이러한 권한 수준을 통해 **가상 머신을 생성, 관리, CPU 상태 변경**을 한다.

#### System Call 을 통한 Kernel Mode 로의 전환

사용자 프로그램이 운영체제에게 특정 작업을 요청하는 공식적인 방법이라고 할 수 있다. 보통 파일 접근, 메모리 할당, 프로세스 제어 등 운영체제만 수행할 수 있는 작업이며, 이는 사용자 모드에서는 못하는 명령어 수준이다.

**System Call의 과정**
1. 사용자 프로그램이 **System Call**
2. **Trap** 명령을 통해 **Kernel Mode** 로 전환
3. 커널이 어떤 요청인지 확인 후 파라미터 검사
4. 요청 처리 후 다시 사용자 모드로 전환

**Exception 과정**
- 잘못된 명령어 실행 및 접근 불가 메모리 사용 시 Trap 발생
- 커널이 이를 감지하고 운영체제가 비정상 종료 처리를 함
- 종료 시 오류 메시지 + **[Memory Dump](#memory-dump)**를 생성함

### 1.4.3 Timer

운영체제는 사용자 프로그램이 무한 루프에 빠지거나 운영체제에 제어를 반환하지 않는 것을 방지해야 한다.

이를 위해 Timer 를 도입하고, 다음과 같이 동작한다:
1. 운영체제가 타이머를 설정
2. 일정 시간이 지나면 인터럽트 발생
3. 운영체제가 제어권을 다시 획득
즉, 빌리는 것이다.

이를 구현하는 방식으로는:
- **고정 속도 클럭(Clock)**과 **카운터(Counter)**가 필요
- 운영체제가 타이머의 Counter 를 설정
- Clock 이 1 tick 할 때마다 Counter 를 -1
- Counter가 0이 되면 **Interrupt** 발생

> 10 비트 카운터 + 1ms 클럭  
> -> 1~1024(2^10)ms 범위로 인터럽트 설정 가능

운영체제는 사용자 프로그램에 제어를 넘기기 전에 반드시 타이머를 설정한다. 만약 타이머 인터럽트가 발생하면 제어는 자동으로 운영체제로 전환된다. 이때 운영체제는 이 인터럽트를 치명적인 오류(fatal error)로 간주하거나 프로그램 실행 시간을 연장해 줄 수도 있다.

여기서 **타이머의 내용을 수정하는 명령어는 특권 명령이며, 일반 사용자 프로그램이 직접 변경할 수 없다**.

#### Linux Timer

리눅스에는 커널 설정 파라미터인 HZ 가 타이머 인터럽트의 빈도를 지정한다.

> HZ = 250  
> -> 타이머는 초당 250번의 인터럽트를 발생시킴  
> -> 4밀리초마다 한번의 인터럽트가 발생

따라서 리눅스에서 또 파생되어 나오는 우분투, 레드햇 등등이 이런 HZ 값이 달라질 수도 있다.

이와 관련된 커널 변수로는 **jiffies** 가 있고, 시스템이 부팅된 이후 발생한 타이머 인터럽트의 총 횟수를 나타낸다.

---

## ✒️ 용어

###### Virtual Memory

실제 메모리(RAM)의 용량을 넘는 프로그램 실행을 가능하게 해주는 메모리 관리 기법이다. 운영체제가 **Secondary Storage의 일부 공간**을 마치 주기억장치처럼 사용하도록 하여, 프로세스는 연속적이고 큰 메모리 공간이 있는 것처럼 동작할 수 있게 한다.

**주요 특징**
- 프로그램은 전체를 한 번에 메모리에 올리지 않고, 필요한 부분만 메모리에 적재
- 나머지는 디스크에 저장되어 있다가 필요할 때 메모리로 불러온다 (**Page** 교체)
- 메모리 주소는 **가상 주소(Virtual Address)**로 관리되며, 하드웨어의 **[MMU(Memory Management Unit)](#️mmumemory-management-unit)**가 이를 실제 물리 주소로 변환한다

**장점**
- 실행 중인 프로그램 수 증가 가능
- 메모리 사용의 효율 증가
- 프로그램 간 메모리 보호(격리) 가능

**단점**
- 디스크 접근은 느리기 때문에 과도한 페이지 교체가 발생하면 속도 저하 발생 (→ **스래싱 현상**)

> 요약: 실제 메모리보다 더 많은 메모리를 쓰는 것처럼 “속임수”를 써서 실행시키는 운영체제의 중요한 기능

###### Daemon

백그라운드에서 지속적으로 실행되며, 특정 작업이나 요청을 대기 및 처리하는 프로그램 또는 프로세스.
사용자와 직접 상호작용하지 않으며, 시스템의 서비스나 자원을 자동으로 관리함.

**주요 특징**
- 시스템 부팅 시 자동 시작되며 **종료될 때까지 계속 실행됨**
- 사용자 입력 없이 작동하며, **요청이 올 때까지 대기 상태(idle) 유지**
- 프로세스 이름 끝에 보통 d가 붙음 (예: **httpd, sshd, crond**)

> sshd: SSH 접속 요청을 대기 및 처리  
> httpd: 웹 서버 요청을 처리  
> crond: 예약 작업을 일정에 따라 자동 실행  
> ...

###### Trap

Trap은 운영체제가 개입해야 할 상황에서 CPU가 발생시키는 소프트웨어 인터럽트이다. 사용자 프로그램에서 **의도적으로 커널 기능(운영체제 기능)**을 호출하거나, **예외 상황(예: 0으로 나누기, 메모리 접근 오류)**이 발생했을 때 운영체제가 개입할 수 있도록 한다.

###### System Call

사용자 프로그램이 운영체제의 기능(서비스)을 요청할 때 사용하는 인터페이스.
일반 프로그램은 직접 하드웨어를 제어할 수 없기 때문에, 운영체제를 통해 간접적으로 하드웨어나 자원에 접근해야 한다. 이때 사용하는 것이 시스템 콜이다.

> 예: 파일 열기, 읽기, 쓰기 (open(), read(), write())  
> 프로세스 생성 (fork())  
> 메모리 할당 (mmap())  
> 네트워크 통신 (socket())

**과정**
1. 사용자 프로그램이 **시스템 콜 호출**
2. **Trap** 명령어를 통해 **커널 모드(Kernel Mode)로 전환**
3. 커널의 **System Call Handler**가 요청 처리
4. 처리 결과를 사용자 프로그램에 반환하고 **사용자 모드(User Mode)로 복귀**

**특징**
- 운영체제와 사용자 프로그램 사이의 경계(보안과 안정성) 유지
- 커널 모드로 진입하는 유일한 공식 통로

###### Memory Dump

프로세스가 비정상 종료가 되었을 시에 저장되는 메모리 상태이며, 디버깅에 활용된다.

###### Systemd

Linux 초기화 시스템이자 주요 Daemon 관리 도구이다.

###### ⭐️MMU(Memory Management Unit)

**Virtual Address** -> **Physical Address** 변환을 담당하는 하드웨어

###### Physical memory

**실제 컴퓨터에 장착된 메모리(RAM)**를 의미한다. CPU가 직접 접근 가능한 주소 공간으로, 운영체제가 메모리 관리를 위해 사용한다.

**특징**
- 하드웨어적으로 존재하는 메모리 칩의 용량과 구조
- 주소는 0번부터 메모리 크기만큼 **연속적인 물리 주소(Physical Address)**로 구성
- 운영체제는 이 공간을 효율적으로 나누어 사용자 프로그램에 할당

> 예: 16GB RAM이 있다면, 그게 곧 물리적 메모리

###### Logical Memory

사용자 프로세스 입장에서 보이는 메모리 공간을 말한다. 즉, 프로세스가 인식하는 주소 공간이며, 실제 물리 메모리와는 다를 수 있다.
- 보통 0번 주소부터 시작하는 가상의 연속 메모리 공간
- 운영체제는 논리 주소(Logical Address)를 물리 주소로 변환(정확히는 MMU가 변환, 운영체제는 명령을 시킴)
- 이 추상화를 통해 각 프로세스가 독립된 주소 공간을 갖고 있는 것처럼 보이게 함

> 예: 두 개의 서로 다른 프로그램이 둘 다 0x00000000 주소를 사용할 수 있음  
> 실제론 서로 다른 물리 주소로 매핑됨 (운영체제가 관리)

---

## 🔗 출처
- 도서: [Operating System Concepts 10th Edition]()
