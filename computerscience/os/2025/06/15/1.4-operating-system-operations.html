<!DOCTYPE html>
<html lang="kor">

    <head><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<link href="https://fonts.googleapis.com/css?family=Merriweather:300|Raleway:400,700" rel="stylesheet">
<link rel="icon" href="/seonghun120614/assets/img/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/seonghun120614/assets/css/style.css">
<title>1.4 Operating System Operations</title>
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>1.4 Operating System Operations | Seonghun’s Blog</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="1.4 Operating System Operations" />
<meta name="author" content="Seonghun Park" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="모든 컴퓨터 시스템의 구조를 보았기 때문에, 아래의 운영체제에 대해 상세히 살펴본다." />
<meta property="og:description" content="모든 컴퓨터 시스템의 구조를 보았기 때문에, 아래의 운영체제에 대해 상세히 살펴본다." />
<link rel="canonical" href="https://seonghun120614.github.io/seonghun120614/computerscience/os/2025/06/15/1.4-operating-system-operations.html" />
<meta property="og:url" content="https://seonghun120614.github.io/seonghun120614/computerscience/os/2025/06/15/1.4-operating-system-operations.html" />
<meta property="og:site_name" content="Seonghun’s Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-06-15T07:06:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="1.4 Operating System Operations" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Seonghun Park"},"dateModified":"2025-06-15T07:06:00+00:00","datePublished":"2025-06-15T07:06:00+00:00","description":"모든 컴퓨터 시스템의 구조를 보았기 때문에, 아래의 운영체제에 대해 상세히 살펴본다.","headline":"1.4 Operating System Operations","mainEntityOfPage":{"@type":"WebPage","@id":"https://seonghun120614.github.io/seonghun120614/computerscience/os/2025/06/15/1.4-operating-system-operations.html"},"url":"https://seonghun120614.github.io/seonghun120614/computerscience/os/2025/06/15/1.4-operating-system-operations.html"}</script>
<!-- End Jekyll SEO tag -->


<script type="text/javascript" src="/seonghun120614/assets/js/darkmode.js"></script>

<!-- Mermaid -->
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-RQTWJRLWGD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-RQTWJRLWGD');
</script></head><script>
        document.addEventListener("DOMContentLoaded", function () {
            const toggle = document.getElementById("dark-toggle");
        
            // 이미 실행한 적 있는지 확인
            const hasToggled = localStorage.getItem("darkModeInitialized");
        
            if (!hasToggled && toggle && toggle.checked) {
                toggleDarkMode();
                localStorage.setItem("darkModeInitialized", "true"); // 최초 실행 기록
            }
        });
    </script>

    <body>
        <div id="scroll-progress"></div>
        <main class="container">
            <section class="about">
                <div class="about-header condensed">
                    <div class="about-title">
                        <a href="/seonghun120614/">
                            
                            <img class="light"
                                src="/seonghun120614/assets/portfolio.png"
                                alt="Seonghun Park" />
                            <img class="dark"
                                src="/seonghun120614/assets/portfolio.png"
                                alt="Seonghun Park" />
                            
                        </a>
                        <h2 id="title">
                            <a href="/seonghun120614/">Seonghun Park</a>
                        </h2>
                    </div><p class="tagline">Developer.</p></div>
                
                <ul class="social about-footer condensed"><li>
                        <a
                            href="https://github.com/seonghun120614"
                            target="_blank"
                            rel="noopener"
                            aria-label="github">
                            <i class="icon-github-circled"></i>
                        </a>
                    </li><li>
                        <a
                            href="mailto:seonghun120614@gmail.com"
                            target="_blank" rel="noopener" aria-label="email">
                            <i class="icon-mail-alt"></i>
                        </a>
                    </li></ul><nav class="navigation about-footer condensed">
                    <ul>
                        
                        <li>
                            <a href="/seonghun120614/about">About Me</a>
                        </li>
                        
                        <li>
                            <a href="/seonghun120614/categories/computerscience">Computer Science</a>
                        </li>
                        
                        <li>
                            <a href="/seonghun120614/categories/math">Math</a>
                        </li>
                        
                        <li>
                            <a href="/seonghun120614/categories/softwareengineering">Software Engineering</a>
                        </li>
                        
                    </ul>
                </nav><p class="about-footer condensed">&copy;
                    2025</p><div class="about-footer condensed">
                    <p>Dark Mode
                        <i class="icon-moon"></i>
                        <label class="switch" for="dark-toggle">
                            <input id="dark-toggle" type="checkbox"
                                class="dark-mode-toggle"
                                aria-label="Toggle dark mode">
                            <span class="slider round"
                                onclick="toggleDarkMode()"></span>
                        </label>
                    </p>
                </div>
            </section>
            <section class="content">
                <script>
window.MathJax = {
    tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']]
    },
    options: {
    renderActions: {
        addMenu: []
    }
    }
};
</script>

<script type="text/javascript"
    id="MathJax-script"
    async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script><div class="post-container">
    <a class="post-link" href="/seonghun120614/computerscience/os/2025/06/15/1.4-operating-system-operations.html">
        <h2 class="post-title">1.4 Operating System Operations</h2>
    </a>
    
    <div class="post-meta">
        <div class="post-date"><i class="icon-calendar"></i>Jun 15, 2025</div><ul class="post-categories"><li>ComputerScience</li><li>OS</li></ul></div>

    <div class="post">
        <!--more-->
<p>모든 컴퓨터 시스템의 구조를 보았기 때문에, 아래의 운영체제에 대해 상세히 살펴본다.</p>

<h2 id="-목차">📂 목차</h2>
<ul>
  <li><a href="#bootstrap-program">Bootstrap Program</a>
    <ul>
      <li><a href="#부팅-단계-요약">부팅 단계 요약</a></li>
    </ul>
  </li>
  <li><a href="#141-multiprogramming-and-multitasking">1.4.1 Multiprogramming and Multitasking</a>
    <ul>
      <li><a href="#다중프로그래밍의-원리">다중프로그래밍의 원리</a></li>
      <li><a href="#다중-작업multitasking">다중 작업(Multitasking)</a></li>
      <li><a href="#가상-메모리와-응답-시간-보장">가상 메모리와 응답 시간 보장</a></li>
      <li><a href="#파일-시스템">파일 시스템</a></li>
    </ul>
  </li>
  <li><a href="#142-dual-mode-and-multimode-operation">1.4.2 Dual-Mode and Multimode Operation</a>
    <ul>
      <li><a href="#dual-mode">Dual Mode</a></li>
      <li><a href="#kernel-mode에서-실행되는-privileged-instruction">Kernel Mode에서 실행되는 Privileged Instruction</a></li>
      <li><a href="#additional-modes">Additional Modes</a></li>
      <li><a href="#mode-관점에서의-virtualization">Mode 관점에서의 Virtualization</a></li>
      <li><a href="#system-call-을-통한-kernel-mode-로의-전환">System Call 을 통한 Kernel Mode 로의 전환</a></li>
    </ul>
  </li>
  <li><a href="#143-timer">1.4.3 Timer</a>
    <ul>
      <li><a href="#linux-timer">Linux Timer</a></li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="-본문">📚 본문</h2>

<p>운영체제는 프로그램이 실행되는 환경을 제공하는 소프트웨어 + 일부 하드웨어 이다.</p>

<p>내부적으로는 다양한 방식으로 조작될 수 있어서 운영체제 마다 다를 수 있겠지만, 전체적인 틀에서 <strong>공통된 컴포넌트</strong>들을 볼 것이다.</p>

<p>우선 운영체제가 어떻게 컴퓨터 내에서 생성이 되는지 보자.</p>

<h3 id="bootstrap-program">Bootstrap Program</h3>

<p>컴퓨터가 전원이 켜지거나 재시작될 때, 가장 먼저 실행되어야 할 초기 프로그램이 필요하며, 이를 <strong>부트스트랩 프로그램(Bootstrap Program)</strong>이라고 한다.</p>

<p>부트스트랩 프로그램은</p>
<ul>
  <li>Firmware 형태로 하드웨어에 내장됨</li>
  <li>컴퓨터 시스템의 모든 구성 요소(CPU 레지스터 집합, 디바이스 컨트롤러, 메모리 내용 등)를 초기화</li>
  <li>운영체제 커널을 어디서 찾을지, 어떻게 적재할지, 실행을 시작할지 담당한다.</li>
</ul>

<h4 id="부팅-단계-요약">부팅 단계 요약</h4>

<ol>
  <li>부트스트랩 프로그램이 실행됨</li>
  <li>부트스트랩은 모든 구성요소 초기화를 함</li>
  <li>초기화 후 운영체제 커널을 찾아서 메모리에 적재함</li>
  <li><strong>적재되면 운영체제의 <a href="#daemon">Daemon</a></strong>들이 시작됨</li>
  <li>모든 서비스가 시작된 후 <strong>외부 이벤트(I/O 인터럽트, 하드웨어 인터럽트, <a href="#trap">Trap</a> 인터럽트(Exception 인터럽트), <a href="#system-call">system call</a> 등)가 발생하길 기다리는 운영 상태</strong>가 됨</li>
</ol>

<p>여기서 <strong>일부 서비스는 커널 외부에서 제공</strong>되고 이는 부팅 시 메모리에 로드되어 <strong>백그라운드</strong>에서 항상 실행되는 <strong>Daemon(시스템 프로그램) 형태로 동작</strong>한다.</p>

<p>Linux 시스템에서는 이러한 시스템 프로그램 중 첫 번째가 <strong><code class="language-plaintext highlighter-rouge">[systemd](#systemd)</code></strong> 이며, 이 프로그램이 여러 다른 daemon들을 시작하게 한다.</p>

<p>이제 운영체제가 하는 일을 보자.</p>

<h3 id="141-multiprogramming-and-multitasking">1.4.1 Multiprogramming and Multitasking</h3>

<p>운영체제의 특징 중 하나는 여러 프로그램을 동시에 실행할 수 있는 능력이며, 이를 <strong>Multiprogramming</strong> 이라고 한다.</p>

<p>다음 장점을 얻을 수 있다:</p>
<ul>
  <li>프로그램들을 조직화하여 CPU의 사용률을 높임</li>
  <li>사용자 만족도를 향상시킴</li>
</ul>

<p>실행 중인 프로그램을 <strong>Process</strong> 라고 부른다</p>

<h4 id="다중프로그래밍의-원리">다중프로그래밍의 원리</h4>

<p><img src="/seonghun120614/assets/img/memory-layout-for-a-multiprogramming-system.png" alt="memory-layout-for-a-multiprogramming-system" /></p>

<p>운영체제가 여러 개의 프로세스를 동시에 메모리에 유지한다.</p>
<ol>
  <li>운영체제는 이 중 하나를 선택하여 실행을 시작함</li>
  <li>해당 프로세스가 I/O 작업 등으로 대기 상태로 진입</li>
  <li>이때 운영체제는 즉시 다른 프로세스로 전환하여 실행</li>
</ol>

<h4 id="다중-작업multitasking">다중 작업(Multitasking)</h4>

<p><strong>Multitasking</strong> 은 다중 프로그래밍의 논리적 확장이다.</p>

<p>다중 작업 시스템에서는 운영체제가 짧은 시간에 <strong>여러 프로세스를 매우 빠르게 전환</strong>함으로써 <strong>사용자가 여러 작업을 동시에 하는 것처럼 느끼게</strong> 하는걸 <strong>Multitasking</strong> 이라고 한다.</p>

<h4 id="다중-프로세스를-위한-추가-고려-사항">다중 프로세스를 위한 추가 고려 사항</h4>

<p>메모리에 여러 프로세스를 동시에 유지하려면 <strong>어떤 형태의 메모리 관리(Memory Management)</strong>가 필요하며 이는 추후에 다룬다.</p>

<p>운영체제가 일단 메모리에 관해 하는 일로는 다음과 같다:</p>
<ul>
  <li><strong>CPU Scheduling</strong>: 여러 프로세스가 동시에 실행 ready 상태에 있다면, 운영체제는 어떤 프로세스를 먼저 실행할지 결정한다.</li>
  <li>동시에 여러 프로세스를 실행하려면 <strong>프로세스 간 상호 간섭을 방지</strong>해야 한다. 이는 <strong>프로세스 스케줄링, 디스크 저장소, 메모리 관리</strong> 전반에 걸쳐 필요하다.</li>
</ul>

<p>이는 추후에 다룬다.</p>

<h4 id="가상-메모리와-응답-시간-보장">가상 메모리와 응답 시간 보장</h4>

<p>다중 작업 시스템에서는 운영체제가 적절한 응답 시간을 보장해야 한다. 이를 위한 방법 중 하나가 <strong><a href="#virtual-memory">Virtual Memory</a></strong> 이다.</p>

<p>가상 메모리는:</p>
<ul>
  <li>메모리에 완전히 올라오지 않은 프로세스도 실행 가능하게 해줌</li>
  <li><strong><a href="#physical-memory">Physical Memory</a></strong>보다 더 큰 프로그램도 실행 가능</li>
  <li><strong><a href="#logical-memory">Logical Memory</a></strong>와 <strong>Physical Memory</strong>를 분리하여, 메모리를 하나의 큰 연속 공간처럼 추상화</li>
</ul>

<p>이 방식은 프로그래머가 메모리 제약을 고려하지 않아도 되는 장점을 가진다.</p>

<h4 id="파일-시스템">파일 시스템</h4>

<p>파일 시스템은 <strong>Secondary Storage</strong> 에 위치하며, <strong>Storage Management</strong> 가 제공되어야 한다.</p>

<p>또한, 부적절한 자원의 사용을 방지하기 위한 보호 기능이 여기에 들어가야 한다.</p>

<h3 id="142-dual-mode-and-multimode-operation">1.4.2 Dual-Mode and Multimode Operation</h3>

<p>운영체제와 사용자들은 컴퓨터 시스템의 하드웨어 및 소프트웨어 자원을 공유하기 때문에 잘 설계된 운영체제는 오류가 있거나 악의적인 프로그램이 다른 프로그램이나 운영체제 자체가 잘못 실행되도록 방해하면 안된다.</p>

<h4 id="dual-mode">Dual Mode</h4>

<p>따라서 위 문제의 해결책으로 둘을 완전히 분리시키면 서로 영향을 주지 못하게 되기 때문에 이를 위해 나온 개념이:</p>
<ul>
  <li>User Mode(사용자 모드)</li>
  <li><strong>Kernel Mode(커널 모드) = Supervisor Mode = System Mode = Privileged Mode</strong>
이다.</li>
</ul>

<p><img src="/seonghun120614/assets/img/transition-from-user-to-kernel-mode.png" alt="transition-from-user-to-kernel-mode" /></p>

<p>하드웨어에 <strong>Mode Bit</strong>를 추가하여 현재 모드를 나타낼 수 있다.</p>
<ul>
  <li>0: Kernel Mode</li>
  <li>1: User Mode</li>
</ul>

<p>따라서 컴퓨터가 어플리케이션을 실행 중일 때는 사용자 모드이며, <strong>운영체제의 서비스를 요청할 때(system call)</strong>는 커널 모드로 전환한다.</p>

<blockquote>
  <p>커널 모드(0): 시스템부팅, Trap, Interrupt 발생 시<br />
유저 모드(1): 운영체제가 적재된 후</p>
</blockquote>

<p>이런 모드 방식을 <strong>Dual Mode</strong> 라고 부르고 다음 기능을 하게 된다:</p>
<ul>
  <li>잘못된 사용자로 부터 보호</li>
  <li>동시에 사용자들 간에도 상호 보호 할 수 있는 수단을 제공</li>
</ul>

<h4 id="kernel-mode에서-실행되는-privileged-instruction">Kernel Mode에서 실행되는 Privileged Instruction</h4>

<p>여기서 시스템에 해를 끼치는 명령어들을 <strong>Kernel Mode</strong> 로만 실행해야하기 때문에 이런 명령어들을 <strong>Privileged Instruction</strong> 라고 한다.</p>

<p>만약 이런 명령어를 <strong>User Mode</strong>에서 실행한다면 <strong>Trap</strong>을 발생시켜 즉시 제어를 운영체제로 넘긴다.</p>

<p>커널 모드로 전환하는 명령어는 특권 명령어 뿐만 아니라, <strong>입출력 제어, 타이머 관리, 인터럽트 관리</strong> 등이 있다.</p>

<h4 id="additional-modes">Additional Modes</h4>

<p>모드의 개념을 통해 사용자마다 실행할 수 있는 명령어들을 제한시킬 수 있도록 할 수 있다. 즉, 모드를 여러 개로 가져가는 것이다.</p>

<p>운영체제 마다 기본적으로 제공하는 모드들이 다르고 개수도 다르다.</p>

<blockquote>
  <p>Intel: <strong>4 protection rings(0, 1, 2, 3)</strong>, 0은 커널, 3이 유저 이다<br />
ARMv8: 7 개의 모드를 제공한다</p>
</blockquote>

<h4 id="mode-관점에서의-virtualization">Mode 관점에서의 Virtualization</h4>

<p>가상화를 지원하는 CPU는 <strong>Virtual Machine Manager(VMM)</strong> 가 시스템을 제어하고 있다는 것을 나타내기 위한 별도의 모드를 제공하기도 한다.</p>

<p>이 모드는 일반 사용자보다는 더 많은 권한을 가지기는 하지만, 커널보다는 적은 권한을 가진다(4 protection ring에서 2, 3 정도라고 보면 된다).</p>

<p>VMM은 이러한 권한 수준을 통해 <strong>가상 머신을 생성, 관리, CPU 상태 변경</strong>을 한다.</p>

<h4 id="system-call-을-통한-kernel-mode-로의-전환">System Call 을 통한 Kernel Mode 로의 전환</h4>

<p>사용자 프로그램이 운영체제에게 특정 작업을 요청하는 공식적인 방법이라고 할 수 있다. 보통 파일 접근, 메모리 할당, 프로세스 제어 등 운영체제만 수행할 수 있는 작업이며, 이는 사용자 모드에서는 못하는 명령어 수준이다.</p>

<p><strong>System Call의 과정</strong></p>
<ol>
  <li>사용자 프로그램이 <strong>System Call</strong></li>
  <li><strong>Trap</strong> 명령을 통해 <strong>Kernel Mode</strong> 로 전환</li>
  <li>커널이 어떤 요청인지 확인 후 파라미터 검사</li>
  <li>요청 처리 후 다시 사용자 모드로 전환</li>
</ol>

<p><strong>Exception 과정</strong></p>
<ul>
  <li>잘못된 명령어 실행 및 접근 불가 메모리 사용 시 Trap 발생</li>
  <li>커널이 이를 감지하고 운영체제가 비정상 종료 처리를 함</li>
  <li>종료 시 오류 메시지 + <strong><a href="#memory-dump">Memory Dump</a></strong>를 생성함</li>
</ul>

<h3 id="143-timer">1.4.3 Timer</h3>

<p>운영체제는 사용자 프로그램이 무한 루프에 빠지거나 운영체제에 제어를 반환하지 않는 것을 방지해야 한다.</p>

<p>이를 위해 Timer 를 도입하고, 다음과 같이 동작한다:</p>
<ol>
  <li>운영체제가 타이머를 설정</li>
  <li>일정 시간이 지나면 인터럽트 발생</li>
  <li>운영체제가 제어권을 다시 획득
즉, 빌리는 것이다.</li>
</ol>

<p>이를 구현하는 방식으로는:</p>
<ul>
  <li><strong>고정 속도 클럭(Clock)</strong>과 <strong>카운터(Counter)</strong>가 필요</li>
  <li>운영체제가 타이머의 Counter 를 설정</li>
  <li>Clock 이 1 tick 할 때마다 Counter 를 -1</li>
  <li>Counter가 0이 되면 <strong>Interrupt</strong> 발생</li>
</ul>

<blockquote>
  <p>10 비트 카운터 + 1ms 클럭<br />
-&gt; 1~1024(2^10)ms 범위로 인터럽트 설정 가능</p>
</blockquote>

<p>운영체제는 사용자 프로그램에 제어를 넘기기 전에 반드시 타이머를 설정한다. 만약 타이머 인터럽트가 발생하면 제어는 자동으로 운영체제로 전환된다. 이때 운영체제는 이 인터럽트를 치명적인 오류(fatal error)로 간주하거나 프로그램 실행 시간을 연장해 줄 수도 있다.</p>

<p>여기서 <strong>타이머의 내용을 수정하는 명령어는 특권 명령이며, 일반 사용자 프로그램이 직접 변경할 수 없다</strong>.</p>

<h4 id="linux-timer">Linux Timer</h4>

<p>리눅스에는 커널 설정 파라미터인 HZ 가 타이머 인터럽트의 빈도를 지정한다.</p>

<blockquote>
  <p>HZ = 250<br />
-&gt; 타이머는 초당 250번의 인터럽트를 발생시킴<br />
-&gt; 4밀리초마다 한번의 인터럽트가 발생</p>
</blockquote>

<p>따라서 리눅스에서 또 파생되어 나오는 우분투, 레드햇 등등이 이런 HZ 값이 달라질 수도 있다.</p>

<p>이와 관련된 커널 변수로는 <strong>jiffies</strong> 가 있고, 시스템이 부팅된 이후 발생한 타이머 인터럽트의 총 횟수를 나타낸다.</p>

<hr />

<h2 id="️-용어">✒️ 용어</h2>

<h6 id="virtual-memory">Virtual Memory</h6>

<p>실제 메모리(RAM)의 용량을 넘는 프로그램 실행을 가능하게 해주는 메모리 관리 기법이다. 운영체제가 <strong>Secondary Storage의 일부 공간</strong>을 마치 주기억장치처럼 사용하도록 하여, 프로세스는 연속적이고 큰 메모리 공간이 있는 것처럼 동작할 수 있게 한다.</p>

<p><strong>주요 특징</strong></p>
<ul>
  <li>프로그램은 전체를 한 번에 메모리에 올리지 않고, 필요한 부분만 메모리에 적재</li>
  <li>나머지는 디스크에 저장되어 있다가 필요할 때 메모리로 불러온다 (<strong>Page</strong> 교체)</li>
  <li>메모리 주소는 <strong>가상 주소(Virtual Address)</strong>로 관리되며, 하드웨어의 <strong><a href="#️mmumemory-management-unit">MMU(Memory Management Unit)</a></strong>가 이를 실제 물리 주소로 변환한다</li>
</ul>

<p><strong>장점</strong></p>
<ul>
  <li>실행 중인 프로그램 수 증가 가능</li>
  <li>메모리 사용의 효율 증가</li>
  <li>프로그램 간 메모리 보호(격리) 가능</li>
</ul>

<p><strong>단점</strong></p>
<ul>
  <li>디스크 접근은 느리기 때문에 과도한 페이지 교체가 발생하면 속도 저하 발생 (→ <strong>스래싱 현상</strong>)</li>
</ul>

<blockquote>
  <p>요약: 실제 메모리보다 더 많은 메모리를 쓰는 것처럼 “속임수”를 써서 실행시키는 운영체제의 중요한 기능</p>
</blockquote>

<h6 id="daemon">Daemon</h6>

<p>백그라운드에서 지속적으로 실행되며, 특정 작업이나 요청을 대기 및 처리하는 프로그램 또는 프로세스.
사용자와 직접 상호작용하지 않으며, 시스템의 서비스나 자원을 자동으로 관리함.</p>

<p><strong>주요 특징</strong></p>
<ul>
  <li>시스템 부팅 시 자동 시작되며 <strong>종료될 때까지 계속 실행됨</strong></li>
  <li>사용자 입력 없이 작동하며, <strong>요청이 올 때까지 대기 상태(idle) 유지</strong></li>
  <li>프로세스 이름 끝에 보통 d가 붙음 (예: <strong>httpd, sshd, crond</strong>)</li>
</ul>

<blockquote>
  <p>sshd: SSH 접속 요청을 대기 및 처리<br />
httpd: 웹 서버 요청을 처리<br />
crond: 예약 작업을 일정에 따라 자동 실행<br />
…</p>
</blockquote>

<h6 id="trap">Trap</h6>

<p>Trap은 운영체제가 개입해야 할 상황에서 CPU가 발생시키는 소프트웨어 인터럽트이다. 사용자 프로그램에서 <strong>의도적으로 커널 기능(운영체제 기능)</strong>을 호출하거나, <strong>예외 상황(예: 0으로 나누기, 메모리 접근 오류)</strong>이 발생했을 때 운영체제가 개입할 수 있도록 한다.</p>

<h6 id="system-call">System Call</h6>

<p>사용자 프로그램이 운영체제의 기능(서비스)을 요청할 때 사용하는 인터페이스.
일반 프로그램은 직접 하드웨어를 제어할 수 없기 때문에, 운영체제를 통해 간접적으로 하드웨어나 자원에 접근해야 한다. 이때 사용하는 것이 시스템 콜이다.</p>

<blockquote>
  <p>예: 파일 열기, 읽기, 쓰기 (open(), read(), write())<br />
프로세스 생성 (fork())<br />
메모리 할당 (mmap())<br />
네트워크 통신 (socket())</p>
</blockquote>

<p><strong>과정</strong></p>
<ol>
  <li>사용자 프로그램이 <strong>시스템 콜 호출</strong></li>
  <li><strong>Trap</strong> 명령어를 통해 <strong>커널 모드(Kernel Mode)로 전환</strong></li>
  <li>커널의 <strong>System Call Handler</strong>가 요청 처리</li>
  <li>처리 결과를 사용자 프로그램에 반환하고 <strong>사용자 모드(User Mode)로 복귀</strong></li>
</ol>

<p><strong>특징</strong></p>
<ul>
  <li>운영체제와 사용자 프로그램 사이의 경계(보안과 안정성) 유지</li>
  <li>커널 모드로 진입하는 유일한 공식 통로</li>
</ul>

<h6 id="memory-dump">Memory Dump</h6>

<p>프로세스가 비정상 종료가 되었을 시에 저장되는 메모리 상태이며, 디버깅에 활용된다.</p>

<h6 id="systemd">Systemd</h6>

<p>Linux 초기화 시스템이자 주요 Daemon 관리 도구이다.</p>

<h6 id="️mmumemory-management-unit">⭐️MMU(Memory Management Unit)</h6>

<p><strong>Virtual Address</strong> -&gt; <strong>Physical Address</strong> 변환을 담당하는 하드웨어</p>

<h6 id="physical-memory">Physical memory</h6>

<p><strong>실제 컴퓨터에 장착된 메모리(RAM)</strong>를 의미한다. CPU가 직접 접근 가능한 주소 공간으로, 운영체제가 메모리 관리를 위해 사용한다.</p>

<p><strong>특징</strong></p>
<ul>
  <li>하드웨어적으로 존재하는 메모리 칩의 용량과 구조</li>
  <li>주소는 0번부터 메모리 크기만큼 <strong>연속적인 물리 주소(Physical Address)</strong>로 구성</li>
  <li>운영체제는 이 공간을 효율적으로 나누어 사용자 프로그램에 할당</li>
</ul>

<blockquote>
  <p>예: 16GB RAM이 있다면, 그게 곧 물리적 메모리</p>
</blockquote>

<h6 id="logical-memory">Logical Memory</h6>

<p>사용자 프로세스 입장에서 보이는 메모리 공간을 말한다. 즉, 프로세스가 인식하는 주소 공간이며, 실제 물리 메모리와는 다를 수 있다.</p>
<ul>
  <li>보통 0번 주소부터 시작하는 가상의 연속 메모리 공간</li>
  <li>운영체제는 논리 주소(Logical Address)를 물리 주소로 변환(정확히는 MMU가 변환, 운영체제는 명령을 시킴)</li>
  <li>이 추상화를 통해 각 프로세스가 독립된 주소 공간을 갖고 있는 것처럼 보이게 함</li>
</ul>

<blockquote>
  <p>예: 두 개의 서로 다른 프로그램이 둘 다 0x00000000 주소를 사용할 수 있음<br />
실제론 서로 다른 물리 주소로 매핑됨 (운영체제가 관리)</p>
</blockquote>

<hr />

<h2 id="-출처">🔗 출처</h2>
<ul>
  <li>도서: <a href="">Operating System Concepts 10th Edition</a></li>
</ul>

    </div><div id="disqus_thread" style="margin-top:25px"></div>
    <script>
    var disqus_config = function () {
        this.page.url = 'https://seonghun120614.github.io/seonghun120614/computerscience/os/2025/06/15/1.4-operating-system-operations.html';
        this.page.identifier = 'https://seonghun120614.github.io/seonghun120614/computerscience/os/2025/06/15/1.4-operating-system-operations.html';
    };
    (function () {
        var d = document, s = d.createElement('script');
        s.src = 'https://seonghun.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
  </script>
    <noscript>Please enable JavaScript to view the <a
            href="https://disqus.com/?ref_noscript" rel="nofollow">comments
            powered by Disqus.</a></noscript></div>
<script>
    mermaid.initialize({startOnLoad:true});
    window.mermaid.init(undefined, document.querySelectorAll('.language-mermaid'));
</script>
            </section>
            <footer class="condensed">
                <ul class="social about-footer condensed"><li>
                        <a
                            href="https://github.com/seonghun120614"
                            target="_blank"
                            rel="noopener"
                            aria-label="github">
                            <i class="icon-github-circled"></i>
                        </a>
                    </li><li>
                        <a
                            href="mailto:seonghun120614@gmail.com"
                            target="_blank" rel="noopener" aria-label="email">
                            <i class="icon-mail-alt"></i>
                        </a>
                    </li></ul><nav class="navigation about-footer condensed">
                    <ul>
                        
                        <li>
                            <a href="/seonghun120614/about">About Me</a>
                        </li>
                        
                        <li>
                            <a href="/seonghun120614/categories/computerscience">Computer Science</a>
                        </li>
                        
                        <li>
                            <a href="/seonghun120614/categories/math">Math</a>
                        </li>
                        
                        <li>
                            <a href="/seonghun120614/categories/softwareengineering">Software Engineering</a>
                        </li>
                        
                    </ul>
                </nav><p class="about-footer condensed">&copy;
                    2025</p><div class="about-footer condensed">
                    <p>Dark Mode
                        <i class="icon-moon"></i>
                        <label class="switch" for="dark-toggle">
                            <input id="dark-toggle" type="checkbox"
                                class="dark-mode-toggle"
                                aria-label="Toggle dark mode">
                            <span class="slider round"
                                onclick="toggleDarkMode()"></span>
                        </label>
                    </p>
                </div>
            </footer>
        </main>
        
        <script type="text/javascript" src="/seonghun120614/assets/js/darkmode.js"></script>
        
        <script src="/seonghun120614/assets/js/simple-jekyll-search.min.js"></script>
        <script src="/seonghun120614/assets/js/search.js"></script>
        
        <script>
            window.addEventListener('scroll', () => {
                const scrollTop = window.scrollY;
                const docHeight = document.documentElement.scrollHeight - window.innerHeight;
                const scrollPercent = (scrollTop / docHeight) * 100;
                document.getElementById('scroll-progress').style.width = scrollPercent + '%';
            });
        </script>
    </body>
</html>